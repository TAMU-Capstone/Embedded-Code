/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals, dead_code)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const CONFIG_y: u8 = 1;
pub const CONFIG_m: u8 = 2;
pub const CONFIG_HOST_LINUX: u8 = 1;
pub const CONFIG_APPS_DIR: &[u8; 8] = b"../apps\0";
pub const CONFIG_BASE_DEFCONFIG: &[u8; 20] = b"nucleo-144:f746-nsh\0";
pub const CONFIG_BUILD_FLAT: u8 = 1;
pub const CONFIG_RAW_BINARY: u8 = 1;
pub const CONFIG_ARCH_HAVE_STDARG_H: u8 = 1;
pub const CONFIG_ARCH_HAVE_SETJMP: u8 = 1;
pub const CONFIG_ARCH_NONE_DEBUG_H: u8 = 1;
pub const CONFIG_FORTIFY_SOURCE: u8 = 0;
pub const CONFIG_NDEBUG: u8 = 1;
pub const CONFIG_DEBUG_ALERT: u8 = 1;
pub const CONFIG_ARCH_HAVE_STACKCHECK: u8 = 1;
pub const CONFIG_STACK_COLORATION: u8 = 1;
pub const CONFIG_STACK_USAGE_WARNING: u8 = 0;
pub const CONFIG_ARCH_HAVE_HEAPCHECK: u8 = 1;
pub const CONFIG_DEBUG_SYMBOLS: u8 = 1;
pub const CONFIG_ARCH_HAVE_CUSTOMOPT: u8 = 1;
pub const CONFIG_DEBUG_NOOPT: u8 = 1;
pub const CONFIG_DEBUG_OPT_UNUSED_SECTIONS: u8 = 1;
pub const CONFIG_DEBUG_LINK_MAP: u8 = 1;
pub const CONFIG_ARCH_ARM: u8 = 1;
pub const CONFIG_ARCH: &[u8; 4] = b"arm\0";
pub const CONFIG_ARM_TOOLCHAIN_GNU_EABI: u8 = 1;
pub const CONFIG_ARCH_CHIP_STM32F7: u8 = 1;
pub const CONFIG_ARCH_ARMV7M: u8 = 1;
pub const CONFIG_ARCH_CORTEXM7: u8 = 1;
pub const CONFIG_ARCH_FAMILY: &[u8; 8] = b"armv7-m\0";
pub const CONFIG_ARCH_CHIP: &[u8; 8] = b"stm32f7\0";
pub const CONFIG_ARM_THUMB: u8 = 1;
pub const CONFIG_ARM_HAVE_MPU_UNIFIED: u8 = 1;
pub const CONFIG_ARCH_HAVE_HARDFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_MEMFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_BUSFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_USAGEFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_ICACHE: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_DCACHE: u8 = 1;
pub const CONFIG_ARMV7M_ICACHE: u8 = 1;
pub const CONFIG_ARMV7M_DCACHE: u8 = 1;
pub const CONFIG_ARMV7M_DCACHE_WRITETHROUGH: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_ITCM: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_DTCM: u8 = 1;
pub const CONFIG_ARMV7M_DTCM: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_STACKCHECK: u8 = 1;
pub const CONFIG_ARCH_CHIP_STM32F746ZG: u8 = 1;
pub const CONFIG_STM32F7_STM32F74XX: u8 = 1;
pub const CONFIG_STM32F7_IO_CONFIG_Z: u8 = 1;
pub const CONFIG_STM32F7_STM32F746XX: u8 = 1;
pub const CONFIG_STM32F7_FLASH_CONFIG_G: u8 = 1;
pub const CONFIG_STM32F7_FLASH_OVERRIDE_DEFAULT: u8 = 1;
pub const CONFIG_STM32F7_HAVE_LTDC: u8 = 1;
pub const CONFIG_STM32F7_HAVE_FMC: u8 = 1;
pub const CONFIG_STM32F7_HAVE_ETHRNET: u8 = 1;
pub const CONFIG_STM32F7_HAVE_RNG: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SPI4: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SPI5: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SPI6: u8 = 1;
pub const CONFIG_STM32F7_HAVE_CAN2: u8 = 1;
pub const CONFIG_STM32F7_HAVE_DCMI: u8 = 1;
pub const CONFIG_STM32F7_HAVE_DMA2D: u8 = 1;
pub const CONFIG_STM32F7_HAVE_EXTERNAL_ULPI: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SAI1: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SAI2: u8 = 1;
pub const CONFIG_STM32F7_USART: u8 = 1;
pub const CONFIG_STM32F7_SYSCFG: u8 = 1;
pub const CONFIG_STM32F7_USART3: u8 = 1;
pub const CONFIG_STM32F7_SERIAL_DISABLE_REORDERING: u8 = 1;
pub const CONFIG_STM32F7_USART_BREAKS: u8 = 1;
pub const CONFIG_STM32F7_SERIALBRK_BSDCOMPAT: u8 = 1;
pub const CONFIG_STM32F7_HAVE_RTC_SUBSECONDS: u8 = 1;
pub const CONFIG_ARCH_BOARD: &[u8; 11] = b"nucleo-144\0";
pub const CONFIG_ARCH_TOOLCHAIN_GNU: u8 = 1;
pub const CONFIG_LTO_NONE: u8 = 1;
pub const CONFIG_ARCH_HAVE_IRQTRIGGER: u8 = 1;
pub const CONFIG_ARCH_HAVE_IRQPRIO: u8 = 1;
pub const CONFIG_ARCH_ICACHE: u8 = 1;
pub const CONFIG_ARCH_DCACHE: u8 = 1;
pub const CONFIG_ARCH_HAVE_FORK: u8 = 1;
pub const CONFIG_ARCH_HAVE_FPU: u8 = 1;
pub const CONFIG_ARCH_HAVE_MPU: u8 = 1;
pub const CONFIG_ARCH_HAVE_PROGMEM: u8 = 1;
pub const CONFIG_ARCH_HAVE_RESET: u8 = 1;
pub const CONFIG_ARCH_HAVE_TESTSET: u8 = 1;
pub const CONFIG_ARCH_HAVE_THREAD_LOCAL: u8 = 1;
pub const CONFIG_ARCH_HAVE_FETCHADD: u8 = 1;
pub const CONFIG_ARCH_HAVE_RTC_SUBSECONDS: u8 = 1;
pub const CONFIG_ARCH_HAVE_SYSCALL_HOOKS: u8 = 1;
pub const CONFIG_ARCH_HAVE_BACKTRACE: u8 = 1;
pub const CONFIG_ARCH_HAVE_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_PERF_EVENTS: u8 = 1;
pub const CONFIG_ARCH_HAVE_CPUINFO: u8 = 1;
pub const CONFIG_ARCH_HAVE_TCBINFO: u8 = 1;
pub const CONFIG_ARCH_STACKDUMP: u8 = 1;
pub const CONFIG_ARCH_STACKDUMP_MAX_LENGTH: u8 = 0;
pub const CONFIG_ARCH_HAVE_RAMVECTORS: u8 = 1;
pub const CONFIG_BOARD_LOOPSPERMSEC: u16 = 43103;
pub const CONFIG_ARCH_HAVE_INTERRUPTSTACK: u8 = 1;
pub const CONFIG_ARCH_INTERRUPTSTACK: u8 = 0;
pub const CONFIG_ARCH_HAVE_HIPRI_INTERRUPT: u8 = 1;
pub const CONFIG_BOOT_RUNFROMFLASH: u8 = 1;
pub const CONFIG_RAM_START: u32 = 536936448;
pub const CONFIG_RAM_SIZE: u32 = 245760;
pub const CONFIG_ARCH_BOARD_NUCLEO_144: u8 = 1;
pub const CONFIG_ARCH_HAVE_LEDS: u8 = 1;
pub const CONFIG_ARCH_LEDS: u8 = 1;
pub const CONFIG_ARCH_HAVE_BUTTONS: u8 = 1;
pub const CONFIG_ARCH_BUTTONS: u8 = 1;
pub const CONFIG_ARCH_HAVE_IRQBUTTONS: u8 = 1;
pub const CONFIG_NUCLEO_CONSOLE_VIRTUAL: u8 = 1;
pub const CONFIG_BOARDCTL: u8 = 1;
pub const CONFIG_BOARDCTL_MKRD: u8 = 1;
pub const CONFIG_BOARD_MEMORY_RANGE: &[u8; 1] = b"\0";
pub const CONFIG_DISABLE_OS_API: u8 = 1;
pub const CONFIG_ARCH_HAVE_TICKLESS: u8 = 1;
pub const CONFIG_USEC_PER_TICK: u16 = 10000;
pub const CONFIG_ARCH_HAVE_TIMEKEEPING: u8 = 1;
pub const CONFIG_START_YEAR: u16 = 2015;
pub const CONFIG_START_MONTH: u8 = 11;
pub const CONFIG_START_DAY: u8 = 30;
pub const CONFIG_PREALLOC_TIMERS: u8 = 4;
pub const CONFIG_INIT_ENTRY: u8 = 1;
pub const CONFIG_INIT_STACKSIZE: u16 = 2048;
pub const CONFIG_INIT_PRIORITY: u8 = 100;
pub const CONFIG_INIT_ENTRYNAME: &[u8; 9] = b"nsh_main\0";
pub const CONFIG_RR_INTERVAL: u8 = 200;
pub const CONFIG_TASK_NAME_SIZE: u8 = 0;
pub const CONFIG_SCHED_WAITPID: u8 = 1;
pub const CONFIG_PTHREAD_MUTEX_ROBUST: u8 = 1;
pub const CONFIG_PTHREAD_MUTEX_DEFAULT_PRIO_NONE: u8 = 1;
pub const CONFIG_PTHREAD_CLEANUP_STACKSIZE: u8 = 0;
pub const CONFIG_SCHED_CPULOAD_NONE: u8 = 1;
pub const CONFIG_SCHED_STACK_RECORD: u8 = 0;
pub const CONFIG_DEV_CONSOLE: u8 = 1;
pub const CONFIG_NFILE_DESCRIPTORS_PER_BLOCK: u8 = 8;
pub const CONFIG_FILE_STREAM: u8 = 1;
pub const CONFIG_NAME_MAX: u8 = 32;
pub const CONFIG_PATH_MAX: u16 = 256;
pub const CONFIG_SIG_PREALLOC_IRQ_ACTIONS: u8 = 8;
pub const CONFIG_PREALLOC_MQ_MSGS: u8 = 8;
pub const CONFIG_PREALLOC_MQ_IRQ_MSGS: u8 = 8;
pub const CONFIG_MQ_MAXMSGSIZE: u8 = 32;
pub const CONFIG_DEFAULT_TASK_STACKSIZE: u16 = 2048;
pub const CONFIG_IDLETHREAD_STACKSIZE: u16 = 1024;
pub const CONFIG_PTHREAD_STACK_MIN: u16 = 256;
pub const CONFIG_PTHREAD_STACK_DEFAULT: u16 = 2048;
pub const CONFIG_ARCH_HAVE_I2CRESET: u8 = 1;
pub const CONFIG_ARCH_HAVE_SPI_BITORDER: u8 = 1;
pub const CONFIG_SPI: u8 = 1;
pub const CONFIG_SPI_EXCHANGE: u8 = 1;
pub const CONFIG_DEV_NULL: u8 = 1;
pub const CONFIG_DEV_OPTEE_NONE: u8 = 1;
pub const CONFIG_DRVR_MKRD: u8 = 1;
pub const CONFIG_ARCH_HAVE_RDWR_MEM_CPU_RUN: u8 = 1;
pub const CONFIG_ARCH_HAVE_SERIAL_TERMIOS: u8 = 1;
pub const CONFIG_SERIAL: u8 = 1;
pub const CONFIG_SERIAL_CONSOLE: u8 = 1;
pub const CONFIG_MCU_SERIAL: u8 = 1;
pub const CONFIG_STANDARD_SERIAL: u8 = 1;
pub const CONFIG_SERIAL_NPOLLWAITERS: u8 = 4;
pub const CONFIG_USART3_SERIAL_CONSOLE: u8 = 1;
pub const CONFIG_USART3_SERIALDRIVER: u8 = 1;
pub const CONFIG_USART3_RXBUFSIZE: u16 = 256;
pub const CONFIG_USART3_TXBUFSIZE: u16 = 256;
pub const CONFIG_USART3_BAUD: u32 = 115200;
pub const CONFIG_USART3_BITS: u8 = 8;
pub const CONFIG_USART3_PARITY: u8 = 0;
pub const CONFIG_USART3_2STOP: u8 = 0;
pub const CONFIG_SYSLOG_MAX_CHANNELS: u8 = 1;
pub const CONFIG_SYSLOG_DEVPATH: &[u8; 11] = b"/dev/ttyS1\0";
pub const CONFIG_SYSLOG_DEFAULT: u8 = 1;
pub const CONFIG_FS_NEPOLL_DESCRIPTORS: u8 = 8;
pub const CONFIG_SENDFILE_BUFSIZE: u16 = 512;
pub const CONFIG_FS_MQUEUE_VFS_PATH: &[u8; 12] = b"/var/mqueue\0";
pub const CONFIG_FS_MQUEUE_NPOLLWAITERS: u8 = 4;
pub const CONFIG_FS_ANONMAP: u8 = 1;
pub const CONFIG_NXFONTS_PACKEDMSFIRST: u8 = 1;
pub const CONFIG_MM_DEFAULT_MANAGER: u8 = 1;
pub const CONFIG_MM_DFAULT_ALIGNMENT: u8 = 0;
pub const CONFIG_MM_REGIONS: u8 = 2;
pub const CONFIG_MM_MAP_COUNT_MAX: u16 = 1024;
pub const CONFIG_MM_HEAP_MEMPOOL_THRESHOLD: u8 = 0;
pub const CONFIG_MM_BACKTRACE: i8 = -1;
pub const CONFIG_MM_FREE_DELAYCOUNT_MAX: u8 = 0;
pub const CONFIG_BINFMT_ELF_RELOCATABLE: u8 = 1;
pub const CONFIG_STDIO_BUFFER_SIZE: u8 = 64;
pub const CONFIG_STDIO_LINEBUFFER: u8 = 1;
pub const CONFIG_NUNGET_CHARS: u8 = 2;
pub const CONFIG_LIBC_LONG_LONG: u8 = 1;
pub const CONFIG_ARCH_LOWPUTC: u8 = 1;
pub const CONFIG_LIBC_RAND_ORDER: u8 = 1;
pub const CONFIG_LIBC_HOMEDIR: &[u8; 2] = b"/\0";
pub const CONFIG_LIBC_TMPDIR: &[u8; 5] = b"/tmp\0";
pub const CONFIG_LIBC_MAX_TMPFILE: u8 = 32;
pub const CONFIG_LIBC_MAX_EXITFUNS: u8 = 0;
pub const CONFIG_POSIX_SPAWN_DEFAULT_STACKSIZE: u16 = 2048;
pub const CONFIG_LIBC_HOSTNAME: &[u8; 1] = b"\0";
pub const CONFIG_LIBC_OPEN_MAX: u16 = 256;
pub const CONFIG_LIBC_STRERROR_ERRNUM: u8 = 1;
pub const CONFIG_LIBC_STRSIGNAL: u8 = 1;
pub const CONFIG_TLS_NELEM: u8 = 0;
pub const CONFIG_TLS_TASK_NELEM: u8 = 0;
pub const CONFIG_LIBC_GAISTRERROR_ERRNUM: u8 = 1;
pub const CONFIG_LIBC_FTOK_VFS_PATH: &[u8; 10] = b"/var/ftok\0";
pub const CONFIG_LIBC_MEMFD_ERROR: u8 = 1;
pub const CONFIG_BUILTIN: u8 = 1;
pub const CONFIG_STREAM_OUT_BUFFER_SIZE: u8 = 64;
pub const CONFIG_STREAM_HEXDUMP_BUFFER_SIZE: u8 = 128;
pub const CONFIG_LIBM_TOOLCHAIN: u8 = 1;
pub const CONFIG_HAVE_CXX: u8 = 1;
pub const CONFIG_HAVE_CXXINITIALIZE: u8 = 1;
pub const CONFIG_LIBCXXMINI: u8 = 1;
pub const CONFIG_CXX_STANDARD: &[u8; 8] = b"gnu++17\0";
pub const CONFIG_NSH_LIBRARY: u8 = 1;
pub const CONFIG_NSH_PROMPT_STRING: &[u8; 6] = b"nsh> \0";
pub const CONFIG_NSH_READLINE: u8 = 1;
pub const CONFIG_NSH_LINELEN: u8 = 64;
pub const CONFIG_NSH_QUOTE: u8 = 1;
pub const CONFIG_NSH_MAXARGUMENTS: u8 = 7;
pub const CONFIG_NSH_ARGCAT: u8 = 1;
pub const CONFIG_NSH_NESTDEPTH: u8 = 3;
pub const CONFIG_NSH_ALIAS: u8 = 1;
pub const CONFIG_NSH_ALIAS_MAX_AMOUNT: u8 = 1;
pub const CONFIG_NSH_BUILTIN_APPS: u8 = 1;
pub const CONFIG_NSH_DISABLE_DATE: u8 = 1;
pub const CONFIG_NSH_DISABLE_IFUPDOWN: u8 = 1;
pub const CONFIG_NSH_DISABLE_LOSMART: u8 = 1;
pub const CONFIG_NSH_DISABLE_LOMTD: u8 = 1;
pub const CONFIG_NSH_DISABLE_MB: u8 = 1;
pub const CONFIG_NSH_DISABLE_MH: u8 = 1;
pub const CONFIG_NSH_DISABLE_MW: u8 = 1;
pub const CONFIG_NSH_DISABLE_TIMEDATECTL: u8 = 1;
pub const CONFIG_NSH_CODECS_BUFSIZE: u8 = 128;
pub const CONFIG_NSH_CMDOPT_HEXDUMP: u8 = 1;
pub const CONFIG_NSH_FILEIOSIZE: u16 = 512;
pub const CONFIG_NSH_SYSINITSCRIPT: &[u8; 18] = b"init.d/rc.sysinit\0";
pub const CONFIG_NSH_INITSCRIPT: &[u8; 11] = b"init.d/rcS\0";
pub const CONFIG_NSH_SCRIPT_REDIRECT_PATH: &[u8; 1] = b"\0";
pub const CONFIG_NSH_CONSOLE: u8 = 1;
pub const CONFIG_SYSTEM_NSH: u8 = 1;
pub const CONFIG_SYSTEM_NSH_PRIORITY: u8 = 100;
pub const CONFIG_SYSTEM_NSH_STACKSIZE: u16 = 2048;
pub const CONFIG_SYSTEM_NSH_PROGNAME: &[u8; 4] = b"nsh\0";
pub const CONFIG_SYSTEM_READLINE: u8 = 1;
pub const CONFIG_READLINE_HAVE_EXTMATCH: u8 = 1;
pub const CONFIG_READLINE_ECHO: u8 = 1;
pub const CONFIG_RAM_END: u32 = 537182208;
pub const CONFIG_HAVE_ANONYMOUS_STRUCT: u8 = 1;
pub const CONFIG_HAVE_ANONYMOUS_UNION: u8 = 1;
pub const CONFIG_C99_BOOL: u8 = 1;
pub const CONFIG_DESIGNATED_INITIALIZERS: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_BSWAP16: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_BSWAP32: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_BSWAP64: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_CTZ: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_CLZ: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_POPCOUNT: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_POPCOUNTLL: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_FFS: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_FFSL: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_FFSLL: u8 = 1;
pub const CONFIG_CPP_HAVE_VARARGS: u8 = 1;
pub const CONFIG_CPP_HAVE_WARNING: u8 = 1;
pub const CONFIG_HAVE_FUNCTIONNAME: u8 = 1;
pub const CONFIG_HAVE_FILENAME: u8 = 1;
pub const CONFIG_HAVE_WEAKFUNCTIONS: u8 = 1;
pub const CONFIG_HAVE_LONG_LONG: u8 = 1;
pub const CONFIG_HAVE_FLOAT: u8 = 1;
pub const CONFIG_HAVE_DOUBLE: u8 = 1;
pub const CONFIG_HAVE_LONG_DOUBLE: u8 = 1;
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIdPTR: &[u8; 2] = b"d\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIiPTR: &[u8; 2] = b"i\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIoPTR: &[u8; 2] = b"o\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIuPTR: &[u8; 2] = b"u\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIxPTR: &[u8; 2] = b"x\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIXPTR: &[u8; 2] = b"X\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNdPTR: &[u8; 2] = b"d\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNiPTR: &[u8; 2] = b"i\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNoPTR: &[u8; 2] = b"o\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNuPTR: &[u8; 2] = b"u\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNxPTR: &[u8; 2] = b"x\0";
pub const CHAR_BIT: u8 = 8;
pub const SCHAR_MAX: u8 = 127;
pub const UCHAR_MAX: u8 = 255;
pub const CHAR_MIN: u8 = 0;
pub const CHAR_MAX: u8 = 255;
pub const SHRT_MAX: u16 = 32767;
pub const USHRT_MAX: u16 = 65535;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i8 = -1;
pub const PTR_MAX: u32 = 2147483647;
pub const UPTR_MAX: u32 = 4294967295;
pub const WCHAR_MIN: u8 = 0;
pub const MB_LEN_MAX: u8 = 4;
pub const _POSIX_ARG_MAX: u16 = 4096;
pub const _POSIX_CHILD_MAX: u8 = 6;
pub const _POSIX_LINK_MAX: u8 = 8;
pub const _POSIX_MAX_CANON: u8 = 255;
pub const _POSIX_MAX_INPUT: u8 = 255;
pub const _POSIX_NAME_MAX: u8 = 32;
pub const _POSIX_NGROUPS_MAX: u8 = 0;
pub const _POSIX_OPEN_MAX: u8 = 16;
pub const _POSIX_PATH_MAX: u16 = 256;
pub const _POSIX_PIPE_BUF: u16 = 512;
pub const _POSIX_STREAM_MAX: u8 = 16;
pub const _POSIX_TZNAME_MAX: u8 = 3;
pub const _POSIX_SIZE_MAX: u32 = 4294967295;
pub const _POSIX_SIZE_MIN: u8 = 0;
pub const _POSIX_SSIZE_MAX: u32 = 2147483647;
pub const _POSIX_RTSIG_MAX: u8 = 8;
pub const _POSIX_SIGQUEUE_MAX: u8 = 32;
pub const _POSIX_SYMLOOP_MAX: u8 = 8;
pub const _POSIX_DELAYTIMER_MAX: u8 = 32;
pub const _POSIX_TIMER_MAX: u8 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 10000000;
pub const _POSIX_AIO_LISTIO_MAX: u8 = 2;
pub const _POSIX_AIO_MAX: u8 = 1;
pub const _POSIX_MQ_OPEN_MAX: u8 = 8;
pub const _POSIX_MQ_PRIO_MAX: u8 = 255;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 2147483647;
pub const _POSIX_SEM_VALUE_MAX: u16 = 32767;
pub const ARG_MAX: u16 = 4096;
pub const CHILD_MAX: u8 = 6;
pub const LINK_MAX: u8 = 8;
pub const MAX_CANON: u8 = 255;
pub const MAX_INPUT: u8 = 255;
pub const NAME_MAX: u8 = 32;
pub const TTY_NAME_MAX: u8 = 32;
pub const NGROUPS_MAX: u8 = 0;
pub const OPEN_MAX: u16 = 256;
pub const PATH_MAX: u16 = 256;
pub const PIPE_BUF: u16 = 512;
pub const SIZE_MAX: u32 = 4294967295;
pub const SIZE_MIN: u8 = 0;
pub const RSIZE_MAX: u32 = 4294967295;
pub const SSIZE_MAX: u32 = 2147483647;
pub const STREAM_MAX: u8 = 16;
pub const TZNAME_MAX: u8 = 3;
pub const RTSIG_MAX: u8 = 32;
pub const SIGQUEUE_MAX: u8 = 32;
pub const SYMLOOP_MAX: u8 = 8;
pub const DELAYTIMER_MAX: u8 = 32;
pub const TIMER_MAX: u8 = 32;
pub const CLOCKRES_MIN: u32 = 10000000;
pub const CHARCLASS_NAME_MAX: u8 = 14;
pub const NL_LANGMAX: u8 = 14;
pub const NL_MSGMAX: u16 = 32767;
pub const NL_SETMAX: u8 = 255;
pub const AIO_LISTIO_MAX: u8 = 2;
pub const AIO_MAX: u8 = 1;
pub const MQ_OPEN_MAX: u8 = 8;
pub const MQ_PRIO_MAX: u8 = 255;
pub const SEM_NSEMS_MAX: u32 = 2147483647;
pub const SEM_VALUE_MAX: u16 = 32767;
pub const IOV_MAX: u32 = 2147483647;
pub const HOST_NAME_MAX: u8 = 32;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const TRUE: u8 = 1;
pub const FALSE: u8 = 0;
pub const SEEK_SET: u8 = 0;
pub const SEEK_CUR: u8 = 1;
pub const SEEK_END: u8 = 2;
pub const CONFIG_SMP_NCPUS: u8 = 1;
pub const SCHED_PRIORITY_MAX: u8 = 255;
pub const SCHED_PRIORITY_DEFAULT: u8 = 100;
pub const SCHED_PRIORITY_MIN: u8 = 1;
pub const SCHED_PRIORITY_IDLE: u8 = 0;
pub const __bool_true_false_are_defined: u8 = 1;
pub const STM32_IRQ_RESERVED: u8 = 0;
pub const STM32_IRQ_NMI: u8 = 2;
pub const STM32_IRQ_HARDFAULT: u8 = 3;
pub const STM32_IRQ_MEMFAULT: u8 = 4;
pub const STM32_IRQ_BUSFAULT: u8 = 5;
pub const STM32_IRQ_USAGEFAULT: u8 = 6;
pub const STM32_IRQ_SVCALL: u8 = 11;
pub const STM32_IRQ_DBGMONITOR: u8 = 12;
pub const STM32_IRQ_PENDSV: u8 = 14;
pub const STM32_IRQ_SYSTICK: u8 = 15;
pub const STM32_IRQ_FIRST: u8 = 16;
pub const STM32_IRQ_WWDG: u8 = 16;
pub const STM32_IRQ_PVD: u8 = 17;
pub const STM32_IRQ_TAMPER: u8 = 18;
pub const STM32_IRQ_TIMESTAMP: u8 = 18;
pub const STM32_IRQ_RTC_WKUP: u8 = 19;
pub const STM32_IRQ_FLASH: u8 = 20;
pub const STM32_IRQ_RCC: u8 = 21;
pub const STM32_IRQ_EXTI0: u8 = 22;
pub const STM32_IRQ_EXTI1: u8 = 23;
pub const STM32_IRQ_EXTI2: u8 = 24;
pub const STM32_IRQ_EXTI3: u8 = 25;
pub const STM32_IRQ_EXTI4: u8 = 26;
pub const STM32_IRQ_DMA1S0: u8 = 27;
pub const STM32_IRQ_DMA1S1: u8 = 28;
pub const STM32_IRQ_DMA1S2: u8 = 29;
pub const STM32_IRQ_DMA1S3: u8 = 30;
pub const STM32_IRQ_DMA1S4: u8 = 31;
pub const STM32_IRQ_DMA1S5: u8 = 32;
pub const STM32_IRQ_DMA1S6: u8 = 33;
pub const STM32_IRQ_ADC: u8 = 34;
pub const STM32_IRQ_CAN1TX: u8 = 35;
pub const STM32_IRQ_CAN1RX0: u8 = 36;
pub const STM32_IRQ_CAN1RX1: u8 = 37;
pub const STM32_IRQ_CAN1SCE: u8 = 38;
pub const STM32_IRQ_EXTI95: u8 = 39;
pub const STM32_IRQ_TIM1BRK: u8 = 40;
pub const STM32_IRQ_TIM9: u8 = 40;
pub const STM32_IRQ_TIM1UP: u8 = 41;
pub const STM32_IRQ_TIM10: u8 = 41;
pub const STM32_IRQ_TIM1TRGCOM: u8 = 42;
pub const STM32_IRQ_TIM11: u8 = 42;
pub const STM32_IRQ_TIM1CC: u8 = 43;
pub const STM32_IRQ_TIM2: u8 = 44;
pub const STM32_IRQ_TIM3: u8 = 45;
pub const STM32_IRQ_TIM4: u8 = 46;
pub const STM32_IRQ_I2C1EV: u8 = 47;
pub const STM32_IRQ_I2C1ER: u8 = 48;
pub const STM32_IRQ_I2C2EV: u8 = 49;
pub const STM32_IRQ_I2C2ER: u8 = 50;
pub const STM32_IRQ_SPI1: u8 = 51;
pub const STM32_IRQ_SPI2: u8 = 52;
pub const STM32_IRQ_USART1: u8 = 53;
pub const STM32_IRQ_USART2: u8 = 54;
pub const STM32_IRQ_USART3: u8 = 55;
pub const STM32_IRQ_EXTI1510: u8 = 56;
pub const STM32_IRQ_RTCALRM: u8 = 57;
pub const STM32_IRQ_OTGFSWKUP: u8 = 58;
pub const STM32_IRQ_TIM8BRK: u8 = 59;
pub const STM32_IRQ_TIM12: u8 = 59;
pub const STM32_IRQ_TIM8UP: u8 = 60;
pub const STM32_IRQ_TIM13: u8 = 60;
pub const STM32_IRQ_TIM8TRGCOM: u8 = 61;
pub const STM32_IRQ_TIM14: u8 = 61;
pub const STM32_IRQ_TIM8CC: u8 = 62;
pub const STM32_IRQ_DMA1S7: u8 = 63;
pub const STM32_IRQ_FMC: u8 = 64;
pub const STM32_IRQ_SDMMC1: u8 = 65;
pub const STM32_IRQ_TIM5: u8 = 66;
pub const STM32_IRQ_SPI3: u8 = 67;
pub const STM32_IRQ_UART4: u8 = 68;
pub const STM32_IRQ_UART5: u8 = 69;
pub const STM32_IRQ_TIM6: u8 = 70;
pub const STM32_IRQ_DAC: u8 = 70;
pub const STM32_IRQ_TIM7: u8 = 71;
pub const STM32_IRQ_DMA2S0: u8 = 72;
pub const STM32_IRQ_DMA2S1: u8 = 73;
pub const STM32_IRQ_DMA2S2: u8 = 74;
pub const STM32_IRQ_DMA2S3: u8 = 75;
pub const STM32_IRQ_DMA2S4: u8 = 76;
pub const STM32_IRQ_ETH: u8 = 77;
pub const STM32_IRQ_ETHWKUP: u8 = 78;
pub const STM32_IRQ_CAN2TX: u8 = 79;
pub const STM32_IRQ_CAN2RX0: u8 = 80;
pub const STM32_IRQ_CAN2RX1: u8 = 81;
pub const STM32_IRQ_CAN2SCE: u8 = 82;
pub const STM32_IRQ_OTGFS: u8 = 83;
pub const STM32_IRQ_DMA2S5: u8 = 84;
pub const STM32_IRQ_DMA2S6: u8 = 85;
pub const STM32_IRQ_DMA2S7: u8 = 86;
pub const STM32_IRQ_USART6: u8 = 87;
pub const STM32_IRQ_I2C3EV: u8 = 88;
pub const STM32_IRQ_I2C3ER: u8 = 89;
pub const STM32_IRQ_OTGHSEP1OUT: u8 = 90;
pub const STM32_IRQ_OTGHSEP1IN: u8 = 91;
pub const STM32_IRQ_OTGHSWKUP: u8 = 92;
pub const STM32_IRQ_OTGHS: u8 = 93;
pub const STM32_IRQ_DCMI: u8 = 94;
pub const STM32_IRQ_CRYP: u8 = 95;
pub const STM32_IRQ_HASH: u8 = 96;
pub const STM32_IRQ_RNG: u8 = 96;
pub const STM32_IRQ_FPU: u8 = 97;
pub const STM32_IRQ_UART7: u8 = 98;
pub const STM32_IRQ_UART8: u8 = 99;
pub const STM32_IRQ_SPI4: u8 = 100;
pub const STM32_IRQ_SPI5: u8 = 101;
pub const STM32_IRQ_SPI6: u8 = 102;
pub const STM32_IRQ_SAI1: u8 = 103;
pub const STM32_IRQ_LTDCINT: u8 = 104;
pub const STM32_IRQ_LTDCERRINT: u8 = 105;
pub const STM32_IRQ_DMA2D: u8 = 106;
pub const STM32_IRQ_SAI2: u8 = 107;
pub const STM32_IRQ_QUADSPI: u8 = 108;
pub const STM32_IRQ_LPTIMER1: u8 = 109;
pub const STM32_IRQ_HDMICEC: u8 = 110;
pub const STM32_IRQ_I2C4EV: u8 = 111;
pub const STM32_IRQ_I2C4ER: u8 = 112;
pub const STM32_IRQ_SPDIFRX: u8 = 113;
pub const STM32_IRQ_NEXTINTS: u8 = 98;
pub const NR_IRQS: u8 = 114;
pub const STM32F7_SRAM1_SIZE: u32 = 245760;
pub const STM32F7_SRAM2_SIZE: u16 = 16384;
pub const STM32F7_DTCM_SRAM_SIZE: u32 = 65536;
pub const STM32F7_ITCM_SRAM_SIZE: u16 = 16384;
pub const STM32F7_NSPDIFRX: u8 = 4;
pub const STM32F7_NGPIO: u8 = 11;
pub const STM32F7_NI2C: u8 = 4;
pub const STM32F7_NATIM: u8 = 2;
pub const STM32F7_NGTIM32: u8 = 2;
pub const STM32F7_NGTIM16: u8 = 2;
pub const STM32F7_NGTIMNDMA: u8 = 6;
pub const STM32F7_NBTIM: u8 = 2;
pub const STM32F7_NUART: u8 = 4;
pub const STM32F7_NUSART: u8 = 4;
pub const STM32F7_NI2S: u8 = 3;
pub const STM32F7_NUSBOTGFS: u8 = 1;
pub const STM32F7_NUSBOTGHS: u8 = 1;
pub const STM32F7_NSAI: u8 = 2;
pub const STM32F7_NDMA: u8 = 2;
pub const STM32F7_NADC: u8 = 3;
pub const STM32F7_NDAC: u8 = 2;
pub const STM32F7_NCAPSENSE: u8 = 0;
pub const STM32F7_NCRC: u8 = 1;
pub const STM32F7_NFMC: u8 = 1;
pub const STM32F7_NETHERNET: u8 = 1;
pub const STM32F7_NRNG: u8 = 1;
pub const STM32F7_NSPI: u8 = 6;
pub const STM32F7_NSDMMC: u8 = 1;
pub const STM32F7_NCAN: u8 = 2;
pub const STM32F7_NDCMI: u8 = 1;
pub const STM32F7_NDSIHOST: u8 = 0;
pub const STM32F7_NLCDTFT: u8 = 1;
pub const STM32F7_NDMA2D: u8 = 1;
pub const STM32F7_NJPEG: u8 = 0;
pub const STM32F7_NCRYP: u8 = 0;
pub const STM32F7_NHASH: u8 = 0;
pub const STM32F7_NDFSDM: u8 = 0;
pub const NVIC_SYSH_PRIORITY_MIN: u8 = 240;
pub const NVIC_SYSH_PRIORITY_DEFAULT: u8 = 128;
pub const NVIC_SYSH_PRIORITY_MAX: u8 = 0;
pub const NVIC_SYSH_PRIORITY_STEP: u8 = 16;
pub const NVIC_SYSH_MAXNORMAL_PRIORITY: u8 = 128;
pub const NVIC_SYSH_HIGH_PRIORITY: u8 = 96;
pub const NVIC_SYSH_DISABLE_PRIORITY: u8 = 128;
pub const NVIC_SYSH_SVCALL_PRIORITY: u8 = 112;
pub const CONFIG_SYS_NNEST: u8 = 2;
pub const REG_R13: u8 = 0;
pub const REG_PRIMASK: u8 = 1;
pub const REG_R4: u8 = 2;
pub const REG_R5: u8 = 3;
pub const REG_R6: u8 = 4;
pub const REG_R7: u8 = 5;
pub const REG_R8: u8 = 6;
pub const REG_R9: u8 = 7;
pub const REG_R10: u8 = 8;
pub const REG_R11: u8 = 9;
pub const REG_CONTROL: u8 = 10;
pub const REG_EXC_RETURN: u8 = 11;
pub const SW_INT_REGS: u8 = 12;
pub const SW_FPU_REGS: u8 = 0;
pub const SW_XCPT_REGS: u8 = 12;
pub const SW_XCPT_SIZE: u8 = 48;
pub const REG_R0: u8 = 12;
pub const REG_R1: u8 = 13;
pub const REG_R2: u8 = 14;
pub const REG_R3: u8 = 15;
pub const REG_R12: u8 = 16;
pub const REG_R14: u8 = 17;
pub const REG_R15: u8 = 18;
pub const REG_XPSR: u8 = 19;
pub const HW_INT_REGS: u8 = 8;
pub const HW_FPU_REGS: u8 = 0;
pub const HW_XCPT_REGS: u8 = 8;
pub const HW_XCPT_SIZE: u8 = 32;
pub const XCPTCONTEXT_REGS: u8 = 20;
pub const XCPTCONTEXT_SIZE: u8 = 80;
pub const REG_A1: u8 = 12;
pub const REG_A2: u8 = 13;
pub const REG_A3: u8 = 14;
pub const REG_A4: u8 = 15;
pub const REG_V1: u8 = 2;
pub const REG_V2: u8 = 3;
pub const REG_V3: u8 = 4;
pub const REG_V4: u8 = 5;
pub const REG_V5: u8 = 6;
pub const REG_V6: u8 = 7;
pub const REG_V7: u8 = 8;
pub const REG_SB: u8 = 7;
pub const REG_SL: u8 = 8;
pub const REG_FP: u8 = 5;
pub const REG_IP: u8 = 16;
pub const REG_SP: u8 = 0;
pub const REG_LR: u8 = 17;
pub const REG_PC: u8 = 18;
pub const REG_PIC: u8 = 8;
pub const CONTROL_FPCA: u8 = 4;
pub const CONTROL_SPSEL: u8 = 2;
pub const CONTROL_NPRIV: u8 = 1;
pub const STM32_GPIO_MODER_OFFSET: u8 = 0;
pub const STM32_GPIO_OTYPER_OFFSET: u8 = 4;
pub const STM32_GPIO_OSPEED_OFFSET: u8 = 8;
pub const STM32_GPIO_PUPDR_OFFSET: u8 = 12;
pub const STM32_GPIO_IDR_OFFSET: u8 = 16;
pub const STM32_GPIO_ODR_OFFSET: u8 = 20;
pub const STM32_GPIO_BSRR_OFFSET: u8 = 24;
pub const STM32_GPIO_LCKR_OFFSET: u8 = 28;
pub const STM32_GPIO_AFRL_OFFSET: u8 = 32;
pub const STM32_GPIO_AFRH_OFFSET: u8 = 36;
pub const GPIO_MODER_INPUT: u8 = 0;
pub const GPIO_MODER_OUTPUT: u8 = 1;
pub const GPIO_MODER_ALT: u8 = 2;
pub const GPIO_MODER_ANALOG: u8 = 3;
pub const GPIO_MODER0_SHIFT: u8 = 0;
pub const GPIO_MODER0_MASK: u8 = 3;
pub const GPIO_MODER1_SHIFT: u8 = 2;
pub const GPIO_MODER1_MASK: u8 = 12;
pub const GPIO_MODER2_SHIFT: u8 = 4;
pub const GPIO_MODER2_MASK: u8 = 48;
pub const GPIO_MODER3_SHIFT: u8 = 6;
pub const GPIO_MODER3_MASK: u8 = 192;
pub const GPIO_MODER4_SHIFT: u8 = 8;
pub const GPIO_MODER4_MASK: u16 = 768;
pub const GPIO_MODER5_SHIFT: u8 = 10;
pub const GPIO_MODER5_MASK: u16 = 3072;
pub const GPIO_MODER6_SHIFT: u8 = 12;
pub const GPIO_MODER6_MASK: u16 = 12288;
pub const GPIO_MODER7_SHIFT: u8 = 14;
pub const GPIO_MODER7_MASK: u16 = 49152;
pub const GPIO_MODER8_SHIFT: u8 = 16;
pub const GPIO_MODER8_MASK: u32 = 196608;
pub const GPIO_MODER9_SHIFT: u8 = 18;
pub const GPIO_MODER9_MASK: u32 = 786432;
pub const GPIO_MODER10_SHIFT: u8 = 20;
pub const GPIO_MODER10_MASK: u32 = 3145728;
pub const GPIO_MODER11_SHIFT: u8 = 22;
pub const GPIO_MODER11_MASK: u32 = 12582912;
pub const GPIO_MODER12_SHIFT: u8 = 24;
pub const GPIO_MODER12_MASK: u32 = 50331648;
pub const GPIO_MODER13_SHIFT: u8 = 26;
pub const GPIO_MODER13_MASK: u32 = 201326592;
pub const GPIO_MODER14_SHIFT: u8 = 28;
pub const GPIO_MODER14_MASK: u32 = 805306368;
pub const GPIO_MODER15_SHIFT: u8 = 30;
pub const GPIO_MODER15_MASK: u32 = 3221225472;
pub const GPIO_OSPEED_2MHz: u8 = 0;
pub const GPIO_OSPEED_25MHz: u8 = 1;
pub const GPIO_OSPEED_50MHz: u8 = 2;
pub const GPIO_OSPEED_100MHz: u8 = 3;
pub const GPIO_OSPEED0_SHIFT: u8 = 0;
pub const GPIO_OSPEED0_MASK: u8 = 3;
pub const GPIO_OSPEED1_SHIFT: u8 = 2;
pub const GPIO_OSPEED1_MASK: u8 = 12;
pub const GPIO_OSPEED2_SHIFT: u8 = 4;
pub const GPIO_OSPEED2_MASK: u8 = 48;
pub const GPIO_OSPEED3_SHIFT: u8 = 6;
pub const GPIO_OSPEED3_MASK: u8 = 192;
pub const GPIO_OSPEED4_SHIFT: u8 = 8;
pub const GPIO_OSPEED4_MASK: u16 = 768;
pub const GPIO_OSPEED5_SHIFT: u8 = 10;
pub const GPIO_OSPEED5_MASK: u16 = 3072;
pub const GPIO_OSPEED6_SHIFT: u8 = 12;
pub const GPIO_OSPEED6_MASK: u16 = 12288;
pub const GPIO_OSPEED7_SHIFT: u8 = 14;
pub const GPIO_OSPEED7_MASK: u16 = 49152;
pub const GPIO_OSPEED8_SHIFT: u8 = 16;
pub const GPIO_OSPEED8_MASK: u32 = 196608;
pub const GPIO_OSPEED9_SHIFT: u8 = 18;
pub const GPIO_OSPEED9_MASK: u32 = 786432;
pub const GPIO_OSPEED10_SHIFT: u8 = 20;
pub const GPIO_OSPEED10_MASK: u32 = 3145728;
pub const GPIO_OSPEED11_SHIFT: u8 = 22;
pub const GPIO_OSPEED11_MASK: u32 = 12582912;
pub const GPIO_OSPEED12_SHIFT: u8 = 24;
pub const GPIO_OSPEED12_MASK: u32 = 50331648;
pub const GPIO_OSPEED13_SHIFT: u8 = 26;
pub const GPIO_OSPEED13_MASK: u32 = 201326592;
pub const GPIO_OSPEED14_SHIFT: u8 = 28;
pub const GPIO_OSPEED14_MASK: u32 = 805306368;
pub const GPIO_OSPEED15_SHIFT: u8 = 30;
pub const GPIO_OSPEED15_MASK: u32 = 3221225472;
pub const GPIO_PUPDR_NONE: u8 = 0;
pub const GPIO_PUPDR_PULLUP: u8 = 1;
pub const GPIO_PUPDR_PULLDOWN: u8 = 2;
pub const GPIO_PUPDR0_SHIFT: u8 = 0;
pub const GPIO_PUPDR0_MASK: u8 = 3;
pub const GPIO_PUPDR1_SHIFT: u8 = 2;
pub const GPIO_PUPDR1_MASK: u8 = 12;
pub const GPIO_PUPDR2_SHIFT: u8 = 4;
pub const GPIO_PUPDR2_MASK: u8 = 48;
pub const GPIO_PUPDR3_SHIFT: u8 = 6;
pub const GPIO_PUPDR3_MASK: u8 = 192;
pub const GPIO_PUPDR4_SHIFT: u8 = 8;
pub const GPIO_PUPDR4_MASK: u16 = 768;
pub const GPIO_PUPDR5_SHIFT: u8 = 10;
pub const GPIO_PUPDR5_MASK: u16 = 3072;
pub const GPIO_PUPDR6_SHIFT: u8 = 12;
pub const GPIO_PUPDR6_MASK: u16 = 12288;
pub const GPIO_PUPDR7_SHIFT: u8 = 14;
pub const GPIO_PUPDR7_MASK: u16 = 49152;
pub const GPIO_PUPDR8_SHIFT: u8 = 16;
pub const GPIO_PUPDR8_MASK: u32 = 196608;
pub const GPIO_PUPDR9_SHIFT: u8 = 18;
pub const GPIO_PUPDR9_MASK: u32 = 786432;
pub const GPIO_PUPDR10_SHIFT: u8 = 20;
pub const GPIO_PUPDR10_MASK: u32 = 3145728;
pub const GPIO_PUPDR11_SHIFT: u8 = 22;
pub const GPIO_PUPDR11_MASK: u32 = 12582912;
pub const GPIO_PUPDR12_SHIFT: u8 = 24;
pub const GPIO_PUPDR12_MASK: u32 = 50331648;
pub const GPIO_PUPDR13_SHIFT: u8 = 26;
pub const GPIO_PUPDR13_MASK: u32 = 201326592;
pub const GPIO_PUPDR14_SHIFT: u8 = 28;
pub const GPIO_PUPDR14_MASK: u32 = 805306368;
pub const GPIO_PUPDR15_SHIFT: u8 = 30;
pub const GPIO_PUPDR15_MASK: u32 = 3221225472;
pub const GPIO_LCKK: u32 = 65536;
pub const GPIO_AFRL0_SHIFT: u8 = 0;
pub const GPIO_AFRL0_MASK: u8 = 15;
pub const GPIO_AFRL1_SHIFT: u8 = 4;
pub const GPIO_AFRL1_MASK: u8 = 240;
pub const GPIO_AFRL2_SHIFT: u8 = 8;
pub const GPIO_AFRL2_MASK: u16 = 3840;
pub const GPIO_AFRL3_SHIFT: u8 = 12;
pub const GPIO_AFRL3_MASK: u16 = 61440;
pub const GPIO_AFRL4_SHIFT: u8 = 16;
pub const GPIO_AFRL4_MASK: u32 = 983040;
pub const GPIO_AFRL5_SHIFT: u8 = 20;
pub const GPIO_AFRL5_MASK: u32 = 15728640;
pub const GPIO_AFRL6_SHIFT: u8 = 24;
pub const GPIO_AFRL6_MASK: u32 = 251658240;
pub const GPIO_AFRL7_SHIFT: u8 = 28;
pub const GPIO_AFRL7_MASK: u32 = 4026531840;
pub const GPIO_AFRH8_SHIFT: u8 = 0;
pub const GPIO_AFRH8_MASK: u8 = 15;
pub const GPIO_AFRH9_SHIFT: u8 = 4;
pub const GPIO_AFRH9_MASK: u8 = 240;
pub const GPIO_AFRH10_SHIFT: u8 = 8;
pub const GPIO_AFRH10_MASK: u16 = 3840;
pub const GPIO_AFRH11_SHIFT: u8 = 12;
pub const GPIO_AFRH11_MASK: u16 = 61440;
pub const GPIO_AFRH12_SHIFT: u8 = 16;
pub const GPIO_AFRH12_MASK: u32 = 983040;
pub const GPIO_AFRH13_SHIFT: u8 = 20;
pub const GPIO_AFRH13_MASK: u32 = 15728640;
pub const GPIO_AFRH14_SHIFT: u8 = 24;
pub const GPIO_AFRH14_MASK: u32 = 251658240;
pub const GPIO_AFRH15_SHIFT: u8 = 28;
pub const GPIO_AFRH15_MASK: u32 = 4026531840;
pub const STM32_CODE_BASE: u8 = 0;
pub const STM32_SRAM_BASE: u32 = 536870912;
pub const STM32_PERIPH_BASE: u32 = 1073741824;
pub const STM32_FMC_BASE12: u32 = 1610612736;
pub const STM32_FMC_BANK1: u32 = 1610612736;
pub const STM32_FMC_BANK2: u32 = 1879048192;
pub const STM32_FMC_BASE34: u32 = 2147483648;
pub const STM32_FMC_BANK3: u32 = 2147483648;
pub const STM32_FMC_BANK4: u32 = 2415919104;
pub const STM32_FMC_BASE5: u32 = 3221225472;
pub const STM32_FMC_BASE6: u32 = 3489660928;
pub const STM32_CORTEX_BASE: u32 = 3758096384;
pub const STM32_REGION_MASK: u32 = 4026531840;
pub const STM32_BOOT_BASE: u8 = 0;
pub const STM32_INSTRAM_BASE: u8 = 0;
pub const STM32_SYSMEM_ICTM: u32 = 1048576;
pub const STM32_FLASH_ITCM: u32 = 2097152;
pub const STM32_LOADER_BASE: u32 = 16777216;
pub const STM32_FLASH_AXIM: u32 = 134217728;
pub const STM32_FLASH_BASE: u32 = 134217728;
pub const STM32_OPTIONS_BASE: u32 = 536805376;
pub const STM32_SYSMEM_AXIM: u32 = 535822336;
pub const STM32_SYSMEM_UID: u32 = 535884832;
pub const STM32_OTP_ICTM: u32 = 1110016;
pub const STM32_OTP_AXIM: u32 = 535883776;
pub const STM32_OPT_BASE: u32 = 535883776;
pub const STM32_OPT_SIZE: u16 = 1056;
pub const STM32_DTCRAM_BASE: u32 = 536870912;
pub const STM32_SRAM1_BASE: u32 = 536936448;
pub const STM32_SRAM2_BASE: u32 = 537182208;
pub const STM32_APB1_BASE: u32 = 1073741824;
pub const STM32_APB2_BASE: u32 = 1073807360;
pub const STM32_AHB1_BASE: u32 = 1073872896;
pub const STM32_AHB2_BASE: u32 = 1342177280;
pub const STM32_AHB3_BASE: u32 = 1610612736;
pub const STM32_TIM2_BASE: u32 = 1073741824;
pub const STM32_TIM3_BASE: u32 = 1073742848;
pub const STM32_TIM4_BASE: u32 = 1073743872;
pub const STM32_TIM5_BASE: u32 = 1073744896;
pub const STM32_TIM6_BASE: u32 = 1073745920;
pub const STM32_TIM7_BASE: u32 = 1073746944;
pub const STM32_TIM12_BASE: u32 = 1073747968;
pub const STM32_TIM13_BASE: u32 = 1073748992;
pub const STM32_TIM14_BASE: u32 = 1073750016;
pub const STM32_LPTIM1_BASE: u32 = 1073751040;
pub const STM32_RTC_BASE: u32 = 1073752064;
pub const STM32_WWDG_BASE: u32 = 1073753088;
pub const STM32_IWDG_BASE: u32 = 1073754112;
pub const STM32_SPI2_BASE: u32 = 1073756160;
pub const STM32_I2S2_BASE: u32 = 1073756160;
pub const STM32_SPI3_BASE: u32 = 1073757184;
pub const STM32_I2S3_BASE: u32 = 1073757184;
pub const STM32_SPDIFRX_BASE: u32 = 1073758208;
pub const STM32_USART2_BASE: u32 = 1073759232;
pub const STM32_USART3_BASE: u32 = 1073760256;
pub const STM32_UART4_BASE: u32 = 1073761280;
pub const STM32_UART5_BASE: u32 = 1073762304;
pub const STM32_I2C1_BASE: u32 = 1073763328;
pub const STM32_I2C2_BASE: u32 = 1073764352;
pub const STM32_I2C3_BASE: u32 = 1073765376;
pub const STM32_I2C4_BASE: u32 = 1073766400;
pub const STM32_CAN1_BASE: u32 = 1073767424;
pub const STM32_CAN2_BASE: u32 = 1073768448;
pub const STM32_HDMICEC_BASE: u32 = 1073769472;
pub const STM32_PWR_BASE: u32 = 1073770496;
pub const STM32_DAC_BASE: u32 = 1073771520;
pub const STM32_UART7_BASE: u32 = 1073772544;
pub const STM32_UART8_BASE: u32 = 1073773568;
pub const STM32_TIM1_BASE: u32 = 1073807360;
pub const STM32_TIM8_BASE: u32 = 1073808384;
pub const STM32_USART1_BASE: u32 = 1073811456;
pub const STM32_USART6_BASE: u32 = 1073812480;
pub const STM32_ADC_BASE: u32 = 1073815552;
pub const STM32_ADC1_BASE: u32 = 1073815552;
pub const STM32_ADC2_BASE: u32 = 1073815808;
pub const STM32_ADC3_BASE: u32 = 1073816064;
pub const STM32_ADCCMN_BASE: u32 = 1073816320;
pub const STM32_SDMMC1_BASE: u32 = 1073818624;
pub const STM32_SPI1_BASE: u32 = 1073819648;
pub const STM32_SPI4_BASE: u32 = 1073820672;
pub const STM32_SYSCFG_BASE: u32 = 1073821696;
pub const STM32_EXTI_BASE: u32 = 1073822720;
pub const STM32_TIM9_BASE: u32 = 1073823744;
pub const STM32_TIM10_BASE: u32 = 1073824768;
pub const STM32_TIM11_BASE: u32 = 1073825792;
pub const STM32_SPI5_BASE: u32 = 1073827840;
pub const STM32_SPI6_BASE: u32 = 1073828864;
pub const STM32_SAI1_BASE: u32 = 1073829888;
pub const STM32_SAI2_BASE: u32 = 1073830912;
pub const STM32_LTDC_BASE: u32 = 1073833984;
pub const STM32_GPIOA_BASE: u32 = 1073872896;
pub const STM32_GPIOB_BASE: u32 = 1073873920;
pub const STM32_GPIOC_BASE: u32 = 1073874944;
pub const STM32_GPIOD_BASE: u32 = 1073875968;
pub const STM32_GPIOE_BASE: u32 = 1073876992;
pub const STM32_GPIOF_BASE: u32 = 1073878016;
pub const STM32_GPIOG_BASE: u32 = 1073879040;
pub const STM32_GPIOH_BASE: u32 = 1073880064;
pub const STM32_GPIOI_BASE: u32 = 1073881088;
pub const STM32_GPIOJ_BASE: u32 = 1073882112;
pub const STM32_GPIOK_BASE: u32 = 1073883136;
pub const STM32_CRC_BASE: u32 = 1073885184;
pub const STM32_RCC_BASE: u32 = 1073887232;
pub const STM32_FLASHIF_BASE: u32 = 1073888256;
pub const STM32_BKPSRAM_BASE: u32 = 1073889280;
pub const STM32_DMA1_BASE: u32 = 1073897472;
pub const STM32_DMA2_BASE: u32 = 1073898496;
pub const STM32_ETHMAC_BASE: u32 = 1073905664;
pub const STM32_DMA2D_BASE: u32 = 1073917952;
pub const STM32_USBOTGHS_BASE: u32 = 1074003968;
pub const STM32_USBOTGFS_BASE: u32 = 1342177280;
pub const STM32_DCMI_BASE: u32 = 1342504960;
pub const STM32_CRYP_BASE: u32 = 1342570496;
pub const STM32_HASH_BASE: u32 = 1342571520;
pub const STM32_RNG_BASE: u32 = 1342572544;
pub const STM32_FMCBANK1_BASE: u32 = 1610612736;
pub const STM32_FMCBANK2_BASE: u32 = 1879048192;
pub const STM32_FMCBANK3_BASE: u32 = 2147483648;
pub const STM32_FMCBANK4_BASE: u32 = 2415919104;
pub const STM32_FMC_BASE: u32 = 2684354560;
pub const STM32_QUADSPI_BASE: u32 = 2684358656;
pub const STM32_FMCBANK5_BASE: u32 = 3221225472;
pub const STM32_FMCBANK6_BASE: u32 = 3489660928;
pub const STM32_DEBUGMCU_BASE: u32 = 3758366720;
pub const ARMV7M_PERIPHERAL_INTERRUPTS: u8 = 98;
pub const ARMV7M_DCACHE_LINESIZE: u8 = 32;
pub const ARMV7M_ICACHE_LINESIZE: u8 = 32;
pub const OTG_EPTYPE_CTRL: u8 = 0;
pub const OTG_EPTYPE_ISOC: u8 = 1;
pub const OTG_EPTYPE_BULK: u8 = 2;
pub const OTG_EPTYPE_INTR: u8 = 3;
pub const OTG_PID_DATA0: u8 = 0;
pub const OTG_PID_DATA2: u8 = 1;
pub const OTG_PID_DATA1: u8 = 2;
pub const OTG_PID_MDATA: u8 = 3;
pub const OTG_PID_SETUP: u8 = 3;
pub const STM32_OTG_GOTGCTL_OFFSET: u8 = 0;
pub const STM32_OTG_GOTGINT_OFFSET: u8 = 4;
pub const STM32_OTG_GAHBCFG_OFFSET: u8 = 8;
pub const STM32_OTG_GUSBCFG_OFFSET: u8 = 12;
pub const STM32_OTG_GRSTCTL_OFFSET: u8 = 16;
pub const STM32_OTG_GINTSTS_OFFSET: u8 = 20;
pub const STM32_OTG_GINTMSK_OFFSET: u8 = 24;
pub const STM32_OTG_GRXSTSR_OFFSET: u8 = 28;
pub const STM32_OTG_GRXSTSP_OFFSET: u8 = 32;
pub const STM32_OTG_GRXFSIZ_OFFSET: u8 = 36;
pub const STM32_OTG_HNPTXFSIZ_OFFSET: u8 = 40;
pub const STM32_OTG_DIEPTXF0_OFFSET: u8 = 40;
pub const STM32_OTG_HNPTXSTS_OFFSET: u8 = 44;
pub const STM32_OTG_GCCFG_OFFSET: u8 = 56;
pub const STM32_OTG_CID_OFFSET: u8 = 60;
pub const STM32_OTG_HPTXFSIZ_OFFSET: u16 = 256;
pub const STM32_OTG_HCFG_OFFSET: u16 = 1024;
pub const STM32_OTG_HFIR_OFFSET: u16 = 1028;
pub const STM32_OTG_HFNUM_OFFSET: u16 = 1032;
pub const STM32_OTG_HPTXSTS_OFFSET: u16 = 1040;
pub const STM32_OTG_HAINT_OFFSET: u16 = 1044;
pub const STM32_OTG_HAINTMSK_OFFSET: u16 = 1048;
pub const STM32_OTG_HPRT_OFFSET: u16 = 1088;
pub const STM32_OTG_HCCHAR_CHOFFSET: u8 = 0;
pub const STM32_OTG_HCINT_CHOFFSET: u8 = 8;
pub const STM32_OTG_HCINTMSK_CHOFFSET: u8 = 12;
pub const STM32_OTG_HCTSIZ_CHOFFSET: u8 = 16;
pub const STM32_OTG_DCFG_OFFSET: u16 = 2048;
pub const STM32_OTG_DCTL_OFFSET: u16 = 2052;
pub const STM32_OTG_DSTS_OFFSET: u16 = 2056;
pub const STM32_OTG_DIEPMSK_OFFSET: u16 = 2064;
pub const STM32_OTG_DOEPMSK_OFFSET: u16 = 2068;
pub const STM32_OTG_DAINT_OFFSET: u16 = 2072;
pub const STM32_OTG_DAINTMSK_OFFSET: u16 = 2076;
pub const STM32_OTG_DVBUSDIS_OFFSET: u16 = 2088;
pub const STM32_OTG_DVBUSPULSE_OFFSET: u16 = 2092;
pub const STM32_OTG_DIEPEMPMSK_OFFSET: u16 = 2100;
pub const STM32_OTG_DIEPCTL_EPOFFSET: u8 = 0;
pub const STM32_OTG_DIEPINT_EPOFFSET: u8 = 8;
pub const STM32_OTG_DIEPTSIZ_EPOFFSET: u8 = 16;
pub const STM32_OTG_DTXFSTS_EPOFFSET: u8 = 24;
pub const STM32_OTG_DOEPCTL_EPOFFSET: u8 = 0;
pub const STM32_OTG_DOEPINT_EPOFFSET: u8 = 8;
pub const STM32_OTG_PCGCCTL_OFFSET: u16 = 3584;
pub const STM32_USBPHYC_PLL1_OFFSET: u8 = 0;
pub const STM32_USBPHYC_TUNE_OFFSET: u8 = 12;
pub const STM32_USBPHYC_LDO_OFFSET: u8 = 24;
pub const OTG_GOTGCTL_SRQSCS: u8 = 1;
pub const OTG_GOTGCTL_SRQ: u8 = 2;
pub const OTG_GOTGCTL_VBVALOEN: u8 = 4;
pub const OTG_GOTGCTL_VBVALOVAL: u8 = 8;
pub const OTG_GOTGCTL_AVALOEN: u8 = 16;
pub const OTG_GOTGCTL_AVALOVAL: u8 = 32;
pub const OTG_GOTGCTL_BVALOEN: u8 = 64;
pub const OTG_GOTGCTL_BVALOVAL: u8 = 128;
pub const OTG_GOTGCTL_HNGSCS: u16 = 256;
pub const OTG_GOTGCTL_HNPRQ: u16 = 512;
pub const OTG_GOTGCTL_HSHNPEN: u16 = 1024;
pub const OTG_GOTGCTL_DHNPEN: u16 = 2048;
pub const OTG_GOTGCTL_EHEN: u16 = 4096;
pub const OTG_GOTGCTL_CIDSTS: u32 = 65536;
pub const OTG_GOTGCTL_DBCT: u32 = 131072;
pub const OTG_GOTGCTL_ASVLD: u32 = 262144;
pub const OTG_GOTGCTL_BSVLD: u32 = 524288;
pub const OTG_GOTGCTL_OTGVER: u32 = 1048576;
pub const OTG_GOTGINT_SEDET: u8 = 4;
pub const OTG_GOTGINT_SRSSCHG: u16 = 256;
pub const OTG_GOTGINT_HNSSCHG: u16 = 512;
pub const OTG_GOTGINT_HNGDET: u32 = 131072;
pub const OTG_GOTGINT_ADTOCHG: u32 = 262144;
pub const OTG_GOTGINT_DBCDNE: u32 = 524288;
pub const OTG_GOTGINT_IDCHNG: u32 = 1048576;
pub const OTG_GAHBCFG_GINTMSK: u8 = 1;
pub const OTG_GAHBCFG_TXFELVL: u8 = 128;
pub const OTG_GAHBCFG_PTXFELVL: u16 = 256;
pub const OTG_GUSBCFG_TOCAL_SHIFT: u8 = 0;
pub const OTG_GUSBCFG_TOCAL_MASK: u8 = 7;
pub const OTG_GUSBCFG_ULPISEL: u8 = 16;
pub const OTG_GUSBCFG_PHYSEL: u8 = 64;
pub const OTG_GUSBCFG_SRPCAP: u16 = 256;
pub const OTG_GUSBCFG_HNPCAP: u16 = 512;
pub const OTG_GUSBCFG_TRDT_SHIFT: u8 = 10;
pub const OTG_GUSBCFG_TRDT_MASK: u16 = 15360;
pub const OTG_GUSBCFG_PHYLPC: u16 = 32768;
pub const OTG_GUSBCFG_ULPIFSLS: u32 = 131072;
pub const OTG_GUSBCFG_ULPIAR: u32 = 262144;
pub const OTG_GUSBCFG_ULPICSM: u32 = 524288;
pub const OTG_GUSBCFG_ULPIEVBUSD: u32 = 1048576;
pub const OTG_GUSBCFG_ULPIEVBUSI: u32 = 2097152;
pub const OTG_GUSBCFG_TSDPS: u32 = 4194304;
pub const OTG_GUSBCFG_PCCI: u32 = 8388608;
pub const OTG_GUSBCFG_PTCI: u32 = 16777216;
pub const OTG_GUSBCFG_ULPIIPD: u32 = 33554432;
pub const OTG_GUSBCFG_FHMOD: u32 = 536870912;
pub const OTG_GUSBCFG_FDMOD: u32 = 1073741824;
pub const OTG_GRSTCTL_CSRST: u8 = 1;
pub const OTG_GRSTCTL_HSRST: u8 = 2;
pub const OTG_GRSTCTL_FCRST: u8 = 4;
pub const OTG_GRSTCTL_RXFFLSH: u8 = 16;
pub const OTG_GRSTCTL_TXFFLSH: u8 = 32;
pub const OTG_GRSTCTL_TXFNUM_SHIFT: u8 = 6;
pub const OTG_GRSTCTL_TXFNUM_MASK: u16 = 1984;
pub const OTG_GRSTCTL_TXFNUM_HNONPER: u8 = 0;
pub const OTG_GRSTCTL_TXFNUM_HPER: u8 = 64;
pub const OTG_GRSTCTL_TXFNUM_HALL: u16 = 1024;
pub const OTG_GRSTCTL_TXFNUM_DALL: u16 = 1024;
pub const OTG_GRSTCTL_AHBIDL: u32 = 2147483648;
pub const OTG_GINTSTS_CMOD: u8 = 1;
pub const OTG_GINTSTS_DEVMODE: u8 = 0;
pub const OTG_GINTSTS_HOSTMODE: u8 = 1;
pub const OTG_GINT_MMIS: u8 = 2;
pub const OTG_GINT_OTG: u8 = 4;
pub const OTG_GINT_SOF: u8 = 8;
pub const OTG_GINT_RXFLVL: u8 = 16;
pub const OTG_GINT_NPTXFE: u8 = 32;
pub const OTG_GINT_GINAKEFF: u8 = 64;
pub const OTG_GINT_GONAKEFF: u8 = 128;
pub const OTG_GINT_RES89: u16 = 768;
pub const OTG_GINT_ESUSP: u16 = 1024;
pub const OTG_GINT_USBSUSP: u16 = 2048;
pub const OTG_GINT_USBRST: u16 = 4096;
pub const OTG_GINT_ENUMDNE: u16 = 8192;
pub const OTG_GINT_ISOODRP: u16 = 16384;
pub const OTG_GINT_EOPF: u16 = 32768;
pub const OTG_GINT_RES1617: u32 = 196608;
pub const OTG_GINT_IEP: u32 = 262144;
pub const OTG_GINT_OEP: u32 = 524288;
pub const OTG_GINT_IISOIXFR: u32 = 1048576;
pub const OTG_GINT_IISOOXFR: u32 = 2097152;
pub const OTG_GINT_IPXFR: u32 = 2097152;
pub const OTG_GINT_RES22: u32 = 4194304;
pub const OTG_GINT_DATAFSUSP: u32 = 4194304;
pub const OTG_GINT_RES23: u32 = 8388608;
pub const OTG_GINT_RSTDET: u32 = 8388608;
pub const OTG_GINT_HPRT: u32 = 16777216;
pub const OTG_GINT_HC: u32 = 33554432;
pub const OTG_GINT_PTXFE: u32 = 67108864;
pub const OTG_GINT_LPMINT: u32 = 134217728;
pub const OTG_GINT_RES27: u32 = 134217728;
pub const OTG_GINT_CIDSCHG: u32 = 268435456;
pub const OTG_GINT_DISC: u32 = 536870912;
pub const OTG_GINT_SRQ: u32 = 1073741824;
pub const OTG_GINT_WKUP: u32 = 2147483648;
pub const OTG_GRXSTSH_CHNUM_SHIFT: u8 = 0;
pub const OTG_GRXSTSH_CHNUM_MASK: u8 = 15;
pub const OTG_GRXSTSH_BCNT_SHIFT: u8 = 4;
pub const OTG_GRXSTSH_BCNT_MASK: u16 = 32752;
pub const OTG_GRXSTSH_DPID_SHIFT: u8 = 15;
pub const OTG_GRXSTSH_DPID_MASK: u32 = 98304;
pub const OTG_GRXSTSH_DPID_DATA0: u8 = 0;
pub const OTG_GRXSTSH_DPID_DATA2: u16 = 32768;
pub const OTG_GRXSTSH_DPID_DATA1: u32 = 65536;
pub const OTG_GRXSTSH_DPID_MDATA: u32 = 98304;
pub const OTG_GRXSTSH_PKTSTS_SHIFT: u8 = 17;
pub const OTG_GRXSTSH_PKTSTS_MASK: u32 = 1966080;
pub const OTG_GRXSTSH_PKTSTS_INRECVD: u32 = 262144;
pub const OTG_GRXSTSH_PKTSTS_INDONE: u32 = 393216;
pub const OTG_GRXSTSH_PKTSTS_DTOGERR: u32 = 655360;
pub const OTG_GRXSTSH_PKTSTS_HALTED: u32 = 917504;
pub const OTG_GRXSTSD_EPNUM_SHIFT: u8 = 0;
pub const OTG_GRXSTSD_EPNUM_MASK: u8 = 15;
pub const OTG_GRXSTSD_BCNT_SHIFT: u8 = 4;
pub const OTG_GRXSTSD_BCNT_MASK: u16 = 32752;
pub const OTG_GRXSTSD_DPID_SHIFT: u8 = 15;
pub const OTG_GRXSTSD_DPID_MASK: u32 = 98304;
pub const OTG_GRXSTSD_DPID_DATA0: u8 = 0;
pub const OTG_GRXSTSD_DPID_DATA2: u16 = 32768;
pub const OTG_GRXSTSD_DPID_DATA1: u32 = 65536;
pub const OTG_GRXSTSD_DPID_MDATA: u32 = 98304;
pub const OTG_GRXSTSD_PKTSTS_SHIFT: u8 = 17;
pub const OTG_GRXSTSD_PKTSTS_MASK: u32 = 1966080;
pub const OTG_GRXSTSD_PKTSTS_OUTNAK: u32 = 131072;
pub const OTG_GRXSTSD_PKTSTS_OUTRECVD: u32 = 262144;
pub const OTG_GRXSTSD_PKTSTS_OUTDONE: u32 = 393216;
pub const OTG_GRXSTSD_PKTSTS_SETUPDONE: u32 = 524288;
pub const OTG_GRXSTSD_PKTSTS_SETUPRECVD: u32 = 786432;
pub const OTG_GRXSTSD_FRMNUM_SHIFT: u8 = 21;
pub const OTG_GRXSTSD_FRMNUM_MASK: u32 = 31457280;
pub const OTG_GRXFSIZ_MASK: u16 = 65535;
pub const OTG_HNPTXFSIZ_NPTXFSA_SHIFT: u8 = 0;
pub const OTG_HNPTXFSIZ_NPTXFSA_MASK: u16 = 65535;
pub const OTG_HNPTXFSIZ_NPTXFD_SHIFT: u8 = 16;
pub const OTG_HNPTXFSIZ_NPTXFD_MASK: u32 = 4294901760;
pub const OTG_HNPTXFSIZ_NPTXFD_MIN: u32 = 1048576;
pub const OTG_HNPTXFSIZ_NPTXFD_MAX: u32 = 16777216;
pub const OTG_DIEPTXF0_TX0FD_SHIFT: u8 = 0;
pub const OTG_DIEPTXF0_TX0FD_MASK: u16 = 65535;
pub const OTG_DIEPTXF0_TX0FSA_SHIFT: u8 = 16;
pub const OTG_DIEPTXF0_TX0FSA_MASK: u32 = 4294901760;
pub const OTG_DIEPTXF0_TX0FSA_MIN: u32 = 1048576;
pub const OTG_DIEPTXF0_TX0FSA_MAX: u32 = 16777216;
pub const OTG_HNPTXSTS_NPTXFSAV_SHIFT: u8 = 0;
pub const OTG_HNPTXSTS_NPTXFSAV_MASK: u16 = 65535;
pub const OTG_HNPTXSTS_NPTXFSAV_FULL: u8 = 0;
pub const OTG_HNPTXSTS_NPTQXSAV_SHIFT: u8 = 16;
pub const OTG_HNPTXSTS_NPTQXSAV_MASK: u32 = 16711680;
pub const OTG_HNPTXSTS_NPTQXSAV_FULL: u8 = 0;
pub const OTG_HNPTXSTS_NPTXQTOP_SHIFT: u8 = 24;
pub const OTG_HNPTXSTS_NPTXQTOP_MASK: u32 = 2130706432;
pub const OTG_HNPTXSTS_TERMINATE: u32 = 16777216;
pub const OTG_HNPTXSTS_TYPE_SHIFT: u8 = 25;
pub const OTG_HNPTXSTS_TYPE_MASK: u32 = 100663296;
pub const OTG_HNPTXSTS_TYPE_INOUT: u8 = 0;
pub const OTG_HNPTXSTS_TYPE_ZLP: u32 = 33554432;
pub const OTG_HNPTXSTS_TYPE_HALT: u32 = 100663296;
pub const OTG_HNPTXSTS_CHNUM_SHIFT: u8 = 27;
pub const OTG_HNPTXSTS_CHNUM_MASK: u32 = 2013265920;
pub const OTG_HNPTXSTS_EPNUM_SHIFT: u8 = 27;
pub const OTG_HNPTXSTS_EPNUM_MASK: u32 = 2013265920;
pub const OTG_GCCFG_PWRDWN: u32 = 65536;
pub const OTG_GCCFG_VBDEN: u32 = 2097152;
pub const OTG_GCCFG_PHYHSEN: u32 = 8388608;
pub const OTG_HPTXFSIZ_PTXSA_SHIFT: u8 = 0;
pub const OTG_HPTXFSIZ_PTXSA_MASK: u16 = 65535;
pub const OTG_HPTXFSIZ_PTXFD_SHIFT: u8 = 16;
pub const OTG_HPTXFSIZ_PTXFD_MASK: u32 = 4294901760;
pub const OTG_DIEPTXF_INEPTXSA_SHIFT: u8 = 0;
pub const OTG_DIEPTXF_INEPTXSA_MASK: u16 = 65535;
pub const OTG_DIEPTXF_INEPTXFD_SHIFT: u8 = 16;
pub const OTG_DIEPTXF_INEPTXFD_MASK: u32 = 4294901760;
pub const OTG_DIEPTXF_INEPTXFD_MIN: u8 = 16;
pub const OTG_HCFG_FSLSPCS_SHIFT: u8 = 0;
pub const OTG_HCFG_FSLSPCS_MASK: u8 = 3;
pub const OTG_HCFG_FSLSPCS_FS48MHz: u8 = 1;
pub const OTG_HCFG_FSLSPCS_LS48MHz: u8 = 1;
pub const OTG_HCFG_FSLSPCS_LS6MHz: u8 = 2;
pub const OTG_HCFG_FSLSS: u8 = 4;
pub const OTG_HFIR_MASK: u16 = 65535;
pub const OTG_HFNUM_FRNUM_SHIFT: u8 = 0;
pub const OTG_HFNUM_FRNUM_MASK: u16 = 65535;
pub const OTG_HFNUM_FTREM_SHIFT: u8 = 16;
pub const OTG_HFNUM_FTREM_MASK: u32 = 4294901760;
pub const OTG_HPTXSTS_PTXFSAVL_SHIFT: u8 = 0;
pub const OTG_HPTXSTS_PTXFSAVL_MASK: u16 = 65535;
pub const OTG_HPTXSTS_PTXFSAVL_FULL: u8 = 0;
pub const OTG_HPTXSTS_PTXQSAV_SHIFT: u8 = 16;
pub const OTG_HPTXSTS_PTXQSAV_MASK: u32 = 16711680;
pub const OTG_HPTXSTS_PTXQSAV_FULL: u8 = 0;
pub const OTG_HPTXSTS_PTXQTOP_SHIFT: u8 = 24;
pub const OTG_HPTXSTS_PTXQTOP_MASK: u32 = 2130706432;
pub const OTG_HPTXSTS_TERMINATE: u32 = 16777216;
pub const OTG_HPTXSTS_TYPE_SHIFT: u8 = 25;
pub const OTG_HPTXSTS_TYPE_MASK: u32 = 100663296;
pub const OTG_HPTXSTS_TYPE_INOUT: u8 = 0;
pub const OTG_HPTXSTS_TYPE_ZLP: u32 = 33554432;
pub const OTG_HPTXSTS_TYPE_HALT: u32 = 100663296;
pub const OTG_HPTXSTS_EPNUM_SHIFT: u8 = 27;
pub const OTG_HPTXSTS_EPNUM_MASK: u32 = 2013265920;
pub const OTG_HPTXSTS_CHNUM_SHIFT: u8 = 27;
pub const OTG_HPTXSTS_CHNUM_MASK: u32 = 2013265920;
pub const OTG_HPTXSTS_ODD: u32 = 16777216;
pub const OTG_HPRT_PCSTS: u8 = 1;
pub const OTG_HPRT_PCDET: u8 = 2;
pub const OTG_HPRT_PENA: u8 = 4;
pub const OTG_HPRT_PENCHNG: u8 = 8;
pub const OTG_HPRT_POCA: u8 = 16;
pub const OTG_HPRT_POCCHNG: u8 = 32;
pub const OTG_HPRT_PRES: u8 = 64;
pub const OTG_HPRT_PSUSP: u8 = 128;
pub const OTG_HPRT_PRST: u16 = 256;
pub const OTG_HPRT_PLSTS_SHIFT: u8 = 10;
pub const OTG_HPRT_PLSTS_MASK: u16 = 3072;
pub const OTG_HPRT_PLSTS_DP: u16 = 1024;
pub const OTG_HPRT_PLSTS_DM: u16 = 2048;
pub const OTG_HPRT_PPWR: u16 = 4096;
pub const OTG_HPRT_PTCTL_SHIFT: u8 = 13;
pub const OTG_HPRT_PTCTL_MASK: u32 = 122880;
pub const OTG_HPRT_PTCTL_DISABLED: u8 = 0;
pub const OTG_HPRT_PTCTL_J: u16 = 8192;
pub const OTG_HPRT_PTCTL_L: u16 = 16384;
pub const OTG_HPRT_PTCTL_SE0_NAK: u16 = 24576;
pub const OTG_HPRT_PTCTL_PACKET: u16 = 32768;
pub const OTG_HPRT_PTCTL_FORCE: u16 = 40960;
pub const OTG_HPRT_PSPD_SHIFT: u8 = 17;
pub const OTG_HPRT_PSPD_MASK: u32 = 393216;
pub const OTG_HPRT_PSPD_FS: u32 = 131072;
pub const OTG_HPRT_PSPD_LS: u32 = 262144;
pub const OTG_HCCHAR_MPSIZ_SHIFT: u8 = 0;
pub const OTG_HCCHAR_MPSIZ_MASK: u16 = 2047;
pub const OTG_HCCHAR_EPNUM_SHIFT: u8 = 11;
pub const OTG_HCCHAR_EPNUM_MASK: u16 = 30720;
pub const OTG_HCCHAR_EPDIR: u16 = 32768;
pub const OTG_HCCHAR_EPDIR_OUT: u8 = 0;
pub const OTG_HCCHAR_EPDIR_IN: u16 = 32768;
pub const OTG_HCCHAR_LSDEV: u32 = 131072;
pub const OTG_HCCHAR_EPTYP_SHIFT: u8 = 18;
pub const OTG_HCCHAR_EPTYP_MASK: u32 = 786432;
pub const OTG_HCCHAR_EPTYP_CTRL: u8 = 0;
pub const OTG_HCCHAR_EPTYP_ISOC: u32 = 262144;
pub const OTG_HCCHAR_EPTYP_BULK: u32 = 524288;
pub const OTG_HCCHAR_EPTYP_INTR: u32 = 786432;
pub const OTG_HCCHAR_MCNT_SHIFT: u8 = 20;
pub const OTG_HCCHAR_MCNT_MASK: u32 = 3145728;
pub const OTG_HCCHAR_DAD_SHIFT: u8 = 22;
pub const OTG_HCCHAR_DAD_MASK: u32 = 532676608;
pub const OTG_HCCHAR_ODDFRM: u32 = 536870912;
pub const OTG_HCCHAR_CHDIS: u32 = 1073741824;
pub const OTG_HCCHAR_CHENA: u32 = 2147483648;
pub const OTG_HCINT_XFRC: u8 = 1;
pub const OTG_HCINT_CHH: u8 = 2;
pub const OTG_HCINT_STALL: u8 = 8;
pub const OTG_HCINT_NAK: u8 = 16;
pub const OTG_HCINT_ACK: u8 = 32;
pub const OTG_HCINT_NYET: u8 = 64;
pub const OTG_HCINT_TXERR: u8 = 128;
pub const OTG_HCINT_BBERR: u16 = 256;
pub const OTG_HCINT_FRMOR: u16 = 512;
pub const OTG_HCINT_DTERR: u16 = 1024;
pub const OTG_HCTSIZ_XFRSIZ_SHIFT: u8 = 0;
pub const OTG_HCTSIZ_XFRSIZ_MASK: u32 = 524287;
pub const OTG_HCTSIZ_PKTCNT_SHIFT: u8 = 19;
pub const OTG_HCTSIZ_PKTCNT_MASK: u32 = 536346624;
pub const OTG_HCTSIZ_DPID_SHIFT: u8 = 29;
pub const OTG_HCTSIZ_DPID_MASK: u32 = 1610612736;
pub const OTG_HCTSIZ_DPID_DATA0: u8 = 0;
pub const OTG_HCTSIZ_DPID_DATA2: u32 = 536870912;
pub const OTG_HCTSIZ_DPID_DATA1: u32 = 1073741824;
pub const OTG_HCTSIZ_DPID_MDATA: u32 = 1610612736;
pub const OTG_HCTSIZ_PID_SETUP: u32 = 1610612736;
pub const OTG_DCFG_DSPD_SHIFT: u8 = 0;
pub const OTG_DCFG_DSPD_MASK: u8 = 3;
pub const OTG_DCFG_DSPD_HS: u8 = 0;
pub const OTG_DCFG_DSPD_FS_USING_HS: u8 = 1;
pub const OTG_DCFG_DSPD_FS: u8 = 3;
pub const OTG_DCFG_NZLSOHSK: u8 = 4;
pub const OTG_DCFG_DAD_SHIFT: u8 = 4;
pub const OTG_DCFG_DAD_MASK: u16 = 2032;
pub const OTG_DCFG_PFIVL_SHIFT: u8 = 11;
pub const OTG_DCFG_PFIVL_MASK: u16 = 6144;
pub const OTG_DCFG_PFIVL_80PCT: u8 = 0;
pub const OTG_DCFG_PFIVL_85PCT: u16 = 2048;
pub const OTG_DCFG_PFIVL_90PCT: u16 = 4096;
pub const OTG_DCFG_PFIVL_95PCT: u16 = 6144;
pub const OTG_TESTMODE_DISABLED: u8 = 0;
pub const OTG_TESTMODE_J: u8 = 1;
pub const OTG_TESTMODE_K: u8 = 2;
pub const OTG_TESTMODE_SE0_NAK: u8 = 3;
pub const OTG_TESTMODE_PACKET: u8 = 4;
pub const OTG_TESTMODE_FORCE: u8 = 5;
pub const OTG_DCTL_RWUSIG: u8 = 1;
pub const OTG_DCTL_SDIS: u8 = 2;
pub const OTG_DCTL_GINSTS: u8 = 4;
pub const OTG_DCTL_GONSTS: u8 = 8;
pub const OTG_DCTL_TCTL_SHIFT: u8 = 4;
pub const OTG_DCTL_TCTL_MASK: u8 = 112;
pub const OTG_DCTL_TCTL_DISABLED: u8 = 0;
pub const OTG_DCTL_TCTL_J: u8 = 16;
pub const OTG_DCTL_TCTL_K: u8 = 32;
pub const OTG_DCTL_TCTL_SE0_NAK: u8 = 48;
pub const OTG_DCTL_TCTL_PACKET: u8 = 64;
pub const OTG_DCTL_TCTL_FORCE: u8 = 80;
pub const OTG_DCTL_SGINAK: u8 = 128;
pub const OTG_DCTL_CGINAK: u16 = 256;
pub const OTG_DCTL_SGONAK: u16 = 512;
pub const OTG_DCTL_CGONAK: u16 = 1024;
pub const OTG_DCTL_POPRGDNE: u16 = 2048;
pub const OTG_DSTS_SUSPSTS: u8 = 1;
pub const OTG_DSTS_ENUMSPD_SHIFT: u8 = 1;
pub const OTG_DSTS_ENUMSPD_MASK: u8 = 6;
pub const OTG_DSTS_ENUMSPD_FS: u8 = 192;
pub const OTG_DSTS_EERR: u8 = 8;
pub const OTG_DSTS_SOFFN_SHIFT: u8 = 8;
pub const OTG_DSTS_SOFFN_MASK: u32 = 4194048;
pub const OTG_DSTS_SOFFN0: u16 = 256;
pub const OTG_DSTS_SOFFN_EVEN: u8 = 0;
pub const OTG_DSTS_SOFFN_ODD: u16 = 256;
pub const OTG_DIEPMSK_XFRCM: u8 = 1;
pub const OTG_DIEPMSK_EPDM: u8 = 2;
pub const OTG_DIEPMSK_AHBERRM: u8 = 4;
pub const OTG_DIEPMSK_TOM: u8 = 8;
pub const OTG_DIEPMSK_ITTXFEMSK: u8 = 16;
pub const OTG_DIEPMSK_INEPNMM: u8 = 32;
pub const OTG_DIEPMSK_INEPNEM: u8 = 64;
pub const OTG_DIEPMSK_TXFURM: u16 = 256;
pub const OTG_DIEPMSK_NAKM: u16 = 8192;
pub const OTG_DOEPMSK_XFRCM: u8 = 1;
pub const OTG_DOEPMSK_EPDM: u8 = 2;
pub const OTG_DOEPMSK_STUPM: u8 = 8;
pub const OTG_DOEPMSK_OTEPDM: u8 = 16;
pub const OTG_DAINT_IEP_SHIFT: u8 = 0;
pub const OTG_DAINT_IEP_MASK: u16 = 65535;
pub const OTG_DAINT_OEP_SHIFT: u8 = 16;
pub const OTG_DAINT_OEP_MASK: u32 = 4294901760;
pub const OTG_DVBUSDIS_MASK: u16 = 65535;
pub const OTG_DVBUSPULSE_MASK: u16 = 4095;
pub const OTG_DIEPCTL0_MPSIZ_SHIFT: u8 = 0;
pub const OTG_DIEPCTL0_MPSIZ_MASK: u8 = 3;
pub const OTG_DIEPCTL0_MPSIZ_64: u8 = 0;
pub const OTG_DIEPCTL0_MPSIZ_32: u8 = 1;
pub const OTG_DIEPCTL0_MPSIZ_16: u8 = 2;
pub const OTG_DIEPCTL0_MPSIZ_8: u8 = 3;
pub const OTG_DIEPCTL0_USBAEP: u16 = 32768;
pub const OTG_DIEPCTL0_NAKSTS: u32 = 131072;
pub const OTG_DIEPCTL0_EPTYP_SHIFT: u8 = 18;
pub const OTG_DIEPCTL0_EPTYP_MASK: u32 = 786432;
pub const OTG_DIEPCTL0_EPTYP_CTRL: u8 = 0;
pub const OTG_DIEPCTL0_STALL: u32 = 2097152;
pub const OTG_DIEPCTL0_TXFNUM_SHIFT: u8 = 22;
pub const OTG_DIEPCTL0_TXFNUM_MASK: u32 = 62914560;
pub const OTG_DIEPCTL0_CNAK: u32 = 67108864;
pub const OTG_DIEPCTL0_SNAK: u32 = 134217728;
pub const OTG_DIEPCTL0_EPDIS: u32 = 1073741824;
pub const OTG_DIEPCTL0_EPENA: u32 = 2147483648;
pub const OTG_DIEPCTL_MPSIZ_SHIFT: u8 = 0;
pub const OTG_DIEPCTL_MPSIZ_MASK: u16 = 2047;
pub const OTG_DIEPCTL_USBAEP: u16 = 32768;
pub const OTG_DIEPCTL_EONUM: u32 = 65536;
pub const OTG_DIEPCTL_EVEN: u8 = 0;
pub const OTG_DIEPCTL_ODD: u32 = 65536;
pub const OTG_DIEPCTL_DATA0: u8 = 0;
pub const OTG_DIEPCTL_DATA1: u32 = 65536;
pub const OTG_DIEPCTL_NAKSTS: u32 = 131072;
pub const OTG_DIEPCTL_EPTYP_SHIFT: u8 = 18;
pub const OTG_DIEPCTL_EPTYP_MASK: u32 = 786432;
pub const OTG_DIEPCTL_EPTYP_CTRL: u8 = 0;
pub const OTG_DIEPCTL_EPTYP_ISOC: u32 = 262144;
pub const OTG_DIEPCTL_EPTYP_BULK: u32 = 524288;
pub const OTG_DIEPCTL_EPTYP_INTR: u32 = 786432;
pub const OTG_DIEPCTL_STALL: u32 = 2097152;
pub const OTG_DIEPCTL_TXFNUM_SHIFT: u8 = 22;
pub const OTG_DIEPCTL_TXFNUM_MASK: u32 = 62914560;
pub const OTG_DIEPCTL_CNAK: u32 = 67108864;
pub const OTG_DIEPCTL_SNAK: u32 = 134217728;
pub const OTG_DIEPCTL_SD0PID: u32 = 268435456;
pub const OTG_DIEPCTL_SEVNFRM: u32 = 268435456;
pub const OTG_DIEPCTL_SODDFRM: u32 = 536870912;
pub const OTG_DIEPCTL_EPDIS: u32 = 1073741824;
pub const OTG_DIEPCTL_EPENA: u32 = 2147483648;
pub const OTG_DIEPINT_XFRC: u8 = 1;
pub const OTG_DIEPINT_EPDISD: u8 = 2;
pub const OTG_DIEPINT_TOC: u8 = 8;
pub const OTG_DIEPINT_ITTXFE: u8 = 16;
pub const OTG_DIEPINT_INEPNE: u8 = 64;
pub const OTG_DIEPINT_TXFE: u8 = 128;
pub const OTG_DIEPTSIZ0_XFRSIZ_SHIFT: u8 = 0;
pub const OTG_DIEPTSIZ0_XFRSIZ_MASK: u8 = 127;
pub const OTG_DIEPTSIZ0_PKTCNT_SHIFT: u8 = 19;
pub const OTG_DIEPTSIZ0_PKTCNT_MASK: u32 = 1572864;
pub const OTG_DIEPTSIZ_XFRSIZ_SHIFT: u8 = 0;
pub const OTG_DIEPTSIZ_XFRSIZ_MASK: u32 = 524287;
pub const OTG_DIEPTSIZ_PKTCNT_SHIFT: u8 = 19;
pub const OTG_DIEPTSIZ_PKTCNT_MASK: u32 = 536346624;
pub const OTG_DIEPTSIZ_MCNT_SHIFT: u8 = 29;
pub const OTG_DIEPTSIZ_MCNT_MASK: u32 = 1610612736;
pub const OTG_DTXFSTS_MASK: u16 = 65535;
pub const OTG_DOEPCTL0_MPSIZ_SHIFT: u8 = 0;
pub const OTG_DOEPCTL0_MPSIZ_MASK: u8 = 3;
pub const OTG_DOEPCTL0_MPSIZ_64: u8 = 0;
pub const OTG_DOEPCTL0_MPSIZ_32: u8 = 1;
pub const OTG_DOEPCTL0_MPSIZ_16: u8 = 2;
pub const OTG_DOEPCTL0_MPSIZ_8: u8 = 3;
pub const OTG_DOEPCTL0_USBAEP: u16 = 32768;
pub const OTG_DOEPCTL0_NAKSTS: u32 = 131072;
pub const OTG_DOEPCTL0_EPTYP_SHIFT: u8 = 18;
pub const OTG_DOEPCTL0_EPTYP_MASK: u32 = 786432;
pub const OTG_DOEPCTL0_EPTYP_CTRL: u8 = 0;
pub const OTG_DOEPCTL0_SNPM: u32 = 1048576;
pub const OTG_DOEPCTL0_STALL: u32 = 2097152;
pub const OTG_DOEPCTL0_CNAK: u32 = 67108864;
pub const OTG_DOEPCTL0_SNAK: u32 = 134217728;
pub const OTG_DOEPCTL0_EPDIS: u32 = 1073741824;
pub const OTG_DOEPCTL0_EPENA: u32 = 2147483648;
pub const OTG_DOEPCTL_MPSIZ_SHIFT: u8 = 0;
pub const OTG_DOEPCTL_MPSIZ_MASK: u16 = 2047;
pub const OTG_DOEPCTL_USBAEP: u16 = 32768;
pub const OTG_DOEPCTL_DPID: u32 = 65536;
pub const OTG_DOEPCTL_DATA0: u8 = 0;
pub const OTG_DOEPCTL_DATA1: u32 = 65536;
pub const OTG_DOEPCTL_EONUM: u32 = 65536;
pub const OTG_DOEPCTL_EVEN: u8 = 0;
pub const OTG_DOEPCTL_ODD: u32 = 65536;
pub const OTG_DOEPCTL_NAKSTS: u32 = 131072;
pub const OTG_DOEPCTL_EPTYP_SHIFT: u8 = 18;
pub const OTG_DOEPCTL_EPTYP_MASK: u32 = 786432;
pub const OTG_DOEPCTL_EPTYP_CTRL: u8 = 0;
pub const OTG_DOEPCTL_EPTYP_ISOC: u32 = 262144;
pub const OTG_DOEPCTL_EPTYP_BULK: u32 = 524288;
pub const OTG_DOEPCTL_EPTYP_INTR: u32 = 786432;
pub const OTG_DOEPCTL_SNPM: u32 = 1048576;
pub const OTG_DOEPCTL_STALL: u32 = 2097152;
pub const OTG_DOEPCTL_CNAK: u32 = 67108864;
pub const OTG_DOEPCTL_SNAK: u32 = 134217728;
pub const OTG_DOEPCTL_SD0PID: u32 = 268435456;
pub const OTG_DOEPCTL_SEVNFRM: u32 = 268435456;
pub const OTG_DOEPCTL_SD1PID: u32 = 536870912;
pub const OTG_DOEPCTL_SODDFRM: u32 = 536870912;
pub const OTG_DOEPCTL_EPDIS: u32 = 1073741824;
pub const OTG_DOEPCTL_EPENA: u32 = 2147483648;
pub const OTG_DOEPINT_XFRC: u8 = 1;
pub const OTG_DOEPINT_EPDISD: u8 = 2;
pub const OTG_DOEPINT_SETUP: u8 = 8;
pub const OTG_DOEPINT_OTEPDIS: u8 = 16;
pub const OTG_DOEPINT_B2BSTUP: u8 = 64;
pub const OTG_DOEPTSIZ0_XFRSIZ_SHIFT: u8 = 0;
pub const OTG_DOEPTSIZ0_XFRSIZ_MASK: u8 = 127;
pub const OTG_DOEPTSIZ0_PKTCNT: u32 = 524288;
pub const OTG_DOEPTSIZ0_STUPCNT_SHIFT: u8 = 29;
pub const OTG_DOEPTSIZ0_STUPCNT_MASK: u32 = 1610612736;
pub const OTG_DOEPTSIZ_XFRSIZ_SHIFT: u8 = 0;
pub const OTG_DOEPTSIZ_XFRSIZ_MASK: u32 = 524287;
pub const OTG_DOEPTSIZ_PKTCNT_SHIFT: u8 = 19;
pub const OTG_DOEPTSIZ_PKTCNT_MASK: u32 = 536346624;
pub const OTG_DOEPTSIZ_STUPCNT_SHIFT: u8 = 29;
pub const OTG_DOEPTSIZ_STUPCNT_MASK: u32 = 1610612736;
pub const OTG_DOEPTSIZ_RXDPID_SHIFT: u8 = 29;
pub const OTG_DOEPTSIZ_RXDPID_MASK: u32 = 1610612736;
pub const OTG_DOEPTSIZ_RXDPID_DATA0: u8 = 0;
pub const OTG_DOEPTSIZ_RXDPID_DATA2: u32 = 536870912;
pub const OTG_DOEPTSIZ_RXDPID_DATA1: u32 = 1073741824;
pub const OTG_DOEPTSIZ_RXDPID_MDATA: u32 = 1610612736;
pub const OTG_PCGCCTL_STPPCLK: u8 = 1;
pub const OTG_PCGCCTL_GATEHCLK: u8 = 2;
pub const OTG_PCGCCTL_PHYSUSP: u8 = 16;
pub const USBPHYC_PLL1_EN: u8 = 1;
pub const USBPHYC_PLL1_SEL_SHIFT: u8 = 1;
pub const USBPHYC_PLL1_SEL_12MHz: u8 = 0;
pub const USBPHYC_PLL1_SEL_12_5MHz: u8 = 2;
pub const USBPHYC_PLL1_SEL_12_5bMHz: u8 = 4;
pub const USBPHYC_PLL1_SEL_16MHz: u8 = 6;
pub const USBPHYC_PLL1_SEL_24MHz: u8 = 8;
pub const USBPHYC_PLL1_SEL_25MHz: u8 = 10;
pub const USBPHYC_PLL1_SEL_25bMHz: u8 = 12;
pub const USBPHYC_TUNE_INCURREN: u8 = 1;
pub const USBPHYC_TUNE_INCURRINT: u8 = 2;
pub const USBPHYC_TUNE_LFSCAPEN: u8 = 4;
pub const USBPHYC_TUNE_HSDRVSLEW: u8 = 8;
pub const USBPHYC_TUNE_HSDRVDCLEV: u8 = 16;
pub const USBPHYC_TUNE_HSDRVDCCUR: u8 = 32;
pub const USBPHYC_TUNE_HSDRVCURINCR: u8 = 64;
pub const USBPHYC_TUNE_FSDRVRFADJ: u8 = 128;
pub const USBPHYC_TUNE_HSDRVRFRED: u16 = 256;
pub const USBPHYC_TUNE_HSDRVCHKITRM_SHIFT: u8 = 9;
pub const USBPHYC_TUNE_HSDRVCHKITRM_MASK: u16 = 7680;
pub const USBPHYC_TUNE_HSDRVCHKZTRM_SHIFT: u8 = 13;
pub const USBPHYC_TUNE_HSDRVCHKZTRM_MASK: u16 = 24576;
pub const USBPHYC_TUNE_SQLCHCTL_SHIFT: u8 = 15;
pub const USBPHYC_TUNE_SQLCHCTL_MASK: u32 = 98304;
pub const USBPHYC_TUNE_HDRXGNEQEN: u32 = 131072;
pub const USBPHYC_TUNE_STAGSEL: u32 = 262144;
pub const USBPHYC_TUNE_HSFALLPREEM: u32 = 524288;
pub const USBPHYC_TUNE_HSRXOFF_SHIFT: u8 = 20;
pub const USBPHYC_TUNE_HSRXOFF_MASK: u32 = 3145728;
pub const USBPHYC_TUNE_SHTCCTCTLPROT: u32 = 4194304;
pub const USBPHYC_TUNE_SQLBYP: u32 = 8388608;
pub const USBPHYC_LDO_USED: u8 = 1;
pub const USBPHYC_LDO_STATUS: u8 = 2;
pub const USBPHYC_LDO_ENABLE: u8 = 4;
pub const __DEBUG_ASSERT_FILE__: u8 = 0;
pub const __DEBUG_ASSERT_LINE__: u8 = 0;
pub const __ASSERT_FILE__: u8 = 0;
pub const __ASSERT_LINE__: u8 = 0;
pub const EPERM: u8 = 1;
pub const EPERM_STR: &[u8; 24] = b"Operation not permitted\0";
pub const ENOENT: u8 = 2;
pub const ENOENT_STR: &[u8; 26] = b"No such file or directory\0";
pub const ESRCH: u8 = 3;
pub const ESRCH_STR: &[u8; 16] = b"No such process\0";
pub const EINTR: u8 = 4;
pub const EINTR_STR: &[u8; 24] = b"Interrupted system call\0";
pub const EIO: u8 = 5;
pub const EIO_STR: &[u8; 10] = b"I/O error\0";
pub const ENXIO: u8 = 6;
pub const ENXIO_STR: &[u8; 26] = b"No such device or address\0";
pub const E2BIG: u8 = 7;
pub const E2BIG_STR: &[u8; 18] = b"Arg list too long\0";
pub const ENOEXEC: u8 = 8;
pub const ENOEXEC_STR: &[u8; 18] = b"Exec format error\0";
pub const EBADF: u8 = 9;
pub const EBADF_STR: &[u8; 16] = b"Bad file number\0";
pub const ECHILD: u8 = 10;
pub const ECHILD_STR: &[u8; 19] = b"No child processes\0";
pub const EAGAIN: u8 = 11;
pub const EAGAIN_STR: &[u8; 10] = b"Try again\0";
pub const ENOMEM: u8 = 12;
pub const ENOMEM_STR: &[u8; 14] = b"Out of memory\0";
pub const EACCES: u8 = 13;
pub const EACCES_STR: &[u8; 18] = b"Permission denied\0";
pub const EFAULT: u8 = 14;
pub const EFAULT_STR: &[u8; 12] = b"Bad address\0";
pub const ENOTBLK: u8 = 15;
pub const ENOTBLK_STR: &[u8; 22] = b"Block device required\0";
pub const EBUSY: u8 = 16;
pub const EBUSY_STR: &[u8; 24] = b"Device or resource busy\0";
pub const EEXIST: u8 = 17;
pub const EEXIST_STR: &[u8; 12] = b"File exists\0";
pub const EXDEV: u8 = 18;
pub const EXDEV_STR: &[u8; 18] = b"Cross-device link\0";
pub const ENODEV: u8 = 19;
pub const ENODEV_STR: &[u8; 15] = b"No such device\0";
pub const ENOTDIR: u8 = 20;
pub const ENOTDIR_STR: &[u8; 16] = b"Not a directory\0";
pub const EISDIR: u8 = 21;
pub const EISDIR_STR: &[u8; 15] = b"Is a directory\0";
pub const EINVAL: u8 = 22;
pub const EINVAL_STR: &[u8; 17] = b"Invalid argument\0";
pub const ENFILE: u8 = 23;
pub const ENFILE_STR: &[u8; 20] = b"File table overflow\0";
pub const EMFILE: u8 = 24;
pub const EMFILE_STR: &[u8; 20] = b"Too many open files\0";
pub const ENOTTY: u8 = 25;
pub const ENOTTY_STR: &[u8; 17] = b"Not a typewriter\0";
pub const ETXTBSY: u8 = 26;
pub const ETXTBSY_STR: &[u8; 15] = b"Text file busy\0";
pub const EFBIG: u8 = 27;
pub const EFBIG_STR: &[u8; 15] = b"File too large\0";
pub const ENOSPC: u8 = 28;
pub const ENOSPC_STR: &[u8; 24] = b"No space left on device\0";
pub const ESPIPE: u8 = 29;
pub const ESPIPE_STR: &[u8; 13] = b"Illegal seek\0";
pub const EROFS: u8 = 30;
pub const EROFS_STR: &[u8; 22] = b"Read-only file system\0";
pub const EMLINK: u8 = 31;
pub const EMLINK_STR: &[u8; 15] = b"Too many links\0";
pub const EPIPE: u8 = 32;
pub const EPIPE_STR: &[u8; 12] = b"Broken pipe\0";
pub const EDOM: u8 = 33;
pub const EDOM_STR: &[u8; 36] = b"Math argument out of domain of func\0";
pub const ERANGE: u8 = 34;
pub const ERANGE_STR: &[u8; 30] = b"Math result not representable\0";
pub const EDEADLK: u8 = 35;
pub const EDEADLK_STR: &[u8; 30] = b"Resource deadlock would occur\0";
pub const ENAMETOOLONG: u8 = 36;
pub const ENAMETOOLONG_STR: &[u8; 19] = b"File name too long\0";
pub const ENOLCK: u8 = 37;
pub const ENOLCK_STR: &[u8; 26] = b"No record locks available\0";
pub const ENOSYS: u8 = 38;
pub const ENOSYS_STR: &[u8; 27] = b"Invalid system call number\0";
pub const ENOTEMPTY: u8 = 39;
pub const ENOTEMPTY_STR: &[u8; 20] = b"Directory not empty\0";
pub const ELOOP: u8 = 40;
pub const ELOOP_STR: &[u8; 36] = b"Too many symbolic links encountered\0";
pub const EWOULDBLOCK: u8 = 11;
pub const EWOULDBLOCK_STR: &[u8; 22] = b"Operation would block\0";
pub const ENOMSG: u8 = 42;
pub const ENOMSG_STR: &[u8; 27] = b"No message of desired type\0";
pub const EIDRM: u8 = 43;
pub const EIDRM_STR: &[u8; 19] = b"Identifier removed\0";
pub const ECHRNG: u8 = 44;
pub const ECHRNG_STR: &[u8; 28] = b"Channel number out of range\0";
pub const EL2NSYNC: u8 = 45;
pub const EL2NSYNC_STR: &[u8; 25] = b"Level 2 not synchronized\0";
pub const EL3HLT: u8 = 46;
pub const EL3HLT_STR: &[u8; 15] = b"Level 3 halted\0";
pub const EL3RST: u8 = 47;
pub const EL3RST_STR: &[u8; 14] = b"Level 3 reset\0";
pub const ELNRNG: u8 = 48;
pub const ELNRNG_STR: &[u8; 25] = b"Link number out of range\0";
pub const EUNATCH: u8 = 49;
pub const EUNATCH_STR: &[u8; 29] = b"Protocol driver not attached\0";
pub const ENOCSI: u8 = 50;
pub const ENOCSI_STR: &[u8; 27] = b"No CSI structure available\0";
pub const EL2HLT: u8 = 51;
pub const EL2HLT_STR: &[u8; 15] = b"Level 2 halted\0";
pub const EBADE: u8 = 52;
pub const EBADE_STR: &[u8; 17] = b"Invalid exchange\0";
pub const EBADR: u8 = 53;
pub const EBADR_STR: &[u8; 27] = b"Invalid request descriptor\0";
pub const EXFULL: u8 = 54;
pub const EXFULL_STR: &[u8; 14] = b"Exchange full\0";
pub const ENOANO: u8 = 55;
pub const ENOANO_STR: &[u8; 9] = b"No anode\0";
pub const EBADRQC: u8 = 56;
pub const EBADRQC_STR: &[u8; 21] = b"Invalid request code\0";
pub const EBADSLT: u8 = 57;
pub const EBADSLT_STR: &[u8; 13] = b"Invalid slot\0";
pub const EDEADLOCK: u8 = 35;
pub const EDEADLOCK_STR: &[u8; 28] = b"File locking deadlock error\0";
pub const EBFONT: u8 = 59;
pub const EBFONT_STR: &[u8; 21] = b"Bad font file format\0";
pub const ENOSTR: u8 = 60;
pub const ENOSTR_STR: &[u8; 20] = b"Device not a stream\0";
pub const ENODATA: u8 = 61;
pub const ENODATA_STR: &[u8; 18] = b"No data available\0";
pub const ETIME: u8 = 62;
pub const ETIME_STR: &[u8; 14] = b"Timer expired\0";
pub const ENOSR: u8 = 63;
pub const ENOSR_STR: &[u8; 25] = b"Out of streams resources\0";
pub const ENONET: u8 = 64;
pub const ENONET_STR: &[u8; 30] = b"Machine is not on the network\0";
pub const ENOPKG: u8 = 65;
pub const ENOPKG_STR: &[u8; 22] = b"Package not installed\0";
pub const EREMOTE: u8 = 66;
pub const EREMOTE_STR: &[u8; 17] = b"Object is remote\0";
pub const ENOLINK: u8 = 67;
pub const ENOLINK_STR: &[u8; 22] = b"Link has been severed\0";
pub const EADV: u8 = 68;
pub const EADV_STR: &[u8; 16] = b"Advertise error\0";
pub const ESRMNT: u8 = 69;
pub const ESRMNT_STR: &[u8; 14] = b"Srmount error\0";
pub const ECOMM: u8 = 70;
pub const ECOMM_STR: &[u8; 28] = b"Communication error on send\0";
pub const EPROTO: u8 = 71;
pub const EPROTO_STR: &[u8; 15] = b"Protocol error\0";
pub const EMULTIHOP: u8 = 72;
pub const EMULTIHOP_STR: &[u8; 19] = b"Multihop attempted\0";
pub const EDOTDOT: u8 = 73;
pub const EDOTDOT_STR: &[u8; 19] = b"RFS specific error\0";
pub const EBADMSG: u8 = 74;
pub const EBADMSG_STR: &[u8; 19] = b"Not a data message\0";
pub const EOVERFLOW: u8 = 75;
pub const EOVERFLOW_STR: &[u8; 38] = b"Value too large for defined data type\0";
pub const ENOTUNIQ: u8 = 76;
pub const ENOTUNIQ_STR: &[u8; 27] = b"Name not unique on network\0";
pub const EBADFD: u8 = 77;
pub const EBADFD_STR: &[u8; 29] = b"File descriptor in bad state\0";
pub const EREMCHG: u8 = 78;
pub const EREMCHG_STR: &[u8; 23] = b"Remote address changed\0";
pub const ELIBACC: u8 = 79;
pub const ELIBACC_STR: &[u8; 39] = b"Can not access a needed shared library\0";
pub const ELIBBAD: u8 = 80;
pub const ELIBBAD_STR: &[u8; 37] = b"Accessing a corrupted shared library\0";
pub const ELIBSCN: u8 = 81;
pub const ELIBSCN_STR: &[u8; 32] = b".lib section in a.out corrupted\0";
pub const ELIBMAX: u8 = 82;
pub const ELIBMAX_STR: &[u8; 48] = b"Attempting to link in too many shared libraries\0";
pub const ELIBEXEC: u8 = 83;
pub const ELIBEXEC_STR: &[u8; 38] = b"Cannot exec a shared library directly\0";
pub const EILSEQ: u8 = 84;
pub const EILSEQ_STR: &[u8; 22] = b"Illegal byte sequence\0";
pub const ERESTART: u8 = 85;
pub const ERESTART_STR: &[u8; 44] = b"Interrupted system call should be restarted\0";
pub const ESTRPIPE: u8 = 86;
pub const ESTRPIPE_STR: &[u8; 19] = b"Streams pipe error\0";
pub const EUSERS: u8 = 87;
pub const EUSERS_STR: &[u8; 15] = b"Too many users\0";
pub const ENOTSOCK: u8 = 88;
pub const ENOTSOCK_STR: &[u8; 31] = b"Socket operation on non-socket\0";
pub const EDESTADDRREQ: u8 = 89;
pub const EDESTADDRREQ_STR: &[u8; 29] = b"Destination address required\0";
pub const EMSGSIZE: u8 = 90;
pub const EMSGSIZE_STR: &[u8; 17] = b"Message too long\0";
pub const EPROTOTYPE: u8 = 91;
pub const EPROTOTYPE_STR: &[u8; 31] = b"Protocol wrong type for socket\0";
pub const ENOPROTOOPT: u8 = 92;
pub const ENOPROTOOPT_STR: &[u8; 23] = b"Protocol not available\0";
pub const EPROTONOSUPPORT: u8 = 93;
pub const EPROTONOSUPPORT_STR: &[u8; 23] = b"Protocol not supported\0";
pub const ESOCKTNOSUPPORT: u8 = 94;
pub const ESOCKTNOSUPPORT_STR: &[u8; 26] = b"Socket type not supported\0";
pub const EOPNOTSUPP: u8 = 95;
pub const EOPNOTSUPP_STR: &[u8; 46] = b"Operation not supported on transport endpoint\0";
pub const EPFNOSUPPORT: u8 = 96;
pub const EPFNOSUPPORT_STR: &[u8; 30] = b"Protocol family not supported\0";
pub const EAFNOSUPPORT: u8 = 97;
pub const EAFNOSUPPORT_STR: &[u8; 41] = b"Address family not supported by protocol\0";
pub const EADDRINUSE: u8 = 98;
pub const EADDRINUSE_STR: &[u8; 23] = b"Address already in use\0";
pub const EADDRNOTAVAIL: u8 = 99;
pub const EADDRNOTAVAIL_STR: &[u8; 32] = b"Cannot assign requested address\0";
pub const ENETDOWN: u8 = 100;
pub const ENETDOWN_STR: &[u8; 16] = b"Network is down\0";
pub const ENETUNREACH: u8 = 101;
pub const ENETUNREACH_STR: &[u8; 23] = b"Network is unreachable\0";
pub const ENETRESET: u8 = 102;
pub const ENETRESET_STR: &[u8; 44] = b"Network dropped connection because of reset\0";
pub const ECONNABORTED: u8 = 103;
pub const ECONNABORTED_STR: &[u8; 33] = b"Software caused connection abort\0";
pub const ECONNRESET: u8 = 104;
pub const ECONNRESET_STR: &[u8; 25] = b"Connection reset by peer\0";
pub const ENOBUFS: u8 = 105;
pub const ENOBUFS_STR: &[u8; 26] = b"No buffer space available\0";
pub const EISCONN: u8 = 106;
pub const EISCONN_STR: &[u8; 40] = b"Transport endpoint is already connected\0";
pub const ENOTCONN: u8 = 107;
pub const ENOTCONN_STR: &[u8; 36] = b"Transport endpoint is not connected\0";
pub const ESHUTDOWN: u8 = 108;
pub const ESHUTDOWN_STR: &[u8; 46] = b"Cannot send after transport endpoint shutdown\0";
pub const ETOOMANYREFS: u8 = 109;
pub const ETOOMANYREFS_STR: &[u8; 35] = b"Too many references: cannot splice\0";
pub const ETIMEDOUT: u8 = 110;
pub const ETIMEDOUT_STR: &[u8; 21] = b"Connection timed out\0";
pub const ECONNREFUSED: u8 = 111;
pub const ECONNREFUSED_STR: &[u8; 19] = b"Connection refused\0";
pub const EHOSTDOWN: u8 = 112;
pub const EHOSTDOWN_STR: &[u8; 13] = b"Host is down\0";
pub const EHOSTUNREACH: u8 = 113;
pub const EHOSTUNREACH_STR: &[u8; 17] = b"No route to host\0";
pub const EALREADY: u8 = 114;
pub const EALREADY_STR: &[u8; 30] = b"Operation already in progress\0";
pub const EINPROGRESS: u8 = 115;
pub const EINPROGRESS_STR: &[u8; 26] = b"Operation now in progress\0";
pub const ESTALE: u8 = 116;
pub const ESTALE_STR: &[u8; 18] = b"Stale file handle\0";
pub const EUCLEAN: u8 = 117;
pub const EUCLEAN_STR: &[u8; 25] = b"Structure needs cleaning\0";
pub const ENOTNAM: u8 = 118;
pub const ENOTNAM_STR: &[u8; 28] = b"Not a XENIX named type file\0";
pub const ENAVAIL: u8 = 119;
pub const ENAVAIL_STR: &[u8; 30] = b"No XENIX semaphores available\0";
pub const EISNAM: u8 = 120;
pub const EISNAM_STR: &[u8; 21] = b"Is a named type file\0";
pub const EREMOTEIO: u8 = 121;
pub const EREMOTEIO_STR: &[u8; 17] = b"Remote I/O error\0";
pub const EDQUOT: u8 = 122;
pub const EDQUOT_STR: &[u8; 15] = b"Quota exceeded\0";
pub const ENOMEDIUM: u8 = 123;
pub const ENOMEDIUM_STR: &[u8; 16] = b"No medium found\0";
pub const EMEDIUMTYPE: u8 = 124;
pub const EMEDIUMTYPE_STR: &[u8; 18] = b"Wrong medium type\0";
pub const ECANCELED: u8 = 125;
pub const ECANCELED_STR: &[u8; 20] = b"Operation cancelled\0";
pub const ENOKEY: u8 = 126;
pub const ENOKEY_STR: &[u8; 27] = b"Required key not available\0";
pub const EKEYEXPIRED: u8 = 127;
pub const EKEYEXPIRED_STR: &[u8; 16] = b"Key has expired\0";
pub const EKEYREVOKED: u8 = 128;
pub const EKEYREVOKED_STR: &[u8; 21] = b"Key has been revoked\0";
pub const EKEYREJECTED: u8 = 129;
pub const EKEYREJECTED_STR: &[u8; 28] = b"Key was rejected by service\0";
pub const EOWNERDEAD: u8 = 130;
pub const EOWNERDEAD_STR: &[u8; 20] = b"Previous owner died\0";
pub const ENOTRECOVERABLE: u8 = 131;
pub const ENOTRECOVERABLE_STR: &[u8; 22] = b"State not recoverable\0";
pub const ERFKILL: u8 = 132;
pub const ERFKILL_STR: &[u8; 38] = b"Operation not possible due to RF-kill\0";
pub const EHWPOISON: u8 = 133;
pub const EHWPOISON_STR: &[u8; 31] = b"Memory page has hardware error\0";
pub const ELBIN: u8 = 134;
pub const ELBIN_STR: &[u8; 16] = b"Inode is remote\0";
pub const EFTYPE: u8 = 135;
pub const EFTYPE_STR: &[u8; 34] = b"Inappropriate file type or format\0";
pub const ENMFILE: u8 = 136;
pub const ENMFILE_STR: &[u8; 14] = b"No more files\0";
pub const EPROCLIM: u8 = 137;
pub const EPROCLIM_STR: &[u8; 42] = b"Limit would be exceeded by attempted fork\0";
pub const ENOTSUP: u8 = 138;
pub const ENOTSUP_STR: &[u8; 14] = b"Not supported\0";
pub const ENOSHARE: u8 = 139;
pub const ENOSHARE_STR: &[u8; 29] = b"No such host or network path\0";
pub const ECASECLASH: u8 = 140;
pub const ECASECLASH_STR: &[u8; 36] = b"Filename exists with different case\0";
pub const __ELASTERROR: u16 = 2000;
pub const CLK_TCK: u8 = 100;
pub const CLOCKS_PER_SEC: u8 = 100;
pub const CLOCK_REALTIME: u8 = 0;
pub const CLOCK_MONOTONIC: u8 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u8 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u8 = 3;
pub const CLOCK_BOOTTIME: u8 = 4;
pub const TIMER_ABSTIME: u8 = 1;
pub const TIME_UTC: u8 = 1;
pub const SEM_PRIO_NONE: u8 = 0;
pub const SEM_PRIO_INHERIT: u8 = 1;
pub const SEM_PRIO_PROTECT: u8 = 2;
pub const SEM_PRIO_MASK: u8 = 3;
pub const SEM_TYPE_MUTEX: u8 = 4;
pub const __HAVE_KERNEL_GLOBALS: u8 = 1;
pub const CLOCK_MASK: u8 = 7;
pub const CLOCK_SHIFT: u8 = 3;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const MSEC_PER_SEC: u16 = 1000;
pub const DSEC_PER_SEC: u8 = 10;
pub const HSEC_PER_SEC: u8 = 2;
pub const NSEC_PER_HSEC: u32 = 500000000;
pub const USEC_PER_HSEC: u32 = 500000;
pub const MSEC_PER_HSEC: u16 = 500;
pub const DSEC_PER_HSEC: u8 = 5;
pub const NSEC_PER_DSEC: u32 = 100000000;
pub const USEC_PER_DSEC: u32 = 100000;
pub const MSEC_PER_DSEC: u8 = 100;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_MSEC: u16 = 1000;
pub const NSEC_PER_USEC: u16 = 1000;
pub const SEC_PER_MIN: u8 = 60;
pub const NSEC_PER_MIN: u64 = 60000000000;
pub const USEC_PER_MIN: u32 = 60000000;
pub const MSEC_PER_MIN: u16 = 60000;
pub const DSEC_PER_MIN: u16 = 600;
pub const HSEC_PER_MIN: u8 = 120;
pub const MIN_PER_HOUR: u8 = 60;
pub const NSEC_PER_HOUR: u64 = 3600000000000;
pub const USEC_PER_HOUR: u32 = 3600000000;
pub const MSEC_PER_HOUR: u32 = 3600000;
pub const DSEC_PER_HOUR: u16 = 36000;
pub const HSEC_PER_HOUR: u16 = 7200;
pub const SEC_PER_HOUR: u16 = 3600;
pub const HOURS_PER_DAY: u8 = 24;
pub const SEC_PER_DAY: u32 = 86400;
pub const USEC_PER_TICK: u16 = 10000;
pub const TICK_PER_HOUR: u32 = 360000;
pub const TICK_PER_MIN: u16 = 6000;
pub const TICK_PER_SEC: u8 = 100;
pub const TICK_PER_MSEC: u8 = 0;
pub const TICK_PER_DSEC: u8 = 10;
pub const TICK_PER_HSEC: u8 = 50;
pub const MSEC_PER_TICK: u8 = 10;
pub const NSEC_PER_TICK: u32 = 10000000;
pub const INITIAL_SYSTEM_TIMER_TICKS: u8 = 0;
pub const SECSPERMIN: u8 = 60;
pub const MINSPERHOUR: u8 = 60;
pub const HOURSPERDAY: u8 = 24;
pub const DAYSPERWEEK: u8 = 7;
pub const DAYSPERNYEAR: u16 = 365;
pub const DAYSPERLYEAR: u16 = 366;
pub const MONSPERYEAR: u8 = 12;
pub const TM_SUNDAY: u8 = 0;
pub const TM_MONDAY: u8 = 1;
pub const TM_TUESDAY: u8 = 2;
pub const TM_WEDNESDAY: u8 = 3;
pub const TM_THURSDAY: u8 = 4;
pub const TM_FRIDAY: u8 = 5;
pub const TM_SATURDAY: u8 = 6;
pub const TM_JANUARY: u8 = 0;
pub const TM_FEBRUARY: u8 = 1;
pub const TM_MARCH: u8 = 2;
pub const TM_APRIL: u8 = 3;
pub const TM_MAY: u8 = 4;
pub const TM_JUNE: u8 = 5;
pub const TM_JULY: u8 = 6;
pub const TM_AUGUST: u8 = 7;
pub const TM_SEPTEMBER: u8 = 8;
pub const TM_OCTOBER: u8 = 9;
pub const TM_NOVEMBER: u8 = 10;
pub const TM_DECEMBER: u8 = 11;
pub const TM_YEAR_BASE: u16 = 1900;
pub const TM_WDAY_BASE: u8 = 1;
pub const EPOCH_YEAR: u16 = 1970;
pub const EPOCH_WDAY: u8 = 4;
pub const USBHOST_DEVADDR_HASHSIZE: u8 = 8;
pub const USBHOST_DEVADDR_HASHMASK: u8 = 7;
pub const MIN_SIGNO: u8 = 1;
pub const MAX_SIGNO: u8 = 63;
pub const SIGSTDMIN: u8 = 1;
pub const SIGSTDMAX: u8 = 31;
pub const SIGRTMIN: u8 = 32;
pub const SIGRTMAX: u8 = 63;
pub const _NSIG: u8 = 64;
pub const NSIG: u8 = 64;
pub const _SIGSET_NELEM: u8 = 2;
pub const SIGHUP: u8 = 1;
pub const SIGINT: u8 = 2;
pub const SIGQUIT: u8 = 3;
pub const SIGILL: u8 = 4;
pub const SIGTRAP: u8 = 5;
pub const SIGABRT: u8 = 6;
pub const SIGBUS: u8 = 7;
pub const SIGFPE: u8 = 8;
pub const SIGKILL: u8 = 9;
pub const SIGUSR1: u8 = 10;
pub const SIGSEGV: u8 = 11;
pub const SIGUSR2: u8 = 12;
pub const SIGPIPE: u8 = 13;
pub const SIGALRM: u8 = 14;
pub const SIGTERM: u8 = 15;
pub const SIGCHLD: u8 = 17;
pub const SIGCONT: u8 = 18;
pub const SIGSTOP: u8 = 19;
pub const SIGTSTP: u8 = 20;
pub const SIGTTIN: u8 = 21;
pub const SIGTTOU: u8 = 22;
pub const SIGURG: u8 = 23;
pub const SIGXCPU: u8 = 24;
pub const SIGXFSZ: u8 = 25;
pub const SIGVTALRM: u8 = 26;
pub const SIGPROF: u8 = 27;
pub const SIGWINCH: u8 = 28;
pub const SIGPOLL: u8 = 29;
pub const SIGIO: u8 = 29;
pub const SIGSYS: u8 = 31;
pub const SIG_BLOCK: u8 = 1;
pub const SIG_UNBLOCK: u8 = 2;
pub const SIG_SETMASK: u8 = 3;
pub const SA_NOCLDSTOP: u8 = 1;
pub const SA_SIGINFO: u8 = 2;
pub const SA_NOCLDWAIT: u8 = 4;
pub const SA_ONSTACK: u8 = 8;
pub const SA_RESTART: u8 = 16;
pub const SA_NODEFER: u8 = 32;
pub const SA_RESETHAND: u8 = 64;
pub const SA_KERNELHAND: u8 = 128;
pub const SI_USER: u8 = 0;
pub const SI_QUEUE: u8 = 1;
pub const SI_TIMER: u8 = 2;
pub const SI_ASYNCIO: u8 = 3;
pub const SI_MESGQ: u8 = 4;
pub const CLD_EXITED: u8 = 5;
pub const CLD_KILLED: u8 = 6;
pub const CLD_DUMPED: u8 = 7;
pub const CLD_TRAPPED: u8 = 8;
pub const CLD_STOPPED: u8 = 9;
pub const CLD_CONTINUED: u8 = 10;
pub const ILL_ILLOPC: u8 = 1;
pub const ILL_ILLOPN: u8 = 2;
pub const ILL_ILLADR: u8 = 3;
pub const ILL_ILLTRP: u8 = 4;
pub const ILL_PRVOPC: u8 = 5;
pub const ILL_PRVREG: u8 = 6;
pub const ILL_COPROC: u8 = 7;
pub const ILL_BADSTK: u8 = 8;
pub const FPE_INTDIV: u8 = 1;
pub const FPE_INTOVF: u8 = 2;
pub const FPE_FLTDIV: u8 = 3;
pub const FPE_FLTOVF: u8 = 4;
pub const FPE_FLTUND: u8 = 5;
pub const FPE_FLTRES: u8 = 6;
pub const FPE_FLTINV: u8 = 7;
pub const FPE_FLTSUB: u8 = 8;
pub const SEGV_MAPERR: u8 = 1;
pub const SEGV_ACCERR: u8 = 2;
pub const BUS_ADRALN: u8 = 1;
pub const BUS_ADRERR: u8 = 2;
pub const BUS_OBJERR: u8 = 3;
pub const TRAP_BRKPT: u8 = 1;
pub const TRAP_TRACE: u8 = 2;
pub const POLL_IN: u8 = 1;
pub const POLL_OUT: u8 = 2;
pub const POLL_MSG: u8 = 3;
pub const POLL_ERR: u8 = 4;
pub const POLL_PRI: u8 = 5;
pub const POLL_HUP: u8 = 6;
pub const SIGEV_NONE: u8 = 0;
pub const SIGEV_SIGNAL: u8 = 1;
pub const MINSIGSTKSZ: u16 = 256;
pub const SIGSTKSZ: u16 = 2048;
pub const SS_ONSTACK: u8 = 1;
pub const SS_DISABLE: u8 = 2;
pub const POLLIN: u8 = 1;
pub const POLLRDNORM: u8 = 1;
pub const POLLRDBAND: u8 = 1;
pub const POLLPRI: u8 = 2;
pub const POLLOUT: u8 = 4;
pub const POLLWRNORM: u8 = 4;
pub const POLLWRBAND: u8 = 4;
pub const POLLERR: u8 = 8;
pub const POLLHUP: u8 = 16;
pub const POLLRDHUP: u8 = 16;
pub const POLLNVAL: u8 = 32;
pub const POLLALWAYS: u32 = 65536;
pub const __GNUC_VA_LIST: u8 = 1;
pub const DT_UNKNOWN: u8 = 0;
pub const DT_FIFO: u8 = 1;
pub const DT_CHR: u8 = 2;
pub const DT_SEM: u8 = 3;
pub const DT_DIR: u8 = 4;
pub const DT_MQ: u8 = 5;
pub const DT_BLK: u8 = 6;
pub const DT_SHM: u8 = 7;
pub const DT_REG: u8 = 8;
pub const DT_MTD: u8 = 9;
pub const DT_LNK: u8 = 10;
pub const DT_SOCK: u8 = 12;
pub const DTYPE_UNKNOWN: u8 = 0;
pub const DTYPE_FIFO: u8 = 1;
pub const DTYPE_CHR: u8 = 2;
pub const DTYPE_SEM: u8 = 3;
pub const DTYPE_DIRECTORY: u8 = 4;
pub const DTYPE_MQ: u8 = 5;
pub const DTYPE_BLK: u8 = 6;
pub const DTYPE_SHM: u8 = 7;
pub const DTYPE_FILE: u8 = 8;
pub const DTYPE_MTD: u8 = 9;
pub const DTYPE_LINK: u8 = 10;
pub const DTYPE_SOCK: u8 = 12;
pub const SP_UNLOCKED: u8 = 0;
pub const SP_LOCKED: u8 = 1;
pub const SCHED_NORMAL: u8 = 0;
pub const SCHED_OTHER: u8 = 0;
pub const SCHED_FIFO: u8 = 1;
pub const SCHED_RR: u8 = 2;
pub const SCHED_SPORADIC: u8 = 3;
pub const TASK_CANCEL_ENABLE: u8 = 0;
pub const TASK_CANCEL_DISABLE: u8 = 1;
pub const TASK_CANCEL_DEFERRED: u8 = 0;
pub const TASK_CANCEL_ASYNCHRONOUS: u8 = 1;
pub const PTHREAD_KEYS_MAX: u8 = 0;
pub const POSIX_SPAWN_RESETIDS: u8 = 1;
pub const POSIX_SPAWN_SETPGROUP: u8 = 2;
pub const POSIX_SPAWN_SETSCHEDPARAM: u8 = 4;
pub const POSIX_SPAWN_SETSCHEDULER: u8 = 8;
pub const POSIX_SPAWN_SETSIGDEF: u8 = 16;
pub const POSIX_SPAWN_SETSIGMASK: u8 = 32;
pub const POSIX_SPAWN_SETSID: u8 = 128;
pub const __FS_FLAG_EOF: u8 = 1;
pub const __FS_FLAG_ERROR: u8 = 2;
pub const __FS_FLAG_LBF: u8 = 4;
pub const __FS_FLAG_UBF: u8 = 8;
pub const FSNODEFLAG_TYPE_MASK: u8 = 15;
pub const FSNODEFLAG_TYPE_PSEUDODIR: u8 = 0;
pub const FSNODEFLAG_TYPE_DRIVER: u8 = 1;
pub const FSNODEFLAG_TYPE_BLOCK: u8 = 2;
pub const FSNODEFLAG_TYPE_MOUNTPT: u8 = 3;
pub const FSNODEFLAG_TYPE_NAMEDSEM: u8 = 4;
pub const FSNODEFLAG_TYPE_MQUEUE: u8 = 5;
pub const FSNODEFLAG_TYPE_SHM: u8 = 6;
pub const FSNODEFLAG_TYPE_MTD: u8 = 7;
pub const FSNODEFLAG_TYPE_SOFTLINK: u8 = 8;
pub const FSNODEFLAG_TYPE_SOCKET: u8 = 9;
pub const FSNODEFLAG_TYPE_PIPE: u8 = 10;
pub const FSNODEFLAG_DELETED: u8 = 16;
pub const CH_STAT_MODE: u8 = 1;
pub const CH_STAT_UID: u8 = 2;
pub const CH_STAT_GID: u8 = 4;
pub const CH_STAT_ATIME: u8 = 8;
pub const CH_STAT_MTIME: u8 = 16;
pub const SPI_STATUS_PRESENT: u8 = 1;
pub const SPI_STATUS_WRPROTECTED: u8 = 2;
pub const _TIOCBASE: u16 = 256;
pub const _WDIOCBASE: u16 = 512;
pub const _FIOCBASE: u16 = 768;
pub const _DIOCBASE: u16 = 1024;
pub const _BIOCBASE: u16 = 1280;
pub const _MTDIOCBASE: u16 = 1536;
pub const _SIOCBASE: u16 = 1792;
pub const _ARPIOCBASE: u16 = 2048;
pub const _TSIOCBASE: u16 = 2304;
pub const _SNIOCBASE: u16 = 2560;
pub const _ANIOCBASE: u16 = 2816;
pub const _PWMIOCBASE: u16 = 3072;
pub const _CAIOCBASE: u16 = 3328;
pub const _BATIOCBASE: u16 = 3584;
pub const _QEIOCBASE: u16 = 3840;
pub const _AUDIOIOCBASE: u16 = 4096;
pub const _LCDIOCBASE: u16 = 4352;
pub const _SLCDIOCBASE: u16 = 4608;
pub const _CAPIOCBASE: u16 = 4864;
pub const _WLCIOCBASE: u16 = 5120;
pub const _CFGDIOCBASE: u16 = 5376;
pub const _TCIOCBASE: u16 = 5632;
pub const _JOYBASE: u16 = 5888;
pub const _PIPEBASE: u16 = 6144;
pub const _RTCBASE: u16 = 6400;
pub const _RELAYBASE: u16 = 6656;
pub const _CANBASE: u16 = 6912;
pub const _BTNBASE: u16 = 7168;
pub const _ULEDBASE: u16 = 7424;
pub const _ZCBASE: u16 = 7680;
pub const _LOOPBASE: u16 = 7936;
pub const _MODEMBASE: u16 = 8192;
pub const _I2CBASE: u16 = 8448;
pub const _SPIBASE: u16 = 8704;
pub const _GPIOBASE: u16 = 8960;
pub const _CLIOCBASE: u16 = 9216;
pub const _USBCBASE: u16 = 9472;
pub const _MAC802154BASE: u16 = 9728;
pub const _PWRBASE: u16 = 9984;
pub const _FBIOCBASE: u16 = 10240;
pub const _NXTERMBASE: u16 = 10496;
pub const _RFIOCBASE: u16 = 10752;
pub const _RPMSGBASE: u16 = 11008;
pub const _NOTECTLBASE: u16 = 11264;
pub const _NOTERAMBASE: u16 = 11520;
pub const _RCIOCBASE: u16 = 11776;
pub const _HIMEMBASE: u16 = 12032;
pub const _EFUSEBASE: u16 = 12288;
pub const _MTRIOBASE: u16 = 12544;
pub const _MATHIOBASE: u16 = 12800;
pub const _MMCSDIOBASE: u16 = 13056;
pub const _BLUETOOTHBASE: u16 = 13312;
pub const _PKTRADIOBASE: u16 = 13568;
pub const _LTEBASE: u16 = 13824;
pub const _VIDIOCBASE: u16 = 14080;
pub const _CELLIOCBASE: u16 = 14336;
pub const _MIPIDSIBASE: u16 = 14592;
pub const _SEIOCBASE: u16 = 14848;
pub const _SYSLOGBASE: u16 = 15360;
pub const _STEPIOBASE: u16 = 15616;
pub const _WLIOCBASE: u16 = 35584;
pub const _BOARDBASE: u16 = 65280;
pub const _IOC_MASK: u8 = 255;
pub const TIOCPKT_FLUSHREAD: u8 = 1;
pub const TIOCPKT_FLUSHWRITE: u8 = 2;
pub const TIOCPKT_STOP: u8 = 4;
pub const TIOCPKT_START: u8 = 8;
pub const TIOCPKT_DOSTOP: u8 = 16;
pub const TIOCPKT_NOSTOP: u8 = 32;
pub const TIOCM_LE: u8 = 1;
pub const TIOCM_DTR: u8 = 2;
pub const TIOCM_RTS: u8 = 4;
pub const TIOCM_ST: u8 = 8;
pub const TIOCM_SR: u8 = 16;
pub const TIOCM_CTS: u8 = 32;
pub const TIOCM_CAR: u8 = 64;
pub const TIOCM_CD: u8 = 64;
pub const TIOCM_RNG: u8 = 128;
pub const TIOCM_RI: u8 = 128;
pub const TIOCM_DSR: u16 = 256;
pub const SER_RS485_ENABLED: u8 = 1;
pub const SER_RS485_RTS_ON_SEND: u8 = 2;
pub const SER_RS485_RTS_AFTER_SEND: u8 = 4;
pub const SER_RS485_RX_DURING_TX: u8 = 16;
pub const SER_SINGLEWIRE_ENABLED: u8 = 1;
pub const SER_SINGLEWIRE_PULL_SHIFT: u8 = 1;
pub const SER_SINGLEWIRE_PULL_MASK: u8 = 6;
pub const SER_SINGLEWIRE_PULL_DISABLE: u8 = 0;
pub const SER_SINGLEWIRE_PULLUP: u8 = 2;
pub const SER_SINGLEWIRE_PULLDOWN: u8 = 4;
pub const SER_SINGLEWIRE_PUSHPULL: u8 = 8;
pub const SER_INVERT_ENABLED_RX: u8 = 1;
pub const SER_INVERT_ENABLED_TX: u8 = 2;
pub const SER_SWAP_ENABLED: u8 = 1;
pub const I2C_READBIT: u8 = 1;
pub const I2C_M_READ: u8 = 1;
pub const I2C_M_TEN: u8 = 2;
pub const I2C_M_NOSTOP: u8 = 64;
pub const I2C_M_NOSTART: u8 = 128;
pub const I2C_SPEED_STANDARD: u32 = 100000;
pub const I2C_SPEED_FAST: u32 = 400000;
pub const I2C_SPEED_FAST_PLUS: u32 = 1000000;
pub const I2C_SPEED_HIGH: u32 = 3400000;
pub const CONFIG_ADC_FIFOSIZE: u8 = 8;
pub const CONFIG_ADC_NPOLLWAITERS: u8 = 2;
pub const STM32_ADC_SR_OFFSET: u8 = 0;
pub const STM32_ADC_CR1_OFFSET: u8 = 4;
pub const STM32_ADC_CR2_OFFSET: u8 = 8;
pub const STM32_ADC_SMPR1_OFFSET: u8 = 12;
pub const STM32_ADC_SMPR2_OFFSET: u8 = 16;
pub const STM32_ADC_JOFR1_OFFSET: u8 = 20;
pub const STM32_ADC_JOFR2_OFFSET: u8 = 24;
pub const STM32_ADC_JOFR3_OFFSET: u8 = 28;
pub const STM32_ADC_JOFR4_OFFSET: u8 = 32;
pub const STM32_ADC_HTR_OFFSET: u8 = 36;
pub const STM32_ADC_LTR_OFFSET: u8 = 40;
pub const STM32_ADC_SQR1_OFFSET: u8 = 44;
pub const STM32_ADC_SQR2_OFFSET: u8 = 48;
pub const STM32_ADC_SQR3_OFFSET: u8 = 52;
pub const STM32_ADC_JSQR_OFFSET: u8 = 56;
pub const STM32_ADC_JDR1_OFFSET: u8 = 60;
pub const STM32_ADC_JDR2_OFFSET: u8 = 64;
pub const STM32_ADC_JDR3_OFFSET: u8 = 68;
pub const STM32_ADC_JDR4_OFFSET: u8 = 72;
pub const STM32_ADC_DR_OFFSET: u8 = 76;
pub const STM32_ADC_CSR_OFFSET: u8 = 0;
pub const STM32_ADC_CCR_OFFSET: u8 = 4;
pub const STM32_ADC_CDR_OFFSET: u8 = 8;
pub const STM32_ADC1_SR: u32 = 1073815552;
pub const STM32_ADC1_CR1: u32 = 1073815556;
pub const STM32_ADC1_CR2: u32 = 1073815560;
pub const STM32_ADC1_SMPR1: u32 = 1073815564;
pub const STM32_ADC1_SMPR2: u32 = 1073815568;
pub const STM32_ADC1_JOFR1: u32 = 1073815572;
pub const STM32_ADC1_JOFR2: u32 = 1073815576;
pub const STM32_ADC1_JOFR3: u32 = 1073815580;
pub const STM32_ADC1_JOFR4: u32 = 1073815584;
pub const STM32_ADC1_HTR: u32 = 1073815588;
pub const STM32_ADC1_LTR: u32 = 1073815592;
pub const STM32_ADC1_SQR1: u32 = 1073815596;
pub const STM32_ADC1_SQR2: u32 = 1073815600;
pub const STM32_ADC1_SQR3: u32 = 1073815604;
pub const STM32_ADC1_JSQR: u32 = 1073815608;
pub const STM32_ADC1_JDR1: u32 = 1073815612;
pub const STM32_ADC1_JDR2: u32 = 1073815616;
pub const STM32_ADC1_JDR3: u32 = 1073815620;
pub const STM32_ADC1_JDR4: u32 = 1073815624;
pub const STM32_ADC1_DR: u32 = 1073815628;
pub const STM32_ADC2_SR: u32 = 1073815808;
pub const STM32_ADC2_CR1: u32 = 1073815812;
pub const STM32_ADC2_CR2: u32 = 1073815816;
pub const STM32_ADC2_SMPR1: u32 = 1073815820;
pub const STM32_ADC2_SMPR2: u32 = 1073815824;
pub const STM32_ADC2_JOFR1: u32 = 1073815828;
pub const STM32_ADC2_JOFR2: u32 = 1073815832;
pub const STM32_ADC2_JOFR3: u32 = 1073815836;
pub const STM32_ADC2_JOFR4: u32 = 1073815840;
pub const STM32_ADC2_HTR: u32 = 1073815844;
pub const STM32_ADC2_LTR: u32 = 1073815848;
pub const STM32_ADC2_SQR1: u32 = 1073815852;
pub const STM32_ADC2_SQR2: u32 = 1073815856;
pub const STM32_ADC2_SQR3: u32 = 1073815860;
pub const STM32_ADC2_JSQR: u32 = 1073815864;
pub const STM32_ADC2_JDR1: u32 = 1073815868;
pub const STM32_ADC2_JDR2: u32 = 1073815872;
pub const STM32_ADC2_JDR3: u32 = 1073815876;
pub const STM32_ADC2_JDR4: u32 = 1073815880;
pub const STM32_ADC2_DR: u32 = 1073815884;
pub const STM32_ADC3_SR: u32 = 1073816064;
pub const STM32_ADC3_CR1: u32 = 1073816068;
pub const STM32_ADC3_CR2: u32 = 1073816072;
pub const STM32_ADC3_SMPR1: u32 = 1073816076;
pub const STM32_ADC3_SMPR2: u32 = 1073816080;
pub const STM32_ADC3_JOFR1: u32 = 1073816084;
pub const STM32_ADC3_JOFR2: u32 = 1073816088;
pub const STM32_ADC3_JOFR3: u32 = 1073816092;
pub const STM32_ADC3_JOFR4: u32 = 1073816096;
pub const STM32_ADC3_HTR: u32 = 1073816100;
pub const STM32_ADC3_LTR: u32 = 1073816104;
pub const STM32_ADC3_SQR1: u32 = 1073816108;
pub const STM32_ADC3_SQR2: u32 = 1073816112;
pub const STM32_ADC3_SQR3: u32 = 1073816116;
pub const STM32_ADC3_JSQR: u32 = 1073816120;
pub const STM32_ADC3_JDR1: u32 = 1073816124;
pub const STM32_ADC3_JDR2: u32 = 1073816128;
pub const STM32_ADC3_JDR3: u32 = 1073816132;
pub const STM32_ADC3_JDR4: u32 = 1073816136;
pub const STM32_ADC3_DR: u32 = 1073816140;
pub const STM32_ADC_CSR: u32 = 1073816320;
pub const STM32_ADC_CCR: u32 = 1073816324;
pub const STM32_ADC_CDR: u32 = 1073816328;
pub const ADC_SR_AWD: u8 = 1;
pub const ADC_SR_EOC: u8 = 2;
pub const ADC_SR_JEOC: u8 = 4;
pub const ADC_SR_JSTRT: u8 = 8;
pub const ADC_SR_STRT: u8 = 16;
pub const ADC_SR_OVR: u8 = 32;
pub const ADC_CR1_AWDCH_SHIFT: u8 = 0;
pub const ADC_CR1_AWDCH_MASK: u8 = 31;
pub const ADC_CR1_EOCIE: u8 = 32;
pub const ADC_CR1_AWDIE: u8 = 64;
pub const ADC_CR1_JEOCIE: u8 = 128;
pub const ADC_CR1_SCAN: u16 = 256;
pub const ADC_CR1_AWDSGL: u16 = 512;
pub const ADC_CR1_JAUTO: u16 = 1024;
pub const ADC_CR1_DISCEN: u16 = 2048;
pub const ADC_CR1_JDISCEN: u16 = 4096;
pub const ADC_CR1_DISCNUM_SHIFT: u8 = 13;
pub const ADC_CR1_DISCNUM_MASK: u16 = 57344;
pub const ADC_CR1_JAWDEN: u32 = 4194304;
pub const ADC_CR1_AWDEN: u32 = 8388608;
pub const ADC_CR1_RES_SHIFT: u8 = 24;
pub const ADC_CR1_RES_MASK: u32 = 50331648;
pub const ADC_CR1_RES_12BIT: u8 = 0;
pub const ADC_CR1_RES_10BIT: u32 = 16777216;
pub const ADC_CR1_RES_8BIT: u32 = 33554432;
pub const ADC_CR1_RES_6BIT: u32 = 50331648;
pub const ADC_CR1_OVRIE: u32 = 67108864;
pub const ADC_CR2_ADON: u8 = 1;
pub const ADC_CR2_CONT: u8 = 2;
pub const ADC_CR2_DMA: u16 = 256;
pub const ADC_CR2_DDS: u16 = 512;
pub const ADC_CR2_EOCS: u16 = 1024;
pub const ADC_CR2_ALIGN: u16 = 2048;
pub const ADC_CR2_JEXTSEL_SHIFT: u8 = 16;
pub const ADC_CR2_JEXTSEL_MASK: u32 = 983040;
pub const ADC_CR2_JEXTSEL_T1TRGO: u8 = 0;
pub const ADC_CR2_JEXTSEL_T1CC4: u32 = 65536;
pub const ADC_CR2_JEXTSEL_T2TRGO: u32 = 131072;
pub const ADC_CR2_JEXTSEL_T2CC1: u32 = 196608;
pub const ADC_CR2_JEXTSEL_T3CC4: u32 = 262144;
pub const ADC_CR2_JEXTSEL_T4TRGO: u32 = 327680;
pub const ADC_CR2_JEXTSEL_T8CC4: u32 = 458752;
pub const ADC_CR2_JEXTSEL_T1TRGO2: u32 = 524288;
pub const ADC_CR2_JEXTSEL_T8TRGO: u32 = 589824;
pub const ADC_CR2_JEXTSEL_T8TRGO2: u32 = 655360;
pub const ADC_CR2_JEXTSEL_T3CC3: u32 = 720896;
pub const ADC_CR2_JEXTSEL_T5TRGO: u32 = 786432;
pub const ADC_CR2_JEXTSEL_T3CC1: u32 = 851968;
pub const ADC_CR2_JEXTSEL_T6TRGO: u32 = 917504;
pub const ADC_CR2_JEXTEN_SHIFT: u8 = 20;
pub const ADC_CR2_JEXTEN_MASK: u32 = 3145728;
pub const ADC_CR2_JEXTEN_NONE: u8 = 0;
pub const ADC_CR2_JEXTEN_RISING: u32 = 1048576;
pub const ADC_CR2_JEXTEN_FALLING: u32 = 2097152;
pub const ADC_CR2_JEXTEN_BOTH: u32 = 3145728;
pub const ADC_CR2_JSWSTART: u32 = 4194304;
pub const ADC_CR2_EXTSEL_SHIFT: u8 = 24;
pub const ADC_CR2_EXTSEL_MASK: u32 = 251658240;
pub const ADC_CR2_EXTSEL_T1CC1: u8 = 0;
pub const ADC_CR2_EXTSEL_T1CC2: u32 = 16777216;
pub const ADC_CR2_EXTSEL_T1CC3: u32 = 33554432;
pub const ADC_CR2_EXTSEL_T2CC2: u32 = 50331648;
pub const ADC_CR2_EXTSEL_T5TRGO: u32 = 67108864;
pub const ADC_CR2_EXTSEL_T4CC4: u32 = 83886080;
pub const ADC_CR2_EXTSEL_T3CC4: u32 = 100663296;
pub const ADC_CR2_EXTSEL_T8TRGO: u32 = 117440512;
pub const ADC_CR2_EXTSEL_T8TRGO2: u32 = 134217728;
pub const ADC_CR2_EXTSEL_T1TRGO: u32 = 150994944;
pub const ADC_CR2_EXTSEL_T1TRGO2: u32 = 167772160;
pub const ADC_CR2_EXTSEL_T2TRGO: u32 = 184549376;
pub const ADC_CR2_EXTSEL_T4TRGO: u32 = 201326592;
pub const ADC_CR2_EXTSEL_T6TRGO: u32 = 218103808;
pub const ADC_CR2_EXTSEL_EXTI11: u32 = 251658240;
pub const ADC_CR2_EXTEN_SHIFT: u8 = 28;
pub const ADC_CR2_EXTEN_MASK: u32 = 805306368;
pub const ADC_CR2_EXTEN_NONE: u8 = 0;
pub const ADC_CR2_EXTEN_RISING: u32 = 268435456;
pub const ADC_CR2_EXTEN_FALLING: u32 = 536870912;
pub const ADC_CR2_EXTEN_BOTH: u32 = 805306368;
pub const ADC_CR2_SWSTART: u32 = 1073741824;
pub const ADC_SMPR_3: u8 = 0;
pub const ADC_SMPR_15: u8 = 1;
pub const ADC_SMPR_28: u8 = 2;
pub const ADC_SMPR_56: u8 = 3;
pub const ADC_SMPR_84: u8 = 4;
pub const ADC_SMPR_112: u8 = 5;
pub const ADC_SMPR_144: u8 = 6;
pub const ADC_SMPR_480: u8 = 7;
pub const ADC_SMPR1_SMP10_SHIFT: u8 = 0;
pub const ADC_SMPR1_SMP10_MASK: u8 = 7;
pub const ADC_SMPR1_SMP11_SHIFT: u8 = 3;
pub const ADC_SMPR1_SMP11_MASK: u8 = 56;
pub const ADC_SMPR1_SMP12_SHIFT: u8 = 6;
pub const ADC_SMPR1_SMP12_MASK: u16 = 448;
pub const ADC_SMPR1_SMP13_SHIFT: u8 = 9;
pub const ADC_SMPR1_SMP13_MASK: u16 = 3584;
pub const ADC_SMPR1_SMP14_SHIFT: u8 = 12;
pub const ADC_SMPR1_SMP14_MASK: u16 = 28672;
pub const ADC_SMPR1_SMP15_SHIFT: u8 = 15;
pub const ADC_SMPR1_SMP15_MASK: u32 = 229376;
pub const ADC_SMPR1_SMP16_SHIFT: u8 = 18;
pub const ADC_SMPR1_SMP16_MASK: u32 = 1835008;
pub const ADC_SMPR1_SMP17_SHIFT: u8 = 21;
pub const ADC_SMPR1_SMP17_MASK: u32 = 14680064;
pub const ADC_SMPR1_SMP18_SHIFT: u8 = 24;
pub const ADC_SMPR1_SMP18_MASK: u32 = 117440512;
pub const ADC_SMPR2_SMP0_SHIFT: u8 = 0;
pub const ADC_SMPR2_SMP0_MASK: u8 = 7;
pub const ADC_SMPR2_SMP1_SHIFT: u8 = 3;
pub const ADC_SMPR2_SMP1_MASK: u8 = 56;
pub const ADC_SMPR2_SMP2_SHIFT: u8 = 6;
pub const ADC_SMPR2_SMP2_MASK: u16 = 448;
pub const ADC_SMPR2_SMP3_SHIFT: u8 = 9;
pub const ADC_SMPR2_SMP3_MASK: u16 = 3584;
pub const ADC_SMPR2_SMP4_SHIFT: u8 = 12;
pub const ADC_SMPR2_SMP4_MASK: u16 = 28672;
pub const ADC_SMPR2_SMP5_SHIFT: u8 = 15;
pub const ADC_SMPR2_SMP5_MASK: u32 = 229376;
pub const ADC_SMPR2_SMP6_SHIFT: u8 = 18;
pub const ADC_SMPR2_SMP6_MASK: u32 = 1835008;
pub const ADC_SMPR2_SMP7_SHIFT: u8 = 21;
pub const ADC_SMPR2_SMP7_MASK: u32 = 14680064;
pub const ADC_SMPR2_SMP8_SHIFT: u8 = 24;
pub const ADC_SMPR2_SMP8_MASK: u32 = 117440512;
pub const ADC_SMPR2_SMP9_SHIFT: u8 = 27;
pub const ADC_SMPR2_SMP9_MASK: u32 = 939524096;
pub const ADC_JOFR_SHIFT: u8 = 0;
pub const ADC_JOFR_MASK: u16 = 4095;
pub const ADC_HTR_SHIFT: u8 = 0;
pub const ADC_HTR_MASK: u16 = 4095;
pub const ADC_LTR_SHIFT: u8 = 0;
pub const ADC_LTR_MASK: u16 = 4095;
pub const ADC_SQR1_SQ13_SHIFT: u8 = 0;
pub const ADC_SQR1_SQ13_MASK: u8 = 31;
pub const ADC_SQR1_SQ14_SHIFT: u8 = 5;
pub const ADC_SQR1_SQ14_MASK: u16 = 992;
pub const ADC_SQR1_SQ15_SHIFT: u8 = 10;
pub const ADC_SQR1_SQ15_MASK: u16 = 31744;
pub const ADC_SQR1_SQ16_SHIFT: u8 = 15;
pub const ADC_SQR1_SQ16_MASK: u32 = 1015808;
pub const ADC_SQR1_L_SHIFT: u8 = 20;
pub const ADC_SQR1_L_MASK: u32 = 15728640;
pub const ADC_SQR1_RESERVED: u32 = 4278190080;
pub const ADC_SQR1_FIRST: u8 = 13;
pub const ADC_SQR1_LAST: u8 = 16;
pub const ADC_SQR1_SQ_OFFSET: u8 = 0;
pub const ADC_SQR2_SQ7_SHIFT: u8 = 0;
pub const ADC_SQR2_SQ7_MASK: u8 = 31;
pub const ADC_SQR2_SQ8_SHIFT: u8 = 5;
pub const ADC_SQR2_SQ8_MASK: u16 = 992;
pub const ADC_SQR2_SQ9_SHIFT: u8 = 10;
pub const ADC_SQR2_SQ9_MASK: u16 = 31744;
pub const ADC_SQR2_SQ10_SHIFT: u8 = 15;
pub const ADC_SQR2_SQ10_MASK: u32 = 1015808;
pub const ADC_SQR2_SQ11_SHIFT: u8 = 20;
pub const ADC_SQR2_SQ11_MASK: u32 = 32505856;
pub const ADC_SQR2_SQ12_SHIFT: u8 = 25;
pub const ADC_SQR2_SQ12_MASK: u32 = 1040187392;
pub const ADC_SQR2_RESERVED: u32 = 3221225472;
pub const ADC_SQR2_FIRST: u8 = 7;
pub const ADC_SQR2_LAST: u8 = 12;
pub const ADC_SQR2_SQ_OFFSET: u8 = 0;
pub const ADC_SQR3_SQ1_SHIFT: u8 = 0;
pub const ADC_SQR3_SQ1_MASK: u8 = 31;
pub const ADC_SQR3_SQ2_SHIFT: u8 = 5;
pub const ADC_SQR3_SQ2_MASK: u16 = 992;
pub const ADC_SQR3_SQ3_SHIFT: u8 = 10;
pub const ADC_SQR3_SQ3_MASK: u16 = 31744;
pub const ADC_SQR3_SQ4_SHIFT: u8 = 15;
pub const ADC_SQR3_SQ4_MASK: u32 = 1015808;
pub const ADC_SQR3_SQ5_SHIFT: u8 = 20;
pub const ADC_SQR3_SQ5_MASK: u32 = 32505856;
pub const ADC_SQR3_SQ6_SHIFT: u8 = 25;
pub const ADC_SQR3_SQ6_MASK: u32 = 1040187392;
pub const ADC_SQR3_RESERVED: u32 = 3221225472;
pub const ADC_SQR3_FIRST: u8 = 1;
pub const ADC_SQR3_LAST: u8 = 6;
pub const ADC_SQR3_SQ_OFFSET: u8 = 0;
pub const ADC_SQ_OFFSET: u8 = 5;
pub const ADC_JSQR_JSQ1_SHIFT: u8 = 0;
pub const ADC_JSQR_JSQ1_MASK: u8 = 31;
pub const ADC_JSQR_JSQ2_SHIFT: u8 = 5;
pub const ADC_JSQR_JSQ2_MASK: u16 = 992;
pub const ADC_JSQR_JSQ3_SHIFT: u8 = 10;
pub const ADC_JSQR_JSQ3_MASK: u16 = 31744;
pub const ADC_JSQR_JSQ4_SHIFT: u8 = 15;
pub const ADC_JSQR_JSQ4_MASK: u32 = 1015808;
pub const ADC_JSQR_JSQ_SHIFT: u8 = 5;
pub const ADC_JSQR_JL_SHIFT: u8 = 20;
pub const ADC_JSQR_JL_MASK: u32 = 3145728;
pub const ADC_JDR_JDATA_SHIFT: u8 = 0;
pub const ADC_JDR_JDATA_MASK: u16 = 65535;
pub const ADC_DR_RDATA_SHIFT: u8 = 0;
pub const ADC_DR_RDATA_MASK: u16 = 65535;
pub const ADC_CSR_AWD1: u8 = 1;
pub const ADC_CSR_EOC1: u8 = 2;
pub const ADC_CSR_JEOC1: u8 = 4;
pub const ADC_CSR_JSTRT1: u8 = 8;
pub const ADC_CSR_STRT1: u8 = 16;
pub const ADC_CSR_OVR1: u8 = 32;
pub const ADC_CSR_AWD2: u16 = 256;
pub const ADC_CSR_EOC2: u16 = 512;
pub const ADC_CSR_JEOC2: u16 = 1024;
pub const ADC_CSR_JSTRT2: u16 = 2048;
pub const ADC_CSR_STRT2: u16 = 4096;
pub const ADC_CSR_OVR2: u16 = 8192;
pub const ADC_CSR_AWD3: u32 = 65536;
pub const ADC_CSR_EOC3: u32 = 131072;
pub const ADC_CSR_JEOC3: u32 = 262144;
pub const ADC_CSR_JSTRT3: u32 = 524288;
pub const ADC_CSR_STRT3: u32 = 1048576;
pub const ADC_CSR_OVR3: u32 = 2097152;
pub const ADC_CCR_MULTI_SHIFT: u8 = 0;
pub const ADC_CCR_MULTI_MASK: u8 = 31;
pub const ADC_CCR_MULTI_NONE: u8 = 0;
pub const ADC_CCR_MULTI_RSISM2: u8 = 1;
pub const ADC_CCR_MULTI_RSATM2: u8 = 2;
pub const ADC_CCR_MULTI_ISM2: u8 = 5;
pub const ADC_CCR_MULTI_RSM2: u8 = 6;
pub const ADC_CCR_MULTI_IM2: u8 = 7;
pub const ADC_CCR_MULTI_ATM2: u8 = 9;
pub const ADC_CCR_MULTI_RSISM3: u8 = 17;
pub const ADC_CCR_MULTI_RSATM3: u8 = 18;
pub const ADC_CCR_MULTI_ISM3: u8 = 21;
pub const ADC_CCR_MULTI_RSM3: u8 = 22;
pub const ADC_CCR_MULTI_IM3: u8 = 23;
pub const ADC_CCR_MULTI_ATM3: u8 = 25;
pub const ADC_CCR_DELAY_SHIFT: u8 = 8;
pub const ADC_CCR_DELAY_MASK: u16 = 3840;
pub const ADC_CCR_DDS: u16 = 8192;
pub const ADC_CCR_DMA_SHIFT: u8 = 14;
pub const ADC_CCR_DMA_MASK: u16 = 49152;
pub const ADC_CCR_DMA_DISABLED: u8 = 0;
pub const ADC_CCR_DMA_MODE1: u16 = 16384;
pub const ADC_CCR_DMA_MODE2: u16 = 32768;
pub const ADC_CCR_DMA_MODE3: u16 = 49152;
pub const ADC_CCR_ADCPRE_SHIFT: u8 = 16;
pub const ADC_CCR_ADCPRE_MASK: u32 = 196608;
pub const ADC_CCR_ADCPRE_DIV2: u8 = 0;
pub const ADC_CCR_ADCPRE_DIV4: u32 = 65536;
pub const ADC_CCR_ADCPRE_DIV6: u32 = 131072;
pub const ADC_CCR_ADCPRE_DIV8: u32 = 196608;
pub const ADC_CCR_VBATE: u32 = 4194304;
pub const ADC_CCR_TSVREFE: u32 = 8388608;
pub const STM32_ADC_DMAREG_OFFSET: u8 = 8;
pub const ADC_DMAREG_DMA: u16 = 256;
pub const STM32_ADC_EXTREG_OFFSET: u8 = 8;
pub const ADC_EXTREG_EXTSEL_MASK: u32 = 251658240;
pub const ADC_EXTREG_EXTSEL_SHIFT: u8 = 24;
pub const STM32_ADC_JEXTREG_OFFSET: u8 = 8;
pub const ADC_JEXTREG_JEXTSEL_MASK: u32 = 983040;
pub const ADC_EXTREG_JEXTSEL_SHIFT: u8 = 16;
pub const STM32_ADC_ISR_OFFSET: u8 = 0;
pub const STM32_ADC_IER_OFFSET: u8 = 4;
pub const ADC_EXTREG_EXTEN_MASK: u32 = 805306368;
pub const ADC_EXTREG_EXTEN_NONE: u8 = 0;
pub const ADC_EXTREG_EXTEN_DEFAULT: u32 = 268435456;
pub const ADC_JEXTREG_JEXTEN_MASK: u32 = 3145728;
pub const ADC_JEXTREG_JEXTEN_NONE: u8 = 0;
pub const ADC_JEXTREG_JEXTEN_DEFAULT: u32 = 1048576;
pub const EXIT_SUCCESS: u8 = 0;
pub const EXIT_FAILURE: u8 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const MB_CUR_MAX: u8 = 4;
pub const HPWORK: u8 = 0;
pub const LPWORK: u8 = 0;
pub const USRWORK: u8 = 0;
pub const F_OK: u8 = 0;
pub const X_OK: u8 = 1;
pub const W_OK: u8 = 2;
pub const R_OK: u8 = 4;
pub const _POSIX_MESSAGE_PASSING: u8 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u8 = 1;
pub const _POSIX_TIMERS: u8 = 1;
pub const _POSIX_TIMEOUTS: u8 = 1;
pub const _POSIX_SYNCHRONIZED_IO: u8 = 1;
pub const _POSIX_VERSION: u32 = 201712;
pub const _POSIX_PRIORITIZED_IO: u32 = 201712;
pub const _POSIX_CPUTIME: u32 = 201712;
pub const _POSIX_THREAD_CPUTIME: u32 = 201712;
pub const _POSIX_REALTIME_SIGNALS: u32 = 201712;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 201712;
pub const _POSIX_SEMAPHORES: u32 = 201712;
pub const _POSIX_SPORADIC_SERVER: i8 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i8 = -1;
pub const _POSIX_SYNC_IO: u8 = 1;
pub const _PC_2_SYMLINKS: u8 = 1;
pub const _PC_ALLOC_SIZE_MIN: u8 = 2;
pub const _PC_ASYNC_IO: u8 = 3;
pub const _PC_CHOWN_RESTRICTED: u8 = 4;
pub const _PC_FILESIZEBITS: u8 = 5;
pub const _PC_LINK_MAX: u8 = 6;
pub const _PC_MAX_CANON: u8 = 7;
pub const _PC_MAX_INPUT: u8 = 8;
pub const _PC_NAME_MAX: u8 = 9;
pub const _PC_NO_TRUNC: u8 = 10;
pub const _PC_PATH_MAX: u8 = 11;
pub const _PC_PIPE_BUF: u8 = 12;
pub const _PC_PRIO_IO: u8 = 13;
pub const _PC_REC_INCR_XFER_SIZE: u8 = 14;
pub const _PC_REC_MIN_XFER_SIZE: u8 = 15;
pub const _PC_REC_XFER_ALIGN: u8 = 16;
pub const _PC_SYMLINK_MAX: u8 = 17;
pub const _PC_SYNC_IO: u8 = 18;
pub const _PC_VDISABLE: u8 = 19;
pub const _SC_2_C_BIND: u8 = 1;
pub const _SC_2_C_DEV: u8 = 2;
pub const _SC_2_CHAR_TERM: u8 = 3;
pub const _SC_2_FORT_DEV: u8 = 4;
pub const _SC_2_FORT_RUN: u8 = 5;
pub const _SC_2_LOCALEDEF: u8 = 6;
pub const _SC_2_PBS: u8 = 7;
pub const _SC_2_PBS_ACCOUNTING: u8 = 8;
pub const _SC_2_PBS_CHECKPOINT: u8 = 9;
pub const _SC_2_PBS_LOCATE: u8 = 10;
pub const _SC_2_PBS_MESSAGE: u8 = 11;
pub const _SC_2_PBS_TRACK: u8 = 12;
pub const _SC_2_SW_DEV: u8 = 13;
pub const _SC_2_UPE: u8 = 14;
pub const _SC_2_VERSION: u8 = 15;
pub const _SC_ADVISORY_INFO: u8 = 16;
pub const _SC_AIO_LISTIO_MAX: u8 = 17;
pub const _SC_AIO_MAX: u8 = 18;
pub const _SC_AIO_PRIO_DELTA_MAX: u8 = 19;
pub const _SC_ARG_MAX: u8 = 20;
pub const _SC_ASYNCHRONOUS_IO: u8 = 21;
pub const _SC_ATEXIT_MAX: u8 = 22;
pub const _SC_BARRIERS: u8 = 23;
pub const _SC_BC_BASE_MAX: u8 = 24;
pub const _SC_BC_DIM_MAX: u8 = 25;
pub const _SC_BC_SCALE_MAX: u8 = 26;
pub const _SC_BC_STRING_MAX: u8 = 27;
pub const _SC_CHILD_MAX: u8 = 28;
pub const _SC_CLK_TCK: u8 = 29;
pub const _SC_CLOCK_SELECTION: u8 = 30;
pub const _SC_COLL_WEIGHTS_MAX: u8 = 31;
pub const _SC_CPUTIME: u8 = 32;
pub const _SC_DELAYTIMER_MAX: u8 = 33;
pub const _SC_EXPR_NEST_MAX: u8 = 34;
pub const _SC_FSYNC: u8 = 35;
pub const _SC_GETGR_R_SIZE_MAX: u8 = 36;
pub const _SC_GETPW_R_SIZE_MAX: u8 = 37;
pub const _SC_HOST_NAME_MAX: u8 = 38;
pub const _SC_IOV_MAX: u8 = 39;
pub const _SC_IPV6: u8 = 40;
pub const _SC_JOB_CONTROL: u8 = 41;
pub const _SC_LINE_MAX: u8 = 42;
pub const _SC_LOGIN_NAME_MAX: u8 = 43;
pub const _SC_MAPPED_FILES: u8 = 44;
pub const _SC_MEMLOCK: u8 = 45;
pub const _SC_MEMLOCK_RANGE: u8 = 46;
pub const _SC_MEMORY_PROTECTION: u8 = 47;
pub const _SC_MESSAGE_PASSING: u8 = 48;
pub const _SC_MONOTONIC_CLOCK: u8 = 49;
pub const _SC_MQ_OPEN_MAX: u8 = 50;
pub const _SC_MQ_PRIO_MAX: u8 = 51;
pub const _SC_NGROUPS_MAX: u8 = 52;
pub const _SC_OPEN_MAX: u8 = 53;
pub const _SC_PAGE_SIZE: u8 = 54;
pub const _SC_PAGESIZE: u8 = 54;
pub const _SC_PRIORITIZED_IO: u8 = 55;
pub const _SC_PRIORITY_SCHEDULING: u8 = 56;
pub const _SC_RAW_SOCKETS: u8 = 57;
pub const _SC_RE_DUP_MAX: u8 = 58;
pub const _SC_READER_WRITER_LOCKS: u8 = 59;
pub const _SC_REALTIME_SIGNALS: u8 = 60;
pub const _SC_REGEXP: u8 = 61;
pub const _SC_RTSIG_MAX: u8 = 62;
pub const _SC_SAVED_IDS: u8 = 63;
pub const _SC_SEM_NSEMS_MAX: u8 = 64;
pub const _SC_SEM_VALUE_MAX: u8 = 65;
pub const _SC_SEMAPHORES: u8 = 66;
pub const _SC_SHARED_MEMORY_OBJECTS: u8 = 67;
pub const _SC_SHELL: u8 = 68;
pub const _SC_SIGQUEUE_MAX: u8 = 69;
pub const _SC_SPAWN: u8 = 70;
pub const _SC_SPIN_LOCKS: u8 = 71;
pub const _SC_SPORADIC_SERVER: u8 = 72;
pub const _SC_SS_REPL_MAX: u8 = 73;
pub const _SC_STREAM_MAX: u8 = 74;
pub const _SC_SYMLOOP_MAX: u8 = 75;
pub const _SC_SYNCHRONIZED_IO: u8 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: u8 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: u8 = 78;
pub const _SC_THREAD_CPUTIME: u8 = 79;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u8 = 80;
pub const _SC_THREAD_KEYS_MAX: u8 = 81;
pub const _SC_THREAD_PRIO_INHERIT: u8 = 82;
pub const _SC_THREAD_PRIO_PROTECT: u8 = 83;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u8 = 84;
pub const _SC_THREAD_PROCESS_SHARED: u8 = 85;
pub const _SC_THREAD_SAFE_FUNCTIONS: u8 = 86;
pub const _SC_THREAD_SPORADIC_SERVER: u8 = 87;
pub const _SC_THREAD_STACK_MIN: u8 = 88;
pub const _SC_THREAD_THREADS_MAX: u8 = 89;
pub const _SC_THREADS: u8 = 90;
pub const _SC_TIMEOUTS: u8 = 91;
pub const _SC_TIMER_MAX: u8 = 92;
pub const _SC_TIMERS: u8 = 93;
pub const _SC_TRACE: u8 = 94;
pub const _SC_TRACE_EVENT_FILTER: u8 = 95;
pub const _SC_TRACE_EVENT_NAME_MAX: u8 = 96;
pub const _SC_TRACE_INHERIT: u8 = 97;
pub const _SC_TRACE_LOG: u8 = 98;
pub const _SC_TRACE_NAME_MAX: u8 = 99;
pub const _SC_TRACE_SYS_MAX: u8 = 100;
pub const _SC_TRACE_USER_EVENT_MAX: u8 = 101;
pub const _SC_TTY_NAME_MAX: u8 = 102;
pub const _SC_TYPED_MEMORY_OBJECTS: u8 = 103;
pub const _SC_TZNAME_MAX: u8 = 104;
pub const _SC_V6_ILP32_OFF32: u8 = 105;
pub const _SC_V6_ILP32_OFFBIG: u8 = 106;
pub const _SC_V6_LP64_OFF64: u8 = 107;
pub const _SC_V6_LPBIG_OFFBIG: u8 = 108;
pub const _SC_VERSION: u8 = 109;
pub const _SC_XBS5_ILP32_OFF32: u8 = 110;
pub const _SC_XBS5_ILP32_OFFBIG: u8 = 111;
pub const _SC_XBS5_LP64_OFF64: u8 = 112;
pub const _SC_XBS5_LPBIG_OFFBIG: u8 = 113;
pub const _SC_XOPEN_CRYPT: u8 = 114;
pub const _SC_XOPEN_ENH_I18N: u8 = 115;
pub const _SC_XOPEN_LEGACY: u8 = 116;
pub const _SC_XOPEN_REALTIME: u8 = 117;
pub const _SC_XOPEN_REALTIME_THREADS: u8 = 118;
pub const _SC_XOPEN_SHM: u8 = 119;
pub const _SC_XOPEN_STREAMS: u8 = 120;
pub const _SC_XOPEN_UNIX: u8 = 121;
pub const _SC_XOPEN_VERSION: u8 = 122;
pub const _SC_PHYS_PAGES: u8 = 123;
pub const _SC_AVPHYS_PAGES: u8 = 124;
pub const _SC_NPROCESSORS_CONF: u8 = 125;
pub const _SC_NPROCESSORS_ONLN: u8 = 126;
pub const STDERR_FILENO: u8 = 2;
pub const STDIN_FILENO: u8 = 0;
pub const STDOUT_FILENO: u8 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u8 = 0;
pub const PTHREAD_PROCESS_SHARED: u8 = 1;
pub const PTHREAD_MUTEX_NORMAL: u8 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u8 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u8 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u8 = 0;
pub const PTHREAD_STACK_MIN: u16 = 256;
pub const PTHREAD_STACK_DEFAULT: u16 = 2048;
pub const PTHREAD_INHERIT_SCHED: u8 = 0;
pub const PTHREAD_EXPLICIT_SCHED: u8 = 1;
pub const PTHREAD_CREATE_JOINABLE: u8 = 0;
pub const PTHREAD_CREATE_DETACHED: u8 = 1;
pub const PTHREAD_DEFAULT_PRIORITY: u8 = 100;
pub const PTHREAD_CANCEL_ENABLE: u8 = 0;
pub const PTHREAD_CANCEL_DISABLE: u8 = 1;
pub const PTHREAD_CANCEL_DEFERRED: u8 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u8 = 1;
pub const PTHREAD_BARRIER_SERIAL_THREAD: u16 = 4096;
pub const PTHREAD_PRIO_NONE: u8 = 0;
pub const PTHREAD_PRIO_INHERIT: u8 = 1;
pub const PTHREAD_PRIO_PROTECT: u8 = 2;
pub const PTHREAD_MUTEX_STALLED: u8 = 0;
pub const PTHREAD_MUTEX_ROBUST: u8 = 1;
pub const _PTHREAD_MFLAGS_ROBUST: u8 = 1;
pub const _PTHREAD_MFLAGS_INCONSISTENT: u8 = 2;
pub const _PTHREAD_MFLAGS_NRECOVERABLE: u8 = 4;
pub const PTHREAD_SCOPE_SYSTEM: u8 = 0;
pub const PTHREAD_SCOPE_PROCESS: u8 = 1;
pub const __PTHREAD_KEY_T_DEFINED: u8 = 1;
pub const __PTHREAD_ADDR_T_DEFINED: u8 = 1;
pub const __PTHREAD_ATTR_T_DEFINED: u8 = 1;
pub const __PTHREAD_T_DEFINED: u8 = 1;
pub const __PTHREAD_CONDATTR_T_DEFINED: u8 = 1;
pub const __PTHREAD_COND_T_DEFINED: u8 = 1;
pub const __PTHREAD_MUTEXATTR_T_DEFINED: u8 = 1;
pub const __PTHREAD_MUTEX_T_DEFINED: u8 = 1;
pub const __PTHREAD_MUTEX_DEFAULT_FLAGS: u8 = 1;
pub const __PTHREAD_BARRIERATTR_T_DEFINED: u8 = 1;
pub const __PTHREAD_BARRIER_T_DEFINED: u8 = 1;
pub const __PTHREAD_ONCE_T_DEFINED: u8 = 1;
pub const __PTHREAD_RWLOCKATTR_T_DEFINED: u8 = 1;
pub const __PTHREAD_RWLOCK_T_DEFINED: u8 = 1;
pub const HAVE_GROUP_MEMBERS: u8 = 1;
pub const CONFIG_SCHED_SPORADIC_MAXREPL: u8 = 3;
pub const MAX_LOCK_COUNT: u8 = 127;
pub const TCB_FLAG_TTYPE_SHIFT: u8 = 0;
pub const TCB_FLAG_TTYPE_MASK: u8 = 3;
pub const TCB_FLAG_TTYPE_TASK: u8 = 0;
pub const TCB_FLAG_TTYPE_PTHREAD: u8 = 1;
pub const TCB_FLAG_TTYPE_KERNEL: u8 = 2;
pub const TCB_FLAG_POLICY_SHIFT: u8 = 3;
pub const TCB_FLAG_POLICY_MASK: u8 = 24;
pub const TCB_FLAG_SCHED_FIFO: u8 = 0;
pub const TCB_FLAG_SCHED_RR: u8 = 8;
pub const TCB_FLAG_SCHED_SPORADIC: u8 = 16;
pub const TCB_FLAG_CPU_LOCKED: u8 = 32;
pub const TCB_FLAG_SIGNAL_ACTION: u8 = 64;
pub const TCB_FLAG_SYSCALL: u8 = 128;
pub const TCB_FLAG_EXIT_PROCESSING: u16 = 256;
pub const TCB_FLAG_FREE_STACK: u16 = 512;
pub const TCB_FLAG_HEAP_CHECK: u16 = 1024;
pub const TCB_FLAG_HEAP_DUMP: u16 = 2048;
pub const TCB_FLAG_DETACHED: u16 = 4096;
pub const TCB_FLAG_FORCED_CANCEL: u16 = 8192;
pub const GROUP_FLAG_NOCLDWAIT: u8 = 1;
pub const GROUP_FLAG_PRIVILEGED: u8 = 2;
pub const GROUP_FLAG_DELETED: u8 = 4;
pub const GROUP_FLAG_EXITING: u8 = 8;
pub const CHILD_FLAG_TTYPE_SHIFT: u8 = 0;
pub const CHILD_FLAG_TTYPE_MASK: u8 = 3;
pub const CHILD_FLAG_TTYPE_TASK: u8 = 0;
pub const CHILD_FLAG_TTYPE_PTHREAD: u8 = 1;
pub const CHILD_FLAG_TTYPE_KERNEL: u8 = 2;
pub const CHILD_FLAG_EXITED: u8 = 4;
pub const SPORADIC_FLAG_ALLOCED: u8 = 1;
pub const SPORADIC_FLAG_MAIN: u8 = 2;
pub const SPORADIC_FLAG_REPLENISH: u8 = 4;
pub const TCB_NAME_OFF: u8 = 0;
pub const DEBUGPOINT_NONE: u8 = 0;
pub const DEBUGPOINT_WATCHPOINT_RO: u8 = 1;
pub const DEBUGPOINT_WATCHPOINT_WO: u8 = 2;
pub const DEBUGPOINT_WATCHPOINT_RW: u8 = 3;
pub const DEBUGPOINT_BREAKPOINT: u8 = 4;
pub const DEBUGPOINT_STEPPOINT: u8 = 5;
pub const M_TRIM_THRESHOLD: i8 = -1;
pub const M_TOP_PAD: i8 = -2;
pub const M_MMAP_THRESHOLD: i8 = -3;
pub const M_MMAP_MAX: i8 = -4;
pub const M_CHECK_ACTION: i8 = -5;
pub const M_PERTURB: i8 = -6;
pub const M_ARENA_TEST: i8 = -7;
pub const M_ARENA_MAX: i8 = -8;
pub const STM32_I2C_CR1_OFFSET: u8 = 0;
pub const STM32_I2C_CR2_OFFSET: u8 = 4;
pub const STM32_I2C_OAR1_OFFSET: u8 = 8;
pub const STM32_I2C_OAR2_OFFSET: u8 = 12;
pub const STM32_I2C_TIMINGR_OFFSET: u8 = 16;
pub const STM32_I2C_TIMEOUTR_OFFSET: u8 = 20;
pub const STM32_I2C_ISR_OFFSET: u8 = 24;
pub const STM32_I2C_ICR_OFFSET: u8 = 28;
pub const STM32_I2C_PECR_OFFSET: u8 = 32;
pub const STM32_I2C_RXDR_OFFSET: u8 = 36;
pub const STM32_I2C_TXDR_OFFSET: u8 = 40;
pub const STM32_I2C1_CR1: u32 = 1073763328;
pub const STM32_I2C1_CR2: u32 = 1073763332;
pub const STM32_I2C1_OAR1: u32 = 1073763336;
pub const STM32_I2C1_OAR2: u32 = 1073763340;
pub const STM32_I2C1_TIMINGR: u32 = 1073763344;
pub const STM32_I2C1_TIMEOUTR: u32 = 1073763348;
pub const STM32_I2C1_ISR: u32 = 1073763352;
pub const STM32_I2C1_ICR: u32 = 1073763356;
pub const STM32_I2C1_PECR: u32 = 1073763360;
pub const STM32_I2C1_RXDR: u32 = 1073763364;
pub const STM32_I2C1_TXDR: u32 = 1073763368;
pub const STM32_I2C2_CR1: u32 = 1073764352;
pub const STM32_I2C2_CR2: u32 = 1073764356;
pub const STM32_I2C2_OAR1: u32 = 1073764360;
pub const STM32_I2C2_OAR2: u32 = 1073764364;
pub const STM32_I2C2_TIMINGR: u32 = 1073764368;
pub const STM32_I2C2_TIMEOUTR: u32 = 1073764372;
pub const STM32_I2C2_ISR: u32 = 1073764376;
pub const STM32_I2C2_ICR: u32 = 1073764380;
pub const STM32_I2C2_PECR: u32 = 1073764384;
pub const STM32_I2C2_RXDR: u32 = 1073764388;
pub const STM32_I2C2_TXDR: u32 = 1073764392;
pub const STM32_I2C3_CR1: u32 = 1073765376;
pub const STM32_I2C3_CR2: u32 = 1073765380;
pub const STM32_I2C3_OAR1: u32 = 1073765384;
pub const STM32_I2C3_OAR2: u32 = 1073765388;
pub const STM32_I2C3_TIMINGR: u32 = 1073765392;
pub const STM32_I2C3_TIMEOUTR: u32 = 1073765396;
pub const STM32_I2C3_ISR: u32 = 1073765400;
pub const STM32_I2C3_ICR: u32 = 1073765404;
pub const STM32_I2C3_PECR: u32 = 1073765408;
pub const STM32_I2C3_RXDR: u32 = 1073765412;
pub const STM32_I2C3_TXDR: u32 = 1073765416;
pub const STM32_I2C4_CR1: u32 = 1073766400;
pub const STM32_I2C4_CR2: u32 = 1073766404;
pub const STM32_I2C4_OAR1: u32 = 1073766408;
pub const STM32_I2C4_OAR2: u32 = 1073766412;
pub const STM32_I2C4_TIMINGR: u32 = 1073766416;
pub const STM32_I2C4_TIMEOUTR: u32 = 1073766420;
pub const STM32_I2C4_ISR: u32 = 1073766424;
pub const STM32_I2C4_ICR: u32 = 1073766428;
pub const STM32_I2C4_PECR: u32 = 1073766432;
pub const STM32_I2C4_RXDR: u32 = 1073766436;
pub const STM32_I2C4_TXDR: u32 = 1073766440;
pub const I2C_CR1_PE: u8 = 1;
pub const I2C_CR1_TXIE: u8 = 2;
pub const I2C_CR1_RXIE: u8 = 4;
pub const I2C_CR1_ADDRIE: u8 = 8;
pub const I2C_CR1_NACKIE: u8 = 16;
pub const I2C_CR1_STOPIE: u8 = 32;
pub const I2C_CR1_TCIE: u8 = 64;
pub const I2C_CR1_ERRIE: u8 = 128;
pub const I2C_CR1_DNF_SHIFT: u8 = 8;
pub const I2C_CR1_DNF_MASK: u16 = 3840;
pub const I2C_CR1_DNF_DISABLE: u8 = 0;
pub const I2C_CR1_ANFOFF: u16 = 4096;
pub const I2C_CR1_TXDMAEN: u16 = 16384;
pub const I2C_CR1_RXDMAEN: u16 = 32768;
pub const I2C_CR1_SBC: u32 = 65536;
pub const I2C_CR1_NOSTRETCH: u32 = 131072;
pub const I2C_CR1_GCEN: u32 = 524288;
pub const I2C_CR1_SMBHEN: u32 = 1048576;
pub const I2C_CR1_SMBDEN: u32 = 2097152;
pub const I2C_CR1_ALERTEN: u32 = 4194304;
pub const I2C_CR1_PECEN: u32 = 8388608;
pub const I2C_CR2_SADD10_SHIFT: u8 = 0;
pub const I2C_CR2_SADD10_MASK: u16 = 1023;
pub const I2C_CR2_SADD7_SHIFT: u8 = 1;
pub const I2C_CR2_SADD7_MASK: u8 = 254;
pub const I2C_CR2_RD_WRN: u16 = 1024;
pub const I2C_CR2_ADD10: u16 = 2048;
pub const I2C_CR2_HEAD10R: u16 = 4096;
pub const I2C_CR2_START: u16 = 8192;
pub const I2C_CR2_STOP: u16 = 16384;
pub const I2C_CR2_NACK: u16 = 32768;
pub const I2C_CR2_NBYTES_SHIFT: u8 = 16;
pub const I2C_CR2_NBYTES_MASK: u32 = 16711680;
pub const I2C_CR2_RELOAD: u32 = 16777216;
pub const I2C_CR2_AUTOEND: u32 = 33554432;
pub const I2C_CR2_PECBYTE: u32 = 67108864;
pub const I2C_OAR1_OA1_10_SHIFT: u8 = 0;
pub const I2C_OAR1_OA1_10_MASK: u16 = 1023;
pub const I2C_OAR1_OA1_7_SHIFT: u8 = 1;
pub const I2C_OAR1_OA1_7_MASK: u8 = 254;
pub const I2C_OAR1_OA1MODE: u16 = 1024;
pub const I2C_OAR1_OA1EN: u16 = 32768;
pub const I2C_OAR2_OA2_SHIFT: u8 = 1;
pub const I2C_OAR2_OA2_MASK: u8 = 254;
pub const I2C_OAR2_OA2MSK_SHIFT: u8 = 8;
pub const I2C_OAR2_OA2MSK_MASK: u16 = 1792;
pub const I2C_OAR2_OA2MSK_NONE: u8 = 0;
pub const I2C_OAR2_OA2MSK_2_7: u16 = 256;
pub const I2C_OAR2_OA2MSK_3_7: u16 = 512;
pub const I2C_OAR2_OA2MSK_4_7: u16 = 768;
pub const I2C_OAR2_OA2MSK_5_7: u16 = 1024;
pub const I2C_OAR2_OA2MSK_6_7: u16 = 1280;
pub const I2C_OAR2_OA2MSK_7: u16 = 1536;
pub const I2C_OAR2_OA2MSK_ALL: u16 = 1792;
pub const I2C_OAR2_OA2EN: u16 = 32768;
pub const I2C_TIMINGR_SCLL_SHIFT: u8 = 0;
pub const I2C_TIMINGR_SCLL_MASK: u8 = 255;
pub const I2C_TIMINGR_SCLH_SHIFT: u8 = 8;
pub const I2C_TIMINGR_SCLH_MASK: u16 = 65280;
pub const I2C_TIMINGR_SDADEL_SHIFT: u8 = 16;
pub const I2C_TIMINGR_SDADEL_MASK: u32 = 983040;
pub const I2C_TIMINGR_SCLDEL_SHIFT: u8 = 20;
pub const I2C_TIMINGR_SCLDEL_MASK: u32 = 15728640;
pub const I2C_TIMINGR_PRESC_SHIFT: u8 = 28;
pub const I2C_TIMINGR_PRESC_MASK: u32 = 4026531840;
pub const I2C_TIMEOUTR_A_SHIFT: u8 = 0;
pub const I2C_TIMEOUTR_A_MASK: u16 = 4095;
pub const I2C_TIMEOUTR_TIDLE: u16 = 4096;
pub const I2C_TIMEOUTR_TIMOUTEN: u16 = 32768;
pub const I2C_TIMEOUTR_B_SHIFT: u8 = 16;
pub const I2C_TIMEOUTR_B_MASK: u32 = 268369920;
pub const I2C_TIMEOUTR_TEXTEN: u32 = 2147483648;
pub const I2C_ISR_TXE: u8 = 1;
pub const I2C_ISR_TXIS: u8 = 2;
pub const I2C_ISR_RXNE: u8 = 4;
pub const I2C_ISR_TC: u8 = 64;
pub const I2C_ISR_TCR: u8 = 128;
pub const I2C_ISR_BUSY: u16 = 32768;
pub const I2C_ISR_DIR: u32 = 65536;
pub const I2C_ISR_ADDCODE_SHIFT: u8 = 17;
pub const I2C_ISR_ADDCODE_MASK: u32 = 16646144;
pub const I2C_INT_ADDR: u8 = 8;
pub const I2C_INT_NACK: u8 = 16;
pub const I2C_INT_STOP: u8 = 32;
pub const I2C_INT_BERR: u16 = 256;
pub const I2C_INT_ARLO: u16 = 512;
pub const I2C_INT_OVR: u16 = 1024;
pub const I2C_INT_PECERR: u16 = 2048;
pub const I2C_INT_TIMEOUT: u16 = 4096;
pub const I2C_INT_ALERT: u16 = 8192;
pub const I2C_ISR_ERRORMASK: u16 = 7936;
pub const I2C_ICR_CLEARMASK: u16 = 16184;
pub const I2C_PECR_MASK: u8 = 255;
pub const I2C_RXDR_MASK: u8 = 255;
pub const I2C_TXDR_MASK: u8 = 255;
pub const LOG_PID: u8 = 1;
pub const LOG_CONS: u8 = 2;
pub const LOG_ODELAY: u8 = 4;
pub const LOG_NDELAY: u8 = 8;
pub const LOG_NOWAIT: u8 = 16;
pub const LOG_PERROR: u8 = 32;
pub const LOG_AUTH: u8 = 0;
pub const LOG_AUTHPRIV: u8 = 0;
pub const LOG_CRON: u8 = 0;
pub const LOG_DAEMON: u8 = 0;
pub const LOG_FTP: u8 = 0;
pub const LOG_KERN: u8 = 0;
pub const LOG_LOCAL0: u8 = 0;
pub const LOG_LOCAL1: u8 = 0;
pub const LOG_LOCAL2: u8 = 0;
pub const LOG_LOCAL3: u8 = 0;
pub const LOG_LOCAL4: u8 = 0;
pub const LOG_LOCAL5: u8 = 0;
pub const LOG_LOCAL6: u8 = 0;
pub const LOG_LOCAL7: u8 = 0;
pub const LOG_LPR: u8 = 0;
pub const LOG_MAIL: u8 = 0;
pub const LOG_NEWS: u8 = 0;
pub const LOG_SYSLOG: u8 = 0;
pub const LOG_USER: u8 = 0;
pub const LOG_UUCP: u8 = 0;
pub const LOG_EMERG: u8 = 0;
pub const LOG_ALERT: u8 = 1;
pub const LOG_CRIT: u8 = 2;
pub const LOG_ERR: u8 = 3;
pub const LOG_WARNING: u8 = 4;
pub const LOG_NOTICE: u8 = 5;
pub const LOG_INFO: u8 = 6;
pub const LOG_DEBUG: u8 = 7;
pub const LOG_ALL: u8 = 255;
pub const FILENAME_MAX: u8 = 32;
pub const FOPEN_MAX: u8 = 16;
pub const BUFSIZ: u8 = 64;
pub const _IOFBF: u8 = 0;
pub const _IOLBF: u8 = 1;
pub const _IONBF: u8 = 2;
pub const EOF: i8 = -1;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u8 = 32;
pub const TMP_MAX: u64 = 56800235584;
pub const __DBL_MANT_DIG__: u8 = 53;
pub const __SIZEOF_WINT_T__: u8 = 4;
pub const __LDBL_HAS_INFINITY__: u8 = 1;
pub const __LDBL_HAS_DENORM__: u8 = 1;
pub const __SHRT_MAX__: u16 = 32767;
pub const __clang_wide_literal_encoding__: &[u8; 7] = b"UTF-32\0";
pub const INT_MIN: i32 = -2147483648;
pub const __llvm__: u8 = 1;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u8 = 2;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINT_FAST8_MAX__: u8 = 255;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u8 = 2;
pub const __UINT_FAST16_MAX__: u16 = 65535;
pub const __INT_LEAST16_FMTi__: &[u8; 3] = b"hi\0";
pub const __CONSTANT_CFSTRINGS__: u8 = 1;
pub const __ATOMIC_RELAXED: u8 = 0;
pub const __SEG_GS: u8 = 1;
pub const SCHAR_MIN: i8 = -128;
pub const __BOOL_WIDTH__: u8 = 8;
pub const __OBJC_BOOL_IS_BOOL: u8 = 0;
pub const __UINT_FAST16_FMTu__: &[u8; 3] = b"hu\0";
pub const __linux__: u8 = 1;
pub const __UINT8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __INTMAX_FMTd__: &[u8; 3] = b"ld\0";
pub const __SIZEOF_PTRDIFF_T__: u8 = 8;
pub const __PTRDIFF_FMTi__: &[u8; 3] = b"li\0";
pub const __GNUC_MINOR__: u8 = 2;
pub const __POINTER_WIDTH__: u8 = 64;
pub const __SIZE_FMTX__: &[u8; 3] = b"lX\0";
pub const __DBL_HAS_DENORM__: u8 = 1;
pub const __GCC_HAVE_DWARF2_CFI_ASM: u8 = 1;
pub const __SIZEOF_LONG_LONG__: u8 = 8;
pub const __INT_LEAST16_FMTd__: &[u8; 3] = b"hd\0";
pub const __STDC_HOSTED__: u8 = 1;
pub const __clang_minor__: u8 = 0;
pub const __UINT32_FMTo__: &[u8; 2] = b"o\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __UINT16_FMTu__: &[u8; 3] = b"hu\0";
pub const __INT_LEAST32_FMTi__: &[u8; 2] = b"i\0";
pub const __code_model_small__: u8 = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u8 = 2;
pub const __LDBL_DIG__: u8 = 18;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u8 = 2;
pub const __SIZEOF_LONG_DOUBLE__: u8 = 16;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u8 = 2;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u8 = 1;
pub const __GXX_ABI_VERSION: u16 = 1002;
pub const __INT_FAST64_WIDTH__: u8 = 64;
pub const __UINT32_FMTx__: &[u8; 2] = b"x\0";
pub const __SSE2__: u8 = 1;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u8 = 2;
pub const __clang_major__: u8 = 14;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u8 = 2;
pub const __UINT16_FMTx__: &[u8; 3] = b"hx\0";
pub const __pic__: u8 = 2;
pub const __UINT_LEAST16_FMTX__: &[u8; 3] = b"hX\0";
pub const __NO_MATH_INLINES: u8 = 1;
pub const __clang_version__: &[u8; 8] = b"14.0.0 \0";
pub const __INTMAX_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT_FAST8_FMTo__: &[u8; 4] = b"hho\0";
pub const __SIG_ATOMIC_WIDTH__: u8 = 32;
pub const __UINT_LEAST16_FMTo__: &[u8; 3] = b"ho\0";
pub const __SIZEOF_FLOAT128__: u8 = 16;
pub const __INT32_FMTi__: &[u8; 2] = b"i\0";
pub const __UINT64_FMTo__: &[u8; 3] = b"lo\0";
pub const __GCC_ASM_FLAG_OUTPUTS__: u8 = 1;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u8 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u8 = 2;
pub const __INT_LEAST16_MAX__: u16 = 32767;
pub const __ATOMIC_RELEASE: u8 = 3;
pub const __PTRDIFF_WIDTH__: u8 = 64;
pub const __UINT64_MAX__: i8 = -1;
pub const __PTRDIFF_FMTd__: &[u8; 3] = b"ld\0";
pub const __UINTMAX_MAX__: i8 = -1;
pub const __INT_LEAST8_MAX__: u8 = 127;
pub const __DBL_MAX_10_EXP__: u16 = 308;
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __STDC_VERSION__: u32 = 201710;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST16_FMTd__: &[u8; 3] = b"hd\0";
pub const __SSE_MATH__: u8 = 1;
pub const __INT_FAST32_FMTi__: &[u8; 2] = b"i\0";
pub const __SIZEOF_POINTER__: u8 = 8;
pub const __UINT_LEAST8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __INT8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __UINT8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT_LEAST8_MAX__: u8 = 255;
pub const __SIZE_FMTu__: &[u8; 3] = b"lu\0";
pub const __SIZEOF_SIZE_T__: u8 = 8;
pub const __INT_FAST8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __UINT_LEAST8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __FLT_MANT_DIG__: u8 = 24;
pub const __UINT_LEAST8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINTMAX_FMTo__: &[u8; 3] = b"lo\0";
pub const __INT16_MAX__: u16 = 32767;
pub const __INT_LEAST64_FMTd__: &[u8; 3] = b"ld\0";
pub const __SIZEOF_INT__: u8 = 4;
pub const linux: u8 = 1;
pub const PTR_MIN: i32 = -2147483648;
pub const INTPTR_MIN: i32 = -2147483648;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u8 = 2;
pub const __SIZEOF_FLOAT__: u8 = 4;
pub const __ORDER_LITTLE_ENDIAN__: u16 = 1234;
pub const __BYTE_ORDER__: u16 = 1234;
pub const __VERSION__: &[u8; 20] = b"Ubuntu Clang 14.0.0\0";
pub const __FINITE_MATH_ONLY__: u8 = 0;
pub const __UINT32_MAX__: u32 = 4294967295;
pub const STM32_GPIOF_IDR: u32 = 1073878032;
pub const STM32_GPIOF_LCKR: u32 = 1073878044;
pub const STM32_GPIOF_ODR: u32 = 1073878036;
pub const __UINT_FAST32_FMTX__: &[u8; 2] = b"X\0";
pub const __UINT32_FMTX__: &[u8; 2] = b"X\0";
pub const __SIZEOF_INT128__: u8 = 16;
pub const __FLT_MAX_10_EXP__: u8 = 38;
pub const __linux: u8 = 1;
pub const __UINT_FAST8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __INT_FAST8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __UINT_FAST64_MAX__: i8 = -1;
pub const STM32_GPIOD_ODR: u32 = 1073875988;
pub const STM32_GPIOD_IDR: u32 = 1073875984;
pub const STM32_GPIOD_LCKR: u32 = 1073875996;
pub const __INT_LEAST16_WIDTH__: u8 = 16;
pub const STM32_GPIOC_LCKR: u32 = 1073874972;
pub const STM32_GPIOC_ODR: u32 = 1073874964;
pub const STM32_GPIOC_IDR: u32 = 1073874960;
pub const __LITTLE_ENDIAN__: u8 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u8 = 1;
pub const __LDBL_MIN_EXP__: i16 = -16381;
pub const __pie__: u8 = 2;
pub const __INT_LEAST8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const WCHAR_MAX: u32 = 2147483647;
pub const __UINT_FAST16_FMTx__: &[u8; 3] = b"hx\0";
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u8 = 0;
pub const __INT64_FMTi__: &[u8; 3] = b"li\0";
pub const __WINT_UNSIGNED__: u8 = 1;
pub const __amd64__: u8 = 1;
pub const __amd64: u8 = 1;
pub const __UINT_LEAST32_FMTu__: &[u8; 2] = b"u\0";
pub const __PIC__: u8 = 2;
pub const __UINT64_FMTu__: &[u8; 3] = b"lu\0";
pub const STM32_GPIOK_IDR: u32 = 1073883152;
pub const STM32_GPIOK_ODR: u32 = 1073883156;
pub const STM32_GPIOK_LCKR: u32 = 1073883164;
pub const __UINTMAX_FMTu__: &[u8; 3] = b"lu\0";
pub const __FLT_DECIMAL_DIG__: u8 = 9;
pub const __SHRT_WIDTH__: u8 = 16;
pub const __ATOMIC_ACQ_REL: u8 = 4;
pub const __UINT16_MAX__: u16 = 65535;
pub const __UINTPTR_MAX__: i8 = -1;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __k8: u8 = 1;
pub const __UINT_LEAST16_MAX__: u16 = 65535;
pub const __LDBL_HAS_QUIET_NAN__: u8 = 1;
pub const __UINT_FAST16_FMTo__: &[u8; 3] = b"ho\0";
pub const STM32_GPIOD_BSRR: u32 = 1073875992;
pub const STM32_GPIOK_BSRR: u32 = 1073883160;
pub const STM32_GPIOF_BSRR: u32 = 1073878040;
pub const STM32_GPIOC_BSRR: u32 = 1073874968;
pub const __GNUC__: u8 = 4;
pub const __SIZEOF_LONG__: u8 = 8;
pub const __INTPTR_WIDTH__: u8 = 64;
pub const __UINT_FAST8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __LP64__: u8 = 1;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i8 = -1;
pub const __INT_FAST32_FMTd__: &[u8; 2] = b"d\0";
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u8 = 1;
pub const __FLT_MAX_EXP__: u8 = 128;
pub const __unix__: u8 = 1;
pub const __UINT32_FMTu__: &[u8; 2] = b"u\0";
pub const __DBL_HAS_QUIET_NAN__: u8 = 1;
pub const __INTPTR_FMTi__: &[u8; 3] = b"li\0";
pub const __STDC__: u8 = 1;
pub const __UINT8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __INT8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __UINT_LEAST32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT_FAST64_FMTu__: &[u8; 3] = b"lu\0";
pub const __DBL_DECIMAL_DIG__: u8 = 17;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u8 = 2;
pub const __SEG_FS: u8 = 1;
pub const __BITINT_MAXWIDTH__: u8 = 128;
pub const __INT16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT_LEAST8_WIDTH__: u8 = 8;
pub const __UINT_LEAST64_FMTu__: &[u8; 3] = b"lu\0";
pub const __INT64_FMTd__: &[u8; 3] = b"ld\0";
pub const __FXSR__: u8 = 1;
pub const __UINT_LEAST64_MAX__: i8 = -1;
pub const __UINT_FAST8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINTMAX_FMTx__: &[u8; 3] = b"lx\0";
pub const __FLT_DIG__: u8 = 6;
pub const __UINT_FAST64_FMTX__: &[u8; 3] = b"lX\0";
pub const __PIE__: u8 = 2;
pub const __UINT8_MAX__: u8 = 255;
pub const __UINT_LEAST32_FMTX__: &[u8; 2] = b"X\0";
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u8 = 2;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __UINT_FAST64_FMTx__: &[u8; 3] = b"lx\0";
pub const STM32_GPIOF_OTYPER: u32 = 1073878020;
pub const STM32_GPIOC_OTYPER: u32 = 1073874948;
pub const STM32_GPIOK_OTYPER: u32 = 1073883140;
pub const STM32_GPIOD_OTYPER: u32 = 1073875972;
pub const __gnu_linux__: u8 = 1;
pub const __UINT64_FMTX__: &[u8; 3] = b"lX\0";
pub const __DBL_HAS_INFINITY__: u8 = 1;
pub const __UINT_FAST32_FMTu__: &[u8; 2] = b"u\0";
pub const __INTPTR_FMTd__: &[u8; 3] = b"ld\0";
pub const LONG_MIN: i32 = -2147483648;
pub const _POSIX_SSIZE_MIN: i32 = -2147483648;
pub const SSIZE_MIN: i32 = -2147483648;
pub const STM32_GPIOB_LCKR: u32 = 1073873948;
pub const STM32_GPIOB_OTYPER: u32 = 1073873924;
pub const STM32_GPIOB_BSRR: u32 = 1073873944;
pub const STM32_GPIOB_ODR: u32 = 1073873940;
pub const STM32_GPIOB_IDR: u32 = 1073873936;
pub const __INT_MAX__: u32 = 2147483647;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u8 = 2;
pub const __ATOMIC_SEQ_CST: u8 = 5;
pub const __UINT_LEAST64_FMTX__: &[u8; 3] = b"lX\0";
pub const __SIZEOF_WCHAR_T__: u8 = 4;
pub const __UINT_LEAST64_FMTo__: &[u8; 3] = b"lo\0";
pub const __SSE2_MATH__: u8 = 1;
pub const STM32_GPIOK_AFRH: u32 = 1073883172;
pub const STM32_GPIOB_AFRH: u32 = 1073873956;
pub const STM32_GPIOF_AFRH: u32 = 1073878052;
pub const STM32_GPIOD_AFRH: u32 = 1073876004;
pub const STM32_GPIOC_AFRH: u32 = 1073874980;
pub const __UINT16_FMTo__: &[u8; 3] = b"ho\0";
pub const __x86_64: u8 = 1;
pub const __INT_FAST64_FMTd__: &[u8; 3] = b"ld\0";
pub const __UINT_LEAST16_FMTx__: &[u8; 3] = b"hx\0";
pub const __DBL_MAX_EXP__: u16 = 1024;
pub const unix: u8 = 1;
pub const __STDC_UTF_16__: u8 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u8 = 2;
pub const __LDBL_DECIMAL_DIG__: u8 = 21;
pub const __DECIMAL_DIG__: u8 = 21;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u8 = 2;
pub const __INT16_FMTi__: &[u8; 3] = b"hi\0";
pub const STM32_GPIOF_MODER: u32 = 1073878016;
pub const STM32_GPIOC_MODER: u32 = 1073874944;
pub const STM32_GPIOB_MODER: u32 = 1073873920;
pub const STM32_GPIOK_MODER: u32 = 1073883136;
pub const STM32_GPIOD_MODER: u32 = 1073875968;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const __FLOAT128__: u8 = 1;
pub const __x86_64__: u8 = 1;
pub const __INT8_MAX__: u8 = 127;
pub const _LP64: u8 = 1;
pub const __INT_LEAST8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __FLT_RADIX__: u8 = 2;
pub const __SIZEOF_SHORT__: u8 = 2;
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __GNUC_STDC_INLINE__: u8 = 1;
pub const __FLT_HAS_INFINITY__: u8 = 1;
pub const __SIZE_FMTo__: &[u8; 3] = b"lo\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u8 = 4;
pub const STM32_GPIOF_OSPEED: u32 = 1073878024;
pub const STM32_GPIOK_OSPEED: u32 = 1073883144;
pub const STM32_GPIOD_OSPEED: u32 = 1073875976;
pub const STM32_GPIOC_OSPEED: u32 = 1073874952;
pub const STM32_GPIOB_OSPEED: u32 = 1073873928;
pub const __INTMAX_WIDTH__: u8 = 64;
pub const __UINT_LEAST16_FMTu__: &[u8; 3] = b"hu\0";
pub const STM32_GPIOG_LCKR: u32 = 1073879068;
pub const STM32_GPIOG_OTYPER: u32 = 1073879044;
pub const STM32_GPIOG_AFRH: u32 = 1073879076;
pub const STM32_GPIOG_OSPEED: u32 = 1073879048;
pub const STM32_GPIOG_ODR: u32 = 1073879060;
pub const STM32_GPIOG_MODER: u32 = 1073879040;
pub const STM32_GPIOG_IDR: u32 = 1073879056;
pub const STM32_GPIOG_BSRR: u32 = 1073879064;
pub const STM32_GPIOH_LCKR: u32 = 1073880092;
pub const STM32_GPIOH_AFRH: u32 = 1073880100;
pub const STM32_GPIOH_MODER: u32 = 1073880064;
pub const STM32_GPIOH_IDR: u32 = 1073880080;
pub const STM32_GPIOH_ODR: u32 = 1073880084;
pub const STM32_GPIOH_OTYPER: u32 = 1073880068;
pub const STM32_GPIOH_BSRR: u32 = 1073880088;
pub const STM32_GPIOH_OSPEED: u32 = 1073880072;
pub const __ORDER_BIG_ENDIAN__: u16 = 4321;
pub const __INT_LEAST32_WIDTH__: u8 = 32;
pub const __PRAGMA_REDEFINE_EXTNAME: u8 = 1;
pub const __MMX__: u8 = 1;
pub const __DBL_MIN_10_EXP__: i16 = -307;
pub const __clang_literal_encoding__: &[u8; 6] = b"UTF-8\0";
pub const __LDBL_MIN_10_EXP__: i16 = -4931;
pub const __UINTPTR_WIDTH__: u8 = 64;
pub const __SIZEOF_DOUBLE__: u8 = 8;
pub const __UINT8_FMTo__: &[u8; 4] = b"hho\0";
pub const STM32_GPIOE_IDR: u32 = 1073877008;
pub const STM32_GPIOE_BSRR: u32 = 1073877016;
pub const STM32_GPIOE_OSPEED: u32 = 1073877000;
pub const STM32_GPIOE_ODR: u32 = 1073877012;
pub const STM32_GPIOE_OTYPER: u32 = 1073876996;
pub const STM32_GPIOE_AFRH: u32 = 1073877028;
pub const STM32_GPIOE_MODER: u32 = 1073876992;
pub const STM32_GPIOE_LCKR: u32 = 1073877020;
pub const __ATOMIC_CONSUME: u8 = 1;
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __UINTPTR_FMTo__: &[u8; 3] = b"lo\0";
pub const __LDBL_MAX_10_EXP__: u16 = 4932;
pub const __clang_patchlevel__: u8 = 0;
pub const __clang__: u8 = 1;
pub const __INT_FAST16_WIDTH__: u8 = 16;
pub const __NO_INLINE__: u8 = 1;
pub const __SIZE_WIDTH__: u8 = 64;
pub const __FLT_MIN_EXP__: i8 = -125;
pub const __UINTPTR_FMTx__: &[u8; 3] = b"lx\0";
pub const __INT32_FMTd__: &[u8; 2] = b"d\0";
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u8 = 1;
pub const __UINT_LEAST8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u8 = 2;
pub const __UINT_LEAST32_FMTo__: &[u8; 2] = b"o\0";
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u8 = 2;
pub const __SCHAR_MAX__: u8 = 127;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __LDBL_MAX_EXP__: u16 = 16384;
pub const STM32_GPIOC_AFRL: u32 = 1073874976;
pub const STM32_GPIOF_AFRL: u32 = 1073878048;
pub const STM32_GPIOD_AFRL: u32 = 1073876000;
pub const STM32_GPIOH_AFRL: u32 = 1073880096;
pub const STM32_GPIOG_AFRL: u32 = 1073879072;
pub const STM32_GPIOK_AFRL: u32 = 1073883168;
pub const STM32_GPIOB_AFRL: u32 = 1073873952;
pub const STM32_GPIOE_AFRL: u32 = 1073877024;
pub const __WCHAR_WIDTH__: u8 = 32;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u8 = 1;
pub const STM32_GPIOB_PUPDR: u32 = 1073873932;
pub const STM32_GPIOH_PUPDR: u32 = 1073880076;
pub const STM32_GPIOK_PUPDR: u32 = 1073883148;
pub const STM32_GPIOF_PUPDR: u32 = 1073878028;
pub const STM32_GPIOG_PUPDR: u32 = 1073879052;
pub const STM32_GPIOD_PUPDR: u32 = 1073875980;
pub const STM32_GPIOC_PUPDR: u32 = 1073874956;
pub const STM32_GPIOE_PUPDR: u32 = 1073877004;
pub const STM32_GPIOA_BSRR: u32 = 1073872920;
pub const STM32_GPIOA_OTYPER: u32 = 1073872900;
pub const STM32_GPIOA_AFRL: u32 = 1073872928;
pub const STM32_GPIOA_OSPEED: u32 = 1073872904;
pub const STM32_GPIOA_MODER: u32 = 1073872896;
pub const STM32_GPIOA_ODR: u32 = 1073872916;
pub const STM32_GPIOA_PUPDR: u32 = 1073872908;
pub const STM32_GPIOA_LCKR: u32 = 1073872924;
pub const STM32_GPIOA_IDR: u32 = 1073872912;
pub const STM32_GPIOA_AFRH: u32 = 1073872932;
pub const __INT_FAST16_FMTi__: &[u8; 3] = b"hi\0";
pub const __INT_FAST32_WIDTH__: u8 = 32;
pub const __INT_LEAST64_FMTi__: &[u8; 3] = b"li\0";
pub const __INT_FAST8_MAX__: u8 = 127;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u8 = 1;
pub const __LLONG_WIDTH__: u8 = 64;
pub const __ATOMIC_ACQUIRE: u8 = 2;
pub const __SSE__: u8 = 1;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u8 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u8 = 2;
pub const __tune_k8__: u8 = 1;
pub const __FLT_HAS_DENORM__: u8 = 1;
pub const __UINT64_FMTx__: &[u8; 3] = b"lx\0";
pub const __ORDER_PDP_ENDIAN__: u16 = 3412;
pub const __WINT_WIDTH__: u8 = 32;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u8 = 2;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __unix: u8 = 1;
pub const SHRT_MIN: i16 = -32768;
pub const __UINT_LEAST64_FMTx__: &[u8; 3] = b"lx\0";
pub const __CHAR_BIT__: u8 = 8;
pub const __LONG_WIDTH__: u8 = 64;
pub const __UINT_FAST32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT16_FMTX__: &[u8; 3] = b"hX\0";
pub const __UINTPTR_FMTX__: &[u8; 3] = b"lX\0";
pub const __INT_FAST64_FMTi__: &[u8; 3] = b"li\0";
pub const __ELF__: u8 = 1;
pub const __UINT_FAST16_FMTX__: &[u8; 3] = b"hX\0";
pub const __STDC_UTF_32__: u8 = 1;
pub const __INT_LEAST64_WIDTH__: u8 = 64;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u8 = 2;
pub const __UINTMAX_WIDTH__: u8 = 64;
pub const __UINTMAX_FMTX__: &[u8; 3] = b"lX\0";
pub const __UINTPTR_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __BIGGEST_ALIGNMENT__: u8 = 16;
pub const __FLT_HAS_QUIET_NAN__: u8 = 1;
pub const __GNUC_PATCHLEVEL__: u8 = 1;
pub const __FLT_EVAL_METHOD__: u8 = 0;
pub const __LDBL_MANT_DIG__: u8 = 64;
pub const SS_REPL_MAX: u8 = 3;
pub const STM32_GPIOI_LCKR: u32 = 1073881116;
pub const STM32_GPIOI_OTYPER: u32 = 1073881092;
pub const STM32_GPIOI_AFRH: u32 = 1073881124;
pub const STM32_GPIOI_AFRL: u32 = 1073881120;
pub const STM32_GPIOI_MODER: u32 = 1073881088;
pub const STM32_GPIOI_OSPEED: u32 = 1073881096;
pub const STM32_GPIOI_PUPDR: u32 = 1073881100;
pub const STM32_GPIOI_BSRR: u32 = 1073881112;
pub const STM32_GPIOI_IDR: u32 = 1073881104;
pub const STM32_GPIOI_ODR: u32 = 1073881108;
pub const STM32_GPIOJ_IDR: u32 = 1073882128;
pub const STM32_GPIOJ_PUPDR: u32 = 1073882124;
pub const STM32_GPIOJ_OTYPER: u32 = 1073882116;
pub const STM32_GPIOJ_OSPEED: u32 = 1073882120;
pub const STM32_GPIOJ_ODR: u32 = 1073882132;
pub const STM32_GPIOJ_AFRH: u32 = 1073882148;
pub const STM32_GPIOJ_MODER: u32 = 1073882112;
pub const STM32_GPIOJ_BSRR: u32 = 1073882136;
pub const STM32_GPIOJ_LCKR: u32 = 1073882140;
pub const STM32_GPIOJ_AFRL: u32 = 1073882144;
pub const __INT_LEAST32_FMTd__: &[u8; 2] = b"d\0";
pub const __k8__: u8 = 1;
pub const __UINT_FAST64_FMTo__: &[u8; 3] = b"lo\0";
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u8 = 3;
pub const __INT_FAST8_WIDTH__: u8 = 8;
pub const NZERO: u8 = 100;
pub const __UINT_FAST32_FMTo__: &[u8; 2] = b"o\0";
pub const __FLT_MIN_10_EXP__: i8 = -37;
pub const __SIZE_FMTx__: &[u8; 3] = b"lx\0";
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __INT_WIDTH__: u8 = 32;
pub const __INT_FAST16_MAX__: u16 = 32767;
pub const __DBL_MIN_EXP__: i16 = -1021;
pub const __DBL_DIG__: u8 = 15;
pub type _int8_t = cty::c_schar;
pub type _uint8_t = cty::c_uchar;
pub type _int16_t = cty::c_short;
pub type _uint16_t = cty::c_ushort;
pub type _int32_t = cty::c_int;
pub type _uint32_t = cty::c_uint;
pub type _int64_t = cty::c_longlong;
pub type _uint64_t = cty::c_ulonglong;
pub type _intmax_t = _int64_t;
pub type _uintmax_t = _uint64_t;
pub type _wchar_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type _size_t = cty::c_uint;
pub type irqstate_t = cty::c_ushort;
pub type int_least8_t = _int8_t;
pub type uint_least8_t = _uint8_t;
pub type int_least16_t = _int16_t;
pub type uint_least16_t = _uint16_t;
pub type int_least24_t = _int32_t;
pub type uint_least24_t = _uint32_t;
pub type int_least32_t = _int32_t;
pub type uint_least32_t = _uint32_t;
pub type int_least64_t = _int64_t;
pub type uint_least64_t = _uint64_t;
pub type int_fast8_t = _int8_t;
pub type uint_fast8_t = _uint8_t;
pub type int_fast16_t = cty::c_int;
pub type uint_fast16_t = cty::c_uint;
pub type int_fast24_t = _int32_t;
pub type uint_fast24_t = _uint32_t;
pub type int_fast32_t = _int32_t;
pub type uint_fast32_t = _uint32_t;
pub type int_fast64_t = _int64_t;
pub type uint_fast64_t = _uint64_t;
pub type intmax_t = _intmax_t;
pub type uintmax_t = _uintmax_t;
pub type mode_t = cty::c_uint;
pub type rsize_t = _size_t;
pub type uid_t = cty::c_uint;
pub type gid_t = cty::c_uint;
pub type dev_t = u32;
pub type ino_t = u16;
pub type nlink_t = u16;
pub type pid_t = cty::c_int;
pub type id_t = cty::c_int;
pub type key_t = i32;
pub type wchar_t = _wchar_t;
pub type wint_t = cty::c_int;
pub type wctype_t = cty::c_int;
pub type fsblkcnt_t = u32;
pub type fsfilcnt_t = u32;
pub type blkcnt_t = u32;
pub type off_t = i32;
pub type fpos_t = i32;
pub type blksize_t = i16;
pub type socklen_t = cty::c_uint;
pub type sa_family_t = u16;
pub type clock_t = u32;
pub type time_t = u32;
pub type clockid_t = cty::c_int;
pub type timer_t = *mut cty::c_void;
pub type useconds_t = u32;
pub type suseconds_t = i32;
pub type cpu_set_t = u8;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type unchar = cty::c_uchar;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type s_char = cty::c_schar;
pub type caddr_t = *mut cty::c_char;
pub type u_int8_t = u8;
pub type u_int16_t = u16;
pub type u_int32_t = u32;
pub type u_int64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsid_s {
    pub val: [cty::c_int; 2usize],
}
pub type main_t = ::core::option::Option<
    unsafe extern "C" fn(argc: cty::c_int, argv: *mut *mut cty::c_char) -> cty::c_int,
>;
pub const ERROR: _bindgen_ty_1 = -1;
pub const OK: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = cty::c_int;
extern "C" {
    pub fn nsh_main(argc: cty::c_int, argv: *mut *mut cty::c_char) -> cty::c_int;
}
pub type irq_t = u8;
pub type xcpt_t = ::core::option::Option<
    unsafe extern "C" fn(
        irq: cty::c_int,
        context: *mut cty::c_void,
        arg: *mut cty::c_void,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " Name: irq_attach\n\n Description:\n   Configure the IRQ subsystem so that IRQ number 'irq' is dispatched to\n   'isr' with argument 'arg'\n"]
    pub fn irq_attach(irq: cty::c_int, isr: xcpt_t, arg: *mut cty::c_void) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcptcontext {
    pub sigdeliver: *mut cty::c_void,
    pub saved_regs: *mut u32,
    pub regs: *mut u32,
}
extern "C" {
    #[doc = " Public Data"]
    pub static mut g_current_regs: [*mut u32; 1usize];
}
extern "C" {
    pub fn _assert(
        filename: *const cty::c_char,
        linenum: cty::c_int,
        msg: *const cty::c_char,
        regs: *mut cty::c_void,
    );
}
extern "C" {
    pub fn __assert(
        filename: *const cty::c_char,
        linenum: cty::c_int,
        msg: *const cty::c_char,
    ) -> !;
}
extern "C" {
    pub fn __errno() -> *mut cty::c_int;
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
    pub tm_gmtoff: cty::c_long,
    pub tm_zone: *const cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn clock_settime(clockid: clockid_t, tp: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_gettime(clockid: clockid_t, tp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getres(clockid: clockid_t, res: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(pid: pid_t, clockid: *mut clockid_t) -> cty::c_int;
}
extern "C" {
    pub fn timespec_get(t: *mut timespec, b: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn timegm(tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn mktime(tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn gmtime(timep: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(timep: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime(timep: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(timep: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        s: *mut cty::c_char,
        max: usize,
        format: *const cty::c_char,
        tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        s: *const cty::c_char,
        format: *const cty::c_char,
        tm: *mut tm,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asctime(tp: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn asctime_r(tp: *const tm, buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(timep: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime_r(timep: *const time_t, buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn time(timep: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(time1: time_t, time0: time_t) -> f64;
}
extern "C" {
    pub fn timer_create(
        clockid: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: cty::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> cty::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        clockid: clockid_t,
        flags: cty::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sq_entry_s {
    pub flink: *mut sq_entry_s,
}
#[doc = " Public Type Definitions"]
pub type sq_entry_t = sq_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dq_entry_s {
    pub flink: *mut dq_entry_s,
    pub blink: *mut dq_entry_s,
}
pub type dq_entry_t = dq_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sq_queue_s {
    pub head: *mut sq_entry_t,
    pub tail: *mut sq_entry_t,
}
pub type sq_queue_t = sq_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dq_queue_s {
    pub head: *mut dq_entry_t,
    pub tail: *mut dq_entry_t,
}
pub type dq_queue_t = dq_queue_s;
extern "C" {
    pub fn sq_addafter(prev: *mut sq_entry_t, node: *mut sq_entry_t, queue: *mut sq_queue_t);
}
extern "C" {
    pub fn dq_addafter(prev: *mut dq_entry_t, node: *mut dq_entry_t, queue: *mut dq_queue_t);
}
extern "C" {
    pub fn sq_remafter(node: *mut sq_entry_t, queue: *mut sq_queue_t) -> *mut sq_entry_t;
}
extern "C" {
    pub fn dq_remafter(node: *mut dq_entry_t, queue: *mut dq_queue_t) -> *mut dq_entry_t;
}
extern "C" {
    pub fn sq_remlast(queue: *mut sq_queue_t) -> *mut sq_entry_t;
}
extern "C" {
    pub fn dq_remlast(queue: *mut dq_queue_t) -> *mut dq_entry_t;
}
extern "C" {
    pub fn sq_remfirst(queue: *mut sq_queue_t) -> *mut sq_entry_t;
}
extern "C" {
    pub fn dq_remfirst(queue: *mut dq_queue_t) -> *mut dq_entry_t;
}
extern "C" {
    pub fn sq_count(queue: *mut sq_queue_t) -> usize;
}
extern "C" {
    pub fn dq_count(queue: *mut dq_queue_t) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_s {
    pub semcount: i16,
    pub flags: u8,
    pub waitlist: dq_queue_t,
}
pub type sem_t = sem_s;
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn sem_init(sem: *mut sem_t, pshared: cty::c_int, value: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn sem_destroy(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_wait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_timedwait(sem: *mut sem_t, abstime: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn sem_clockwait(
        sem: *mut sem_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sem_trywait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_post(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: sem_setprotocol\n\n Description:\n    Set semaphore protocol attribute.\n\n    One particularly important use of this function is when a semaphore\n    is used for inter-task communication like:\n\n      TASK A                 TASK B\n      sem_init(sem, 0, 0);\n      sem_wait(sem);\n                             sem_post(sem);\n      Awakens as holder\n\n    In this case priority inheritance can interfere with the operation of\n    the semaphore.  The problem is that when TASK A is restarted it is a\n    holder of the semaphore.  However, it never calls sem_post(sem) so it\n    becomes *permanently* a holder of the semaphore and may have its\n    priority boosted when any other task tries to acquire the semaphore.\n\n    The fix is to call sem_setprotocol(SEM_PRIO_NONE) immediately after\n    the sem_init() call so that there will be no priority inheritance\n    operations on this semaphore.\n\n Input Parameters:\n    sem      - A pointer to the semaphore whose attributes are to be\n               modified\n    protocol - The new protocol to use\n\n Returned Value:\n   This function is exposed as a non-standard application interface.  It\n   returns zero (OK) if successful.  Otherwise, -1 (ERROR) is returned and\n   the errno value is set appropriately.\n"]
    pub fn sem_setprotocol(sem: *mut sem_t, protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: sem_getprotocol\n\n Description:\n    Return the value of the semaphore protocol attribute.\n\n Input Parameters:\n    sem      - A pointer to the semaphore whose attributes are to be\n               queried.\n    protocol - The user provided location in which to store the protocol\n               value.\n\n Returned Value:\n   This function is exposed as a non-standard application interface.  It\n   returns zero (OK) if successful.  Otherwise, -1 (ERROR) is returned and\n   the errno value is set appropriately.\n"]
    pub fn sem_getprotocol(sem: *mut sem_t, protocol: *mut cty::c_int) -> cty::c_int;
}
pub type sclock_t = i32;
extern "C" {
    pub static mut g_system_ticks: clock_t;
}
extern "C" {
    #[doc = " Name: clock_timespec_compare\n\n Description:\n    Return < 0 if time ts1 is before time ts2\n    Return > 0 if time ts2 is before time ts1\n    Return 0 if time ts1 is the same as time ts2\n"]
    pub fn clock_timespec_compare(ts1: *const timespec, ts2: *const timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_timespec_add\n\n Description:\n   Add timespec ts1 to to2 and return the result in ts3\n\n Input Parameters:\n   ts1 and ts2: The two timespecs to be added\n   t23: The location to return the result (may be ts1 or ts2)\n\n Returned Value:\n   None\n"]
    pub fn clock_timespec_add(ts1: *const timespec, ts2: *const timespec, ts3: *mut timespec);
}
extern "C" {
    #[doc = " Name:  clock_timespec_subtract\n\n Description:\n   Subtract timespec ts2 from to1 and return the result in ts3.\n   Zero is returned if the time difference is negative.\n\n Input Parameters:\n   ts1 and ts2: The two timespecs to be subtracted (ts1 - ts2)\n   t23: The location to return the result (may be ts1 or ts2)\n\n Returned Value:\n   None\n"]
    pub fn clock_timespec_subtract(ts1: *const timespec, ts2: *const timespec, ts3: *mut timespec);
}
extern "C" {
    #[doc = " Name:  clock_isleapyear\n\n Description:\n    Return true if the specified year is a leap year\n"]
    pub fn clock_isleapyear(year: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_daysbeforemonth\n\n Description:\n    Get the number of days that occurred before the beginning of the month.\n"]
    pub fn clock_daysbeforemonth(month: cty::c_int, leapyear: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_dayoftheweek\n\n Description:\n    Get the day of the week\n\n Input Parameters:\n   mday  - The day of the month 1 - 31\n   month - The month of the year 1 - 12\n   year  - the year including the 1900\n\n Returned Value:\n   Zero based day of the week 0-6, 0 = Sunday, 1 = Monday... 6 = Saturday\n"]
    pub fn clock_dayoftheweek(mday: cty::c_int, month: cty::c_int, year: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_calendar2utc\n\n Description:\n    Calendar/UTC conversion based on algorithms from p. 604\n    of Seidelman, P. K. 1992.  Explanatory Supplement to\n    the Astronomical Almanac.  University Science Books,\n    Mill Valley.\n"]
    pub fn clock_calendar2utc(year: cty::c_int, month: cty::c_int, day: cty::c_int) -> time_t;
}
extern "C" {
    #[doc = " Name: clock_time2ticks\n\n Description:\n   Return the given struct timespec as systime ticks.\n\n   NOTE:  This is an internal OS interface and should not be called from\n   application code.\n\n Input Parameters:\n   reltime - Pointer to the time presented as struct timespec\n\n Output Parameters:\n   ticks - Pointer to receive the time value presented as systime ticks\n\n Returned Value:\n   Always returns OK (0)\n"]
    pub fn clock_time2ticks(reltime: *const timespec, ticks: *mut sclock_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: clock_ticks2time\n\n Description:\n   Return the given systime ticks as a struct timespec.\n\n   NOTE:  This is an internal OS interface and should not be called from\n   application code.\n\n Input Parameters:\n   ticks - Time presented as systime ticks\n\n Output Parameters:\n   reltime - Pointer to receive the time value presented as struct timespec\n\n Returned Value:\n   Always returns OK (0)\n"]
    pub fn clock_ticks2time(ticks: sclock_t, reltime: *mut timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: clock_systime_timespec\n\n Description:\n   Return the current value of the system timer counter as a struct\n   timespec.\n\n Input Parameters:\n   ts - Location to return the time\n\n Returned Value:\n   OK (0) on success; a negated errno value on failure.\n\n Assumptions:\n"]
    pub fn clock_systime_timespec(ts: *mut timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " perf_gettime"]
    pub fn perf_gettime() -> clock_t;
}
extern "C" {
    #[doc = " perf_convert"]
    pub fn perf_convert(elapsed: clock_t, ts: *mut timespec);
}
extern "C" {
    #[doc = " perf_gettfreq"]
    pub fn perf_getfreq() -> cty::c_ulong;
}
extern "C" {
    #[doc = " Name: nxsem_init\n\n Description:\n   This function initializes the UNNAMED semaphore sem. Following a\n   successful call to nxsem_init(), the semaphore may be used in subsequent\n   calls to nxsem_wait(), nxsem_post(), and nxsem_trywait().  The semaphore\n   remains usable until it is destroyed.\n\n   Only sem itself may be used for performing synchronization. The result\n   of referring to copies of sem in calls to sem_wait(), sem_trywait(),\n   sem_post(), and sem_destroy() is undefined.\n\n Input Parameters:\n   sem - Semaphore to be initialized\n   pshared - Process sharing (not used)\n   value - Semaphore initialization value\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_init(sem: *mut sem_t, pshared: cty::c_int, value: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_destroy\n\n Description:\n   This function is used to destroy the un-named semaphore indicated by\n   'sem'.  Only a semaphore that was created using nxsem_init() may be\n   destroyed using nxsem_destroy(); the effect of calling nxsem_destroy()\n   with a named semaphore is undefined.  The effect of subsequent use of\n   the semaphore sem is undefined until sem is re-initialized by another\n   call to nxsem_init().\n\n   The effect of destroying a semaphore upon which other processes are\n   currently blocked is undefined.\n\n Input Parameters:\n   sem - Semaphore to be destroyed.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_destroy(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_wait\n\n Description:\n   This function attempts to lock the semaphore referenced by 'sem'.  If\n   the semaphore value is (<=) zero, then the calling task will not return\n   until it successfully acquires the lock.\n\n   This is an internal OS interface.  It is functionally equivalent to\n   sem_wait except that:\n\n   - It is not a cancellation point, and\n   - It does not modify the errno value.\n\n Input Parameters:\n   sem - Semaphore descriptor.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     EINVAL - Invalid attempt to get the semaphore\n     EINTR  - The wait was interrupted by the receipt of a signal.\n"]
    pub fn nxsem_wait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_trywait\n\n Description:\n   This function locks the specified semaphore only if the semaphore is\n   currently not locked.  Otherwise, it locks the semaphore.  In either\n   case, the call returns without blocking.\n\n Input Parameters:\n   sem - the semaphore descriptor\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     EINVAL - Invalid attempt to get the semaphore\n     EAGAIN - The semaphore is not available.\n\n Assumptions:\n"]
    pub fn nxsem_trywait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_timedwait\n\n Description:\n   This function will lock the semaphore referenced by sem as in the\n   sem_wait() function. However, if the semaphore cannot be locked without\n   waiting for another process or thread to unlock the semaphore by\n   performing a sem_post() function, this wait will be terminated when the\n   specified timeout expires.\n\n   The timeout will expire when the absolute time specified by abstime\n   passes, as measured by the clock on which timeouts are based (that is,\n   when the value of that clock equals or exceeds abstime), or if the\n   absolute time specified by abstime has already been passed at the\n   time of the call.\n\n   This is an internal OS interface.  It is functionally equivalent to\n   sem_wait except that:\n\n   - It is not a cancellation point, and\n   - It does not modify the errno value.\n\n Input Parameters:\n   sem     - Semaphore object\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   That may be one of:\n\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   EINTR     A signal interrupted this function.\n   ECANCELED May be returned if the thread is canceled while waiting.\n"]
    pub fn nxsem_timedwait(sem: *mut sem_t, abstime: *const timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_clockwait\n\n Description:\n   This function will lock the semaphore referenced by sem as in the\n   sem_wait() function. However, if the semaphore cannot be locked without\n   waiting for another process or thread to unlock the semaphore by\n   performing a sem_post() function, this wait will be terminated when the\n   specified timeout expires.\n\n   The timeout will expire when the absolute time specified by abstime\n   passes, as measured by the clock on which timeouts are based (that is,\n   when the value of that clock equals or exceeds abstime), or if the\n   absolute time specified by abstime has already been passed at the\n   time of the call.\n\n   This is an internal OS interface.  It is functionally equivalent to\n   sem_wait except that:\n\n   - It is not a cancellation point, and\n   - It does not modify the errno value.\n\n Input Parameters:\n   sem     - Semaphore object\n   clockid - The timing source to use in the conversion\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   That may be one of:\n\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   EINTR     A signal interrupted this function.\n   ECANCELED May be returned if the thread is canceled while waiting.\n"]
    pub fn nxsem_clockwait(
        sem: *mut sem_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_tickwait\n\n Description:\n   This function is a lighter weight version of sem_timedwait().  It is\n   non-standard and intended only for use within the RTOS.\n\n Input Parameters:\n   sem     - Semaphore object\n   delay   - Ticks to wait from the start time until the semaphore is\n             posted.  If ticks is zero, then this function is equivalent\n             to sem_trywait().\n\n Returned Value:\n   This is an internal OS interface, not available to applications, and\n   hence follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure:\n\n     -ETIMEDOUT is returned on the timeout condition.\n     -ECANCELED may be returned if the thread is canceled while waiting.\n"]
    pub fn nxsem_tickwait(sem: *mut sem_t, delay: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_post\n\n Description:\n   When a kernel thread has finished with a semaphore, it will call\n   nxsem_post().  This function unlocks the semaphore referenced by sem\n   by performing the semaphore unlock operation on that semaphore.\n\n   If the semaphore value resulting from this operation is positive, then\n   no tasks were blocked waiting for the semaphore to become unlocked; the\n   semaphore is simply incremented.\n\n   If the value of the semaphore resulting from this operation is zero,\n   then one of the tasks blocked waiting for the semaphore shall be\n   allowed to return successfully from its call to sem_wait().\n\n Input Parameters:\n   sem - Semaphore descriptor\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n\n Assumptions:\n   This function may be called from an interrupt handler.\n"]
    pub fn nxsem_post(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  nxsem_get_value\n\n Description:\n   This function updates the location referenced by 'sval' argument to\n   have the value of the semaphore referenced by 'sem' without effecting\n   the state of the semaphore.  The updated value represents the actual\n   semaphore value that occurred at some unspecified time during the call,\n   but may not reflect the actual value of the semaphore when it is\n   returned to the calling task.\n\n   If 'sem' is locked, the value return by nxsem_get_value() will either be\n   zero or a negative number whose absolute value represents the number\n   of tasks waiting for the semaphore.\n\n Input Parameters:\n   sem - Semaphore descriptor\n   sval - Buffer by which the value is returned\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_get_value(sem: *mut sem_t, sval: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_open\n\n Description:\n   This function establishes a connection between named semaphores and a\n   task.  Following a call to sem_open() with the semaphore name, the task\n   may reference the semaphore associated with name using the address\n   returned by this call.  The semaphore may be used in subsequent calls\n   to sem_wait(), sem_trywait(), and sem_post().  The semaphore remains\n   usable until the semaphore is closed by a successful call to\n   sem_close().\n\n   If a task makes multiple calls to sem_open() with the same name, then\n   the same semaphore address is returned (provided there have been no\n   calls to sem_unlink()).\n\n Input Parameters:\n   name  - Semaphore name\n   oflags - Semaphore creation options.  This may either or both of the\n     following bit settings.\n     oflags = 0:  Connect to the semaphore only if it already exists.\n     oflags = O_CREAT:  Connect to the semaphore if it exists, otherwise\n        create the semaphore.\n     oflags = O_CREAT|O_EXCL:  Create a new semaphore\n        unless one of this name already exists.\n   Optional parameters.  When the O_CREAT flag is specified, two optional\n     parameters are expected:\n     1. mode_t mode, and\n     2. unsigned int value.  This initial value of the semaphore. Valid\n        initial values of the semaphore must be less than or equal to\n        SEM_VALUE_MAX.\n\n Returned Value:\n   A pointer to sem_t or negated errno if unsuccessful.\n\n Assumptions:\n"]
    pub fn nxsem_open(name: *const cty::c_char, oflags: cty::c_int, ...) -> *mut sem_t;
}
extern "C" {
    #[doc = " Name:  nxsem_close\n\n Description:\n   This function is called to indicate that the calling task is finished\n   with the specified named semaphore, 'sem'.  The sem_close() deallocates\n   any system resources allocated by the system for this named semaphore.\n\n   If the semaphore has not been removed with a call to sem_unlink(), then\n   sem_close() has no effect on the named semaphore.  However, when the\n   named semaphore has been fully unlinked, the semaphore will vanish when\n   the last task closes it.\n\n Input Parameters:\n  sem - semaphore descriptor\n\n Returned Value:\n  0 (OK), or negated errno if unsuccessful.\n\n Assumptions:\n   - Care must be taken to avoid risking the deletion of a semaphore that\n     another calling task has already locked.\n   - sem_close must not be called for an un-named semaphore\n"]
    pub fn nxsem_close(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_unlink\n\n Description:\n   This function removes the semaphore named by the input parameter 'name.'\n   If the semaphore named by 'name' is currently referenced by other task,\n   the sem_unlink() will have no effect on the state of the semaphore.  If\n   one or more processes have the semaphore open when sem_unlink() is\n   called, destruction of the semaphore will be postponed until all\n   references to the semaphore have been destroyed by calls of sem_close().\n\n Input Parameters:\n   name - Semaphore name\n\n Returned Value:\n  0 (OK), or negated errno if unsuccessful.\n\n Assumptions:\n"]
    pub fn nxsem_unlink(name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_reset\n\n Description:\n   Reset a semaphore count to a specific value.  This is similar to part\n   of the operation of nxsem_init().  But nxsem_reset() may need to wake up\n   tasks waiting on a count.  This kind of operation is sometimes required\n   within the OS (only) for certain error handling conditions.\n\n Input Parameters:\n   sem   - Semaphore descriptor to be reset\n   count - The requested semaphore count\n\n Returned Value:\n   This is an internal OS interface, not available to applications, and\n   hence follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_reset(sem: *mut sem_t, count: i16) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_set_protocol\n\n Description:\n    Set semaphore protocol attribute.\n\n    One particularly important use of this function is when a semaphore\n    is used for inter-task communication like:\n\n      TASK A                 TASK B\n      sem_init(sem, 0, 0);\n      sem_wait(sem);\n                             sem_post(sem);\n      Awakens as holder\n\n    In this case priority inheritance can interfere with the operation of\n    the semaphore.  The problem is that when TASK A is restarted it is a\n    holder of the semaphore.  However, it never calls sem_post(sem) so it\n    becomes *permanently* a holder of the semaphore and may have its\n    priority boosted when any other task tries to acquire the semaphore.\n\n    The fix is to call nxsem_set_protocol(SEM_PRIO_NONE) immediately after\n    the sem_init() call so that there will be no priority inheritance\n    operations on this semaphore.\n\n Input Parameters:\n    sem      - A pointer to the semaphore whose attributes are to be\n               modified\n    protocol - The new protocol to use\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_set_protocol(sem: *mut sem_t, protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_wait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_wait(), which is\n   uninterruptible and convenient for use.\n\n Parameters:\n   sem - Semaphore descriptor.\n\n Return Value:\n   Zero(OK)  - On success\n   EINVAL    - Invalid attempt to get the semaphore\n   ECANCELED - May be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_wait_uninterruptible(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_timedwait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_timedwait(), which is\n   uninterruptible and convenient for use.\n\n Input Parameters:\n   sem     - Semaphore object\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   ECANCELED May be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_timedwait_uninterruptible(sem: *mut sem_t, abstime: *const timespec)
        -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_clockwait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_clockwait(), which is\n   uninterruptible and convenient for use.\n\n Input Parameters:\n   sem     - Semaphore object\n   clockid - The timing source to use in the conversion\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   ECANCELED May be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_clockwait_uninterruptible(
        sem: *mut sem_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_tickwait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_tickwait(), which is\n   uninterruptible and convenient for use.\n\n Input Parameters:\n   sem     - Semaphore object\n   delay   - Ticks to wait from the start time until the semaphore is\n             posted.  If ticks is zero, then this function is equivalent\n             to sem_trywait().\n\n Returned Value:\n   This is an internal OS interface, not available to applications, and\n   hence follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure:\n\n     -ETIMEDOUT is returned on the timeout condition.\n     -ECANCELED may be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_tickwait_uninterruptible(sem: *mut sem_t, delay: u32) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex_s {
    pub sem: sem_t,
    pub holder: pid_t,
}
#[doc = " Public Type Definitions"]
pub type mutex_t = mutex_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmutex_s {
    pub mutex: mutex_t,
    pub count: cty::c_uint,
}
pub type rmutex_t = rmutex_s;
extern "C" {
    #[doc = " Name: nxmutex_init\n\n Description:\n   This function initializes the UNNAMED mutex. Following a\n   successful call to nxmutex_init(), the mutex may be used in subsequent\n   calls to nxmutex_lock(), nxmutex_unlock(), and nxmutex_trylock().  The\n   mutex remains usable until it is destroyed.\n\n Parameters:\n   mutex - Semaphore to be initialized\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxmutex_init(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_destroy\n\n Description:\n   This function initializes the UNNAMED mutex. Following a\n   successful call to nxmutex_init(), the mutex may be used in subsequent\n   calls to nxmutex_lock(), nxmutex_unlock(), and nxmutex_trylock().  The\n   mutex remains usable until it is destroyed.\n\n Parameters:\n   mutex - Semaphore to be destroyed\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxmutex_destroy(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_is_hold\n\n Description:\n   This function check whether the caller hold the mutex\n   referenced by 'mutex'.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n"]
    pub fn nxmutex_is_hold(mutex: *mut mutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nxmutex_is_locked\n\n Description:\n   This function get the lock state the mutex referenced by 'mutex'.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n"]
    pub fn nxmutex_is_locked(mutex: *mut mutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nxmutex_lock\n\n Description:\n   This function attempts to lock the mutex referenced by 'mutex'.  The\n   mutex is implemented with a semaphore, so if the semaphore value is\n   (<=) zero, then the calling task will not return until it successfully\n   acquires the lock.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxmutex_lock(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_trylock\n\n Description:\n   This function locks the mutex only if the mutex is currently not locked.\n   If the mutex has been locked already, the call returns without blocking.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     -EINVAL - Invalid attempt to lock the mutex\n     -EAGAIN - The mutex is not available.\n"]
    pub fn nxmutex_trylock(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_timedlock\n\n Description:\n   This function attempts to lock the mutex .  If the mutex value\n   is (<=) zero,then the calling task will not return until it\n   successfully acquires the lock or timed out\n\n Input Parameters:\n   mutex   - Mutex object\n   timeout - The time when mutex lock timed out\n\n Returned Value:\n   OK        The mutex successfully acquires\n   EINVAL    The mutex argument does not refer to a valid mutex.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The mutex could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n"]
    pub fn nxmutex_timedlock(mutex: *mut mutex_t, timeout: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_unlock\n\n Description:\n   This function attempts to unlock the mutex referenced by 'mutex'.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n Assumptions:\n   This function may be called from an interrupt handler.\n"]
    pub fn nxmutex_unlock(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn nxmutex_reset(mutex: *mut mutex_t);
}
extern "C" {
    #[doc = " Name: nxmutex_breaklock\n\n Description:\n   This function attempts to break the mutex\n\n Parameters:\n   mutex   - Mutex descriptor.\n   locked  - Is the mutex break success\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxmutex_breaklock(mutex: *mut mutex_t, locked: *mut bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_restorelock\n\n Description:\n   This function attempts to restore the mutex.\n\n Parameters:\n   mutex   - mutex descriptor.\n   locked  - true: it's mean that the mutex is broke success\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure\n"]
    pub fn nxmutex_restorelock(mutex: *mut mutex_t, locked: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_init\n\n Description:\n   This function initializes the UNNAMED recursive mutex. Following a\n   successful call to nxrmutex_init(), the recursive mutex may be used in\n   subsequent calls to nxrmutex_lock(), nxrmutex_unlock(),\n   and nxrmutex_trylock(). The recursive mutex remains usable\n   until it is destroyed.\n\n Parameters:\n   rmutex - Recursive mutex to be initialized\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxrmutex_init(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_destroy\n\n Description:\n   This function destroy the UNNAMED recursive mutex.\n\n Parameters:\n   rmutex - Recursive mutex to be destroyed\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxrmutex_destroy(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_is_hold\n\n Description:\n   This function check whether the caller hold the recursive mutex\n   referenced by 'rmutex'.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n"]
    pub fn nxrmutex_is_hold(rmutex: *mut rmutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nxrmutex_is_locked\n\n Description:\n   This function get the lock state the recursive mutex\n   referenced by 'rmutex'.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n"]
    pub fn nxrmutex_is_locked(rmutex: *mut rmutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nrxmutex_lock\n\n Description:\n   This function attempts to lock the recursive mutex referenced by\n   'rmutex'.The recursive mutex can be locked multiple times in the same\n   thread.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxrmutex_lock(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_trylock\n\n Description:\n   This function locks the recursive mutex if the recursive mutex is\n   currently not locked or the same thread call.\n   If the recursive mutex is locked and other thread call it,\n   the call returns without blocking.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     -EINVAL - Invalid attempt to lock the recursive mutex\n     -EAGAIN - The recursive mutex is not available.\n"]
    pub fn nxrmutex_trylock(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_timedlock\n\n Description:\n   This function attempts to lock the mutex .  If the mutex value\n   is (<=) zero,then the calling task will not return until it\n   successfully acquires the lock or timed out\n\n Input Parameters:\n   rmutex  - Rmutex object\n   timeout - The time when mutex lock timed out\n\n Returned Value:\n   OK        The mutex successfully acquires\n   EINVAL    The mutex argument does not refer to a valid mutex.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The mutex could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   ECANCELED May be returned if the thread is canceled while waiting.\n"]
    pub fn nxrmutex_timedlock(rmutex: *mut rmutex_t, timeout: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_unlock\n\n Description:\n   This function attempts to unlock the recursive mutex\n   referenced by 'rmutex'.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n Assumptions:\n   This function may be called from an interrupt handler.\n"]
    pub fn nxrmutex_unlock(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    pub fn nxrmutex_reset(rmutex: *mut rmutex_t);
}
extern "C" {
    #[doc = " Name: nrxmutex_breaklock\n\n Description:\n   This function attempts to break the recursive mutex\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxrmutex_breaklock(rmutex: *mut rmutex_t, count: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_restorelock\n\n Description:\n   This function attempts to restore the recursive mutex.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxrmutex_restorelock(rmutex: *mut rmutex_t, count: cty::c_uint) -> cty::c_int;
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_devaddr_s {
    pub next: u8,
    pub lock: mutex_t,
    pub alloctab: [u32; 4usize],
}
extern "C" {
    #[doc = " Name: usbhost_devaddr_initialize\n\n Description:\n   Initialize the caller provided struct usbhost_devaddr_s instance in\n   preparation for the management of device addresses on behalf of an root\n   hub port.\n\n Input Parameters:\n   devgen - A reference to a usbhost_devaddr_s structure.\n\n Returned Value:\n   On success, zero (OK) is returned. On a failure, a negated errno value\n   is returned indicating the nature of the failure.\n"]
    pub fn usbhost_devaddr_initialize(devgen: *mut usbhost_devaddr_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_devaddr_create\n\n Description:\n   Create a new unique device address for this hub port.\n\n Input Parameters:\n   hport - A reference to a hub port structure to which a device has been\n     newly connected and so is in need of a function address.\n\n Returned Value:\n   On success, a new device function address in the range 0x01 to 0x7f\n   is returned.  On failure, a negated errno value is returned.\n"]
    pub fn usbhost_devaddr_create(hport: *mut usbhost_hubport_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_devaddr_destroy\n\n Description:\n  Release a device address previously assigned by usbhost_devaddr_create().\n\n Input Parameters:\n  hport - A reference to a hub port structure from which a device has been\n     disconnected and so no longer needs the function address.\n  devaddr - The address to be released.\n\n Returned Value:\n   None\n"]
    pub fn usbhost_devaddr_destroy(hport: *mut usbhost_hubport_s, devaddr: u8);
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_id_s {
    pub base: u8,
    pub subclass: u8,
    pub proto: u8,
    pub vid: u16,
    pub pid: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_registry_s {
    pub flink: *mut usbhost_registry_s,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            hub: *mut usbhost_hubport_s,
            id: *const usbhost_id_s,
        ) -> *mut usbhost_class_s,
    >,
    pub nids: u8,
    pub id: *const usbhost_id_s,
}
pub type usbhost_ep_t = *mut cty::c_void;
#[doc = " Public Functions Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_hubport_s {
    pub drvr: *mut usbhost_driver_s,
    pub devclass: *mut usbhost_class_s,
    pub ep0: usbhost_ep_t,
    pub connected: bool,
    pub port: u8,
    pub funcaddr: u8,
    pub speed: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_roothubport_s {
    pub hport: usbhost_hubport_s,
    pub pdevgen: *mut usbhost_devaddr_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_class_s {
    pub hport: *mut usbhost_hubport_s,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            devclass: *mut usbhost_class_s,
            configdesc: *const u8,
            desclen: cty::c_int,
        ) -> cty::c_int,
    >,
    pub disconnected:
        ::core::option::Option<unsafe extern "C" fn(devclass: *mut usbhost_class_s) -> cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_epdesc_s {
    pub hport: *mut usbhost_hubport_s,
    pub addr: u8,
    pub in_: bool,
    pub xfrtype: u8,
    pub interval: u8,
    pub mxpacketsize: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_connection_s {
    pub wait: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut usbhost_connection_s,
            hport: *mut *mut usbhost_hubport_s,
        ) -> cty::c_int,
    >,
    pub enumerate: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut usbhost_connection_s,
            hport: *mut usbhost_hubport_s,
        ) -> cty::c_int,
    >,
}
pub type usbhost_asynch_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void, result: isize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_driver_s {
    pub ep0configure: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep0: usbhost_ep_t,
            funcaddr: u8,
            speed: u8,
            maxpacketsize: u16,
        ) -> cty::c_int,
    >,
    pub epalloc: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            epdesc: *const usbhost_epdesc_s,
            ep: *mut usbhost_ep_t,
        ) -> cty::c_int,
    >,
    pub epfree: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, ep: usbhost_ep_t) -> cty::c_int,
    >,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            buffer: *mut *mut u8,
            maxlen: *mut usize,
        ) -> cty::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, buffer: *mut u8) -> cty::c_int,
    >,
    pub ioalloc: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            buffer: *mut *mut u8,
            buflen: usize,
        ) -> cty::c_int,
    >,
    pub iofree: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, buffer: *mut u8) -> cty::c_int,
    >,
    pub ctrlin: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep0: usbhost_ep_t,
            req: *mut usb_ctrlreq_s,
            buffer: *mut u8,
        ) -> cty::c_int,
    >,
    pub ctrlout: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep0: usbhost_ep_t,
            req: *const usb_ctrlreq_s,
            buffer: *const u8,
        ) -> cty::c_int,
    >,
    pub transfer: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep: usbhost_ep_t,
            buffer: *mut u8,
            buflen: usize,
        ) -> isize,
    >,
    pub cancel: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, ep: usbhost_ep_t) -> cty::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, hport: *mut usbhost_hubport_s),
    >,
}
extern "C" {
    #[doc = " Name: usbhost_registerclass\n\n Description:\n   Register a USB host class implementation.  The caller provides an\n   instance of struct usbhost_registry_s that contains all of the\n   information that will be needed later to (1) associate the USB host\n   class implementation with a connected USB device, and (2) to obtain and\n   bind a struct usbhost_class_s instance for the device.\n\n Input Parameters:\n   devclass - An write-able instance of struct usbhost_registry_s that will\n     be maintained in a registry.\n\n Returned Value:\n   On success, this function will return zero (OK).  Otherwise, a negated\n   errno value is returned.\n"]
    pub fn usbhost_registerclass(devclass: *mut usbhost_registry_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_findclass\n\n Description:\n   Find a USB host class implementation previously registered by\n   usbhost_registerclass().  On success, an instance of struct\n   usbhost_registry_s will be returned.  That instance will contain all of\n   the information that will be needed to obtain and bind a struct\n   usbhost_class_s instance for the device.\n\n Input Parameters:\n   id - Identifies the USB device class that has connect to the USB host.\n\n Returned Value:\n   On success this function will return a non-NULL instance of struct\n   usbhost_registry_s.  NULL will be returned on failure.  This function\n   can only fail if (1) id is NULL, or (2) no USB host class is registered\n   that matches the device class ID.\n"]
    pub fn usbhost_findclass(id: *const usbhost_id_s) -> *const usbhost_registry_s;
}
extern "C" {
    #[doc = " Name: usbhost_wlaninit\n\n Description:\n   Initialize the USB WLAN class driver.  This function should be called\n   by platform-specific code in order to initialize and register support\n   for the USB host class device.\n\n Input Parameters:\n   None\n\n Returned Value:\n   On success this function will return zero (OK);  A negated errno value\n   will be returned on failure.\n"]
    pub fn usbhost_wlaninit() -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_enumerate\n\n Description:\n   This is a share-able implementation of most of the logic required by the\n   driver enumerate() method.  This logic within this method should be\n   common to all USB host drivers.\n\n   Enumerate the connected device.  As part of this enumeration process,\n   the driver will (1) get the device's configuration descriptor, (2)\n   extract the class ID info from the configuration descriptor, (3) call\n   usbhost_findclass() to find the class that supports this device, (4)\n   call the create() method on the struct usbhost_registry_s interface\n   to get a class instance, and finally (5) call the configdesc() method\n   of the struct usbhost_class_s interface.  After that, the class is in\n   charge of the sequence of operations.\n\n Input Parameters:\n   hub - The hub that manages the new class.\n   devclass - If the class driver for the device is successful located\n      and bound to the hub, the allocated class instance is returned into\n      this caller-provided memory location.\n\n Returned Value:\n   On success, zero (OK) is returned. On a failure, a negated errno value\n   is returned indicating the nature of the failure\n\n Assumptions:\n   - Only a single class bound to a single device is supported.\n   - Called from a single thread so no mutual exclusion is required.\n   - Never called from an interrupt handler.\n"]
    pub fn usbhost_enumerate(
        hub: *mut usbhost_hubport_s,
        devclass: *mut *mut usbhost_class_s,
    ) -> cty::c_int;
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_s {
    pub _elem: [u32; 2usize],
}
#[doc = " Public Types"]
pub type sigset_t = sigset_s;
pub type sig_atomic_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: cty::c_int,
    pub sival_ptr: *mut cty::c_void,
}
pub type sigev_notify_function_t = ::core::option::Option<unsafe extern "C" fn(value: sigval)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: u8,
    pub sigev_signo: u8,
    pub sigev_value: sigval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub si_signo: u8,
    pub si_code: u8,
    pub si_errno: u8,
    pub si_value: sigval,
    pub si_user: *mut cty::c_void,
}
pub type siginfo_t = siginfo;
pub type _sa_handler_t = ::core::option::Option<unsafe extern "C" fn(signo: cty::c_int)>;
pub type _sa_sigaction_t = ::core::option::Option<
    unsafe extern "C" fn(signo: cty::c_int, siginfo: *mut siginfo_t, context: *mut cty::c_void),
>;
pub type sighandler_t = _sa_handler_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_u: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_flags: cty::c_int,
    pub sa_user: *mut cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub _sa_handler: _sa_handler_t,
    pub _sa_sigaction: _sa_sigaction_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut cty::c_void,
    pub ss_flags: cty::c_int,
    pub ss_size: usize,
}
extern "C" {
    pub fn kill(pid: pid_t, signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn killpg(pgrp: pid_t, signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn tgkill(pid: pid_t, tid: pid_t, signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn psignal(signum: cty::c_int, message: *const cty::c_char);
}
extern "C" {
    pub fn psiginfo(pinfo: *const siginfo_t, message: *const cty::c_char);
}
extern "C" {
    pub fn raise(signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigaction(signo: cty::c_int, act: *const sigaction, oact: *mut sigaction) -> cty::c_int;
}
extern "C" {
    pub fn sigaddset(set: *mut sigset_t, signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigandset(
        dest: *mut sigset_t,
        left: *const sigset_t,
        right: *const sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigdelset(set: *mut sigset_t, signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigemptyset(set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigfillset(set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sighold(signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigisemptyset(set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigismember(set: *const sigset_t, signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigignore(signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn signal(signo: cty::c_int, func: _sa_handler_t) -> _sa_handler_t;
}
extern "C" {
    pub fn sigorset(
        dest: *mut sigset_t,
        left: *const sigset_t,
        right: *const sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigpause(signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigpending(set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigprocmask(how: cty::c_int, set: *const sigset_t, oset: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigqueue(pid: cty::c_int, signo: cty::c_int, value: sigval) -> cty::c_int;
}
extern "C" {
    pub fn sigrelse(signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigset(signo: cty::c_int, func: _sa_handler_t) -> _sa_handler_t;
}
extern "C" {
    pub fn sigwait(set: *const sigset_t, sig: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        set: *const sigset_t,
        value: *mut siginfo,
        timeout: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigsuspend(sigmask: *const sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigwaitinfo(set: *const sigset_t, value: *mut siginfo) -> cty::c_int;
}
extern "C" {
    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> cty::c_int;
}
extern "C" {
    pub fn siginterrupt(signo: cty::c_int, flag: cty::c_int) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
pub type nfds_t = cty::c_uint;
pub type pollevent_t = u32;
pub type pollcb_t = ::core::option::Option<unsafe extern "C" fn(fds: *mut pollfd)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: cty::c_int,
    pub events: pollevent_t,
    pub revents: pollevent_t,
    pub arg: *mut cty::c_void,
    pub cb: pollcb_t,
    pub priv_: *mut cty::c_void,
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ppoll(
        fds: *mut pollfd,
        nfds: nfds_t,
        timeout_ts: *const timespec,
        sigmask: *const sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn poll_fdsetup(fd: cty::c_int, fds: *mut pollfd, setup: bool) -> cty::c_int;
}
extern "C" {
    pub fn poll_default_cb(fds: *mut pollfd);
}
extern "C" {
    pub fn poll_notify(afds: *mut *mut pollfd, nfds: cty::c_int, eventset: pollevent_t);
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_type: u8,
    pub d_name: [cty::c_char; 33usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIR {
    pub fd: cty::c_int,
    pub entry: dirent,
}
extern "C" {
    pub fn closedir(dirp: *mut DIR) -> cty::c_int;
}
extern "C" {
    pub fn opendir(path: *const cty::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(fd: cty::c_int) -> *mut DIR;
}
extern "C" {
    pub fn readdir(dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(dirp: *mut DIR, entry: *mut dirent, result: *mut *mut dirent) -> cty::c_int;
}
extern "C" {
    pub fn rewinddir(dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(dirp: *mut DIR, loc: off_t);
}
extern "C" {
    pub fn telldir(dirp: *mut DIR) -> off_t;
}
extern "C" {
    pub fn scandir(
        path: *const cty::c_char,
        namelist: *mut *mut *mut dirent,
        filter: ::core::option::Option<unsafe extern "C" fn(arg1: *const dirent) -> cty::c_int>,
        compar: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut *const dirent, arg2: *mut *const dirent) -> cty::c_int,
        >,
    ) -> cty::c_int;
}
extern "C" {
    pub fn alphasort(a: *mut *const dirent, b: *mut *const dirent) -> cty::c_int;
}
extern "C" {
    pub fn versionsort(a: *mut *const dirent, b: *mut *const dirent) -> cty::c_int;
}
extern "C" {
    pub fn dirfd(dirp: *mut DIR) -> cty::c_int;
}
pub type spinlock_t = u8;
extern "C" {
    pub fn up_testset(lock: *mut spinlock_t) -> spinlock_t;
}
extern "C" {
    #[doc = " Name: spin_lock\n\n Description:\n   If this CPU does not already hold the spinlock, then loop until the\n   spinlock is successfully locked.\n\n   This implementation is non-reentrant and is prone to deadlocks in\n   the case that any logic on the same CPU attempts to take the lock\n   more than once.\n\n Input Parameters:\n   lock - A reference to the spinlock object to lock.\n\n Returned Value:\n   None.  When the function returns, the spinlock was successfully locked\n   by this CPU.\n\n Assumptions:\n   Not running at the interrupt level.\n"]
    pub fn spin_lock(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " Name: spin_lock_wo_note\n\n Description:\n   If this CPU does not already hold the spinlock, then loop until the\n   spinlock is successfully locked.\n\n   This implementation is the same as the above spin_lock() except that\n   it does not perform instrumentation logic.\n\n Input Parameters:\n   lock - A reference to the spinlock object to lock.\n\n Returned Value:\n   None.  When the function returns, the spinlock was successfully locked\n   by this CPU.\n\n Assumptions:\n   Not running at the interrupt level.\n"]
    pub fn spin_lock_wo_note(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " Name: spin_trylock\n\n Description:\n   Try once to lock the spinlock.  Do not wait if the spinlock is already\n   locked.\n\n Input Parameters:\n   lock - A reference to the spinlock object to lock.\n\n Returned Value:\n   SP_LOCKED   - Failure, the spinlock was already locked\n   SP_UNLOCKED - Success, the spinlock was successfully locked\n\n Assumptions:\n   Not running at the interrupt level.\n"]
    pub fn spin_trylock(lock: *mut spinlock_t) -> bool;
}
extern "C" {
    #[doc = " Name: spin_trylock_wo_note\n\n Description:\n   Try once to lock the spinlock.  Do not wait if the spinlock is already\n   locked.\n\n   This implementation is the same as the above spin_trylock() except that\n   it does not perform instrumentation logic.\n\n Input Parameters:\n   lock - A reference to the spinlock object to lock.\n\n Returned Value:\n   SP_LOCKED   - Failure, the spinlock was already locked\n   SP_UNLOCKED - Success, the spinlock was successfully locked\n\n Assumptions:\n   Not running at the interrupt level.\n"]
    pub fn spin_trylock_wo_note(lock: *mut spinlock_t) -> bool;
}
extern "C" {
    #[doc = " Name: spin_unlock_wo_note\n\n Description:\n   Release one count on a non-reentrant spinlock.\n\n   This implementation is the same as the above spin_unlock() except that\n   it does not perform instrumentation logic.\n\n Input Parameters:\n   lock - A reference to the spinlock object to unlock.\n\n Returned Value:\n   None.\n\n Assumptions:\n   Not running at the interrupt level.\n"]
    pub fn spin_unlock_wo_note(lock: *mut spinlock_t);
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_map_entry_s {
    pub flink: *mut mm_map_entry,
    pub vaddr: *mut cty::c_void,
    pub length: usize,
    pub offset: off_t,
    pub prot: cty::c_int,
    pub flags: cty::c_int,
    pub priv_: mm_map_entry_s__bindgen_ty_1,
    pub munmap: ::core::option::Option<
        unsafe extern "C" fn(
            group: *mut task_group_s,
            entry: *mut mm_map_entry_s,
            start: *mut cty::c_void,
            length: usize,
        ) -> cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mm_map_entry_s__bindgen_ty_1 {
    pub p: *mut cty::c_void,
    pub i: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_map_s {
    pub mm_map_sq: sq_queue_t,
    pub map_count: usize,
    pub mm_map_mutex: rmutex_t,
}
extern "C" {
    #[doc = " Name: mm_map_lock\n\n Description:\n   Get exclusive access current task_group's mm_map\n\n Input Parameters:\n   None\n\n Returned Value:\n   OK on success\n   A negated errno value on failure\n"]
    pub fn mm_map_lock() -> cty::c_int;
}
extern "C" {
    #[doc = " Name: mm_map_unlock\n\n Description:\n   Relinquish exclusive access to current task_group's mm_map\n\n Input Parameters:\n   None\n\n Returned Value:\n   None\n"]
    pub fn mm_map_unlock();
}
extern "C" {
    #[doc = " Name: mm_map_initialize\n\n Description:\n   Initialization function, called only by group_initialize\n\n Input Parameters:\n   mm     - Pointer to the mm_map structure to be initialized\n   kernel - Indicates whether we are initializing a kernel task\n\n Returned Value:\n   None\n"]
    pub fn mm_map_initialize(mm: *mut mm_map_s, kernel: bool);
}
extern "C" {
    #[doc = " Name: mm_map_destroy\n\n Description:\n   Uninitialization function, called only by group_release\n\n Input Parameters:\n   mm - Pointer to the mm_map structure to be initialized\n\n Returned Value:\n   None\n"]
    pub fn mm_map_destroy(mm: *mut mm_map_s);
}
extern "C" {
    #[doc = " Name: mm_map_add\n\n Description:\n   Adds a virtual memory area into the list of mappings\n\n Input Parameters:\n   mm    - A pointer to mm_map_s, which describes the virtual memory area\n   entry - A pointer to mm_map_entry_s, mapping info to be added\n\n Returned Value:\n   OK        Added successfully\n   -EINVAL:  Invalid attempt to get the semaphore\n   -EINTR:   The wait was interrupted by the receipt of a signal.\n   -ENOMEM:  Out of memory\n"]
    pub fn mm_map_add(mm: *mut mm_map_s, entry: *mut mm_map_entry_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: mm_map_next\n\n Description:\n   Returns the next mapping in the list, following the argument.\n   Can be used to iterate through all the mappings. Returns the first\n   mapping when the argument \"entry\" is NULL.\n\n Input Parameters:\n   mm    - A pointer to mm_map_s, which describes the virtual memory area\n   entry - Pointer to a single mapping in this task group or NULL to get\n           the first one\n\n Returned Value:\n   Pointer to the next mapping\n"]
    pub fn mm_map_next(mm: *mut mm_map_s, entry: *const mm_map_entry_s) -> *mut mm_map_entry_s;
}
extern "C" {
    #[doc = " Name: mm_map_find\n\n Description:\n   Find the first mapping matching address and length\n\n Input Parameters:\n   mm     - A pointer to mm_map_s, which describes the virtual memory area\n   vaddr  - Start address of the mapped area\n   length - Length of the mapping\n\n Returned Value:\n   Pointer to the mapping, NULL if not found\n"]
    pub fn mm_map_find(
        mm: *mut mm_map_s,
        vaddr: *const cty::c_void,
        length: usize,
    ) -> *mut mm_map_entry_s;
}
extern "C" {
    #[doc = " Name: mm_map_remove\n\n Description:\n   Removes a virtual memory area from the list of mappings\n   Sets the given pointer argument to NULL after successful removal\n\n Input Parameters:\n   mm      - Pointer to the list of entries, from which the entry is\n             removed. If passed mm is NULL, the function doesn't do\n             anything, but just returns OK.\n\n   entry   - Pointer to the entry to be removed. If the passed entry is\n             NULL the function doesn't do anything but just returns OK\n\n Returned Value:\n   OK:       Removed successfully\n   -EINVAL:  Invalid attempt to get the semaphore\n   -EINTR:   The wait was interrupted by the receipt of a signal.\n   -ENOENT:  Memory area not found\n"]
    pub fn mm_map_remove(mm: *mut mm_map_s, entry: *mut mm_map_entry_s) -> cty::c_int;
}
#[doc = " Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub max_align_i: cty::c_longlong,
    pub max_align_f: f64,
}
extern "C" {
    pub fn strdup(s: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(s: *const cty::c_char, size: cty::c_uint) -> *mut cty::c_char;
}
extern "C" {
    pub fn strerror(arg1: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strerror_r(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: usize) -> cty::c_int;
}
extern "C" {
    pub fn strlen(arg1: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const cty::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strcat(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strncat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const cty::c_char, s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(dest: *mut cty::c_char, src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpcpy(dest: *mut cty::c_char, src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcpy(dst: *mut cty::c_char, src: *const cty::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(s: *const cty::c_char, c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchrnul(s: *const cty::c_char, c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(s: *const cty::c_char, c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strcspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strstr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcasestr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(signum: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(arg1: *mut cty::c_char, arg2: *const cty::c_char, n: cty::c_uint)
        -> cty::c_uint;
}
extern "C" {
    pub fn strverscmp(s1: *const cty::c_char, s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn memchr(s: *const cty::c_void, c: cty::c_int, n: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn memrchr(s: *const cty::c_void, c: cty::c_int, n: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn rawmemchr(s: *const cty::c_void, c: cty::c_int) -> *mut cty::c_void;
}
extern "C" {
    pub fn memccpy(
        s1: *mut cty::c_void,
        s2: *const cty::c_void,
        c: cty::c_int,
        n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(s1: *const cty::c_void, s2: *const cty::c_void, n: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn mempcpy(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        count: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(s: *mut cty::c_void, c: cty::c_int, n: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmem(
        haystack: *const cty::c_void,
        haystacklen: usize,
        needle: *const cty::c_void,
        needlelen: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn explicit_bzero(s: *mut cty::c_void, n: usize);
}
extern "C" {
    pub fn timingsafe_bcmp(b1: *const cty::c_void, b2: *const cty::c_void, n: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn ffs(j: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(j: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(j: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn fls(j: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn flsl(j: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn flsll(j: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn popcount(j: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn popcountl(j: cty::c_ulong) -> cty::c_uint;
}
extern "C" {
    pub fn popcountll(j: cty::c_ulonglong) -> cty::c_uint;
}
extern "C" {
    pub fn index(s: *const cty::c_char, c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(s: *const cty::c_char, c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
extern "C" {
    pub fn task_create(
        name: *const cty::c_char,
        priority: cty::c_int,
        stack_size: cty::c_int,
        entry: main_t,
        argv: *const *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn task_create_with_stack(
        name: *const cty::c_char,
        priority: cty::c_int,
        stack_addr: *mut cty::c_void,
        stack_size: cty::c_int,
        entry: main_t,
        argv: *const *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn task_delete(pid: pid_t) -> cty::c_int;
}
extern "C" {
    pub fn task_restart(pid: pid_t) -> cty::c_int;
}
extern "C" {
    pub fn task_setcancelstate(state: cty::c_int, oldstate: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn task_setcanceltype(type_: cty::c_int, oldtype: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn task_testcancel();
}
extern "C" {
    pub fn sched_setparam(pid: pid_t, param: *const sched_param) -> cty::c_int;
}
extern "C" {
    pub fn sched_getparam(pid: pid_t, param: *mut sched_param) -> cty::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        pid: pid_t,
        policy: cty::c_int,
        param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sched_getscheduler(pid: pid_t) -> cty::c_int;
}
extern "C" {
    pub fn sched_yield() -> cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(policy: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(policy: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(pid: pid_t, interval: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn sched_lock() -> cty::c_int;
}
extern "C" {
    pub fn sched_unlock() -> cty::c_int;
}
extern "C" {
    pub fn sched_lockcount() -> cty::c_int;
}
extern "C" {
    pub fn sched_idletask() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_spawnattr_s {
    pub flags: u8,
    pub priority: u8,
    pub policy: u8,
    pub sigmask: sigset_t,
    pub stacksize: usize,
    pub stackaddr: *mut cty::c_void,
}
pub type posix_spawnattr_t = posix_spawnattr_s;
pub type posix_spawn_file_actions_t = *mut cty::c_void;
extern "C" {
    pub fn posix_spawn(
        pid: *mut pid_t,
        path: *const cty::c_char,
        file_actions: *const posix_spawn_file_actions_t,
        attr: *const posix_spawnattr_t,
        argv: *const *mut cty::c_char,
        envp: *const *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn task_spawn(
        name: *const cty::c_char,
        entry: main_t,
        file_actions: *const posix_spawn_file_actions_t,
        attr: *const posix_spawnattr_t,
        argv: *const *mut cty::c_char,
        envp: *const *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_init(
        file_actions: *mut posix_spawn_file_actions_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_destroy(
        file_actions: *mut posix_spawn_file_actions_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_addclose(
        file_actions: *mut posix_spawn_file_actions_t,
        fd: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_adddup2(
        file_actions: *mut posix_spawn_file_actions_t,
        fd1: cty::c_int,
        fd2: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_addopen(
        file_actions: *mut posix_spawn_file_actions_t,
        fd: cty::c_int,
        path: *const cty::c_char,
        oflags: cty::c_int,
        mode: mode_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_init(attr: *mut posix_spawnattr_t) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_destroy(attr: *mut posix_spawnattr_t) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getflags(
        attr: *const posix_spawnattr_t,
        flags: *mut cty::c_short,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getschedparam(
        attr: *const posix_spawnattr_t,
        param: *mut sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getschedpolicy(
        attr: *const posix_spawnattr_t,
        policy: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getsigmask(
        attr: *const posix_spawnattr_t,
        sigmask: *mut sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setflags(
        attr: *mut posix_spawnattr_t,
        flags: cty::c_short,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setschedparam(
        attr: *mut posix_spawnattr_t,
        param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setschedpolicy(
        attr: *mut posix_spawnattr_t,
        policy: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setsigmask(
        attr: *mut posix_spawnattr_t,
        sigmask: *const sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getstacksize(
        attr: *const posix_spawnattr_t,
        stacksize: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setstacksize(
        attr: *mut posix_spawnattr_t,
        stacksize: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getstackaddr(
        attr: *const posix_spawnattr_t,
        stackaddr: *mut *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setstackaddr(
        attr: *mut posix_spawnattr_t,
        stackaddr: *mut cty::c_void,
    ) -> cty::c_int;
}
pub const spawn_file_actions_e_SPAWN_FILE_ACTION_NONE: spawn_file_actions_e = 0;
pub const spawn_file_actions_e_SPAWN_FILE_ACTION_CLOSE: spawn_file_actions_e = 1;
pub const spawn_file_actions_e_SPAWN_FILE_ACTION_DUP2: spawn_file_actions_e = 2;
pub const spawn_file_actions_e_SPAWN_FILE_ACTION_OPEN: spawn_file_actions_e = 3;
#[doc = " Type Definitions"]
pub type spawn_file_actions_e = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spawn_general_file_action_s {
    pub flink: *mut spawn_general_file_action_s,
    pub action: spawn_file_actions_e,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spawn_close_file_action_s {
    pub flink: *mut spawn_general_file_action_s,
    pub action: spawn_file_actions_e,
    pub fd: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spawn_dup2_file_action_s {
    pub flink: *mut spawn_general_file_action_s,
    pub action: spawn_file_actions_e,
    pub fd1: cty::c_int,
    pub fd2: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spawn_open_file_action_s {
    pub flink: *mut spawn_general_file_action_s,
    pub action: spawn_file_actions_e,
    pub fd: cty::c_int,
    pub oflags: cty::c_int,
    pub mode: mode_t,
    pub path: [cty::c_char; 1usize],
}
extern "C" {
    pub fn add_file_action(
        file_action: *mut posix_spawn_file_actions_t,
        entry: *mut spawn_general_file_action_s,
    );
}
extern "C" {
    pub fn spawn_file_actions(
        tcb: *mut tcb_s,
        actions: *const posix_spawn_file_actions_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn spawn_file_is_duplicateable(
        actions: *const posix_spawn_file_actions_t,
        fd: cty::c_int,
        cloexec: bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtd_dev_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_dirent_s {
    pub fd_root: *mut inode,
    pub fd_path: *mut cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub open: ::core::option::Option<unsafe extern "C" fn(filep: *mut file) -> cty::c_int>,
    pub close: ::core::option::Option<unsafe extern "C" fn(filep: *mut file) -> cty::c_int>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, buffer: *mut cty::c_char, buflen: usize) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, buffer: *const cty::c_char, buflen: usize) -> isize,
    >,
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, offset: off_t, whence: cty::c_int) -> off_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, cmd: cty::c_int, arg: cty::c_ulong) -> cty::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, map: *mut mm_map_entry_s) -> cty::c_int,
    >,
    pub truncate:
        ::core::option::Option<unsafe extern "C" fn(filep: *mut file, length: off_t) -> cty::c_int>,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, fds: *mut pollfd, setup: bool) -> cty::c_int,
    >,
    pub unlink: ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry {
    pub geo_available: bool,
    pub geo_mediachanged: bool,
    pub geo_writeenabled: bool,
    pub geo_nsectors: blkcnt_t,
    pub geo_sectorsize: blksize_t,
    pub geo_model: [cty::c_char; 33usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct partition_info_s {
    pub numsectors: usize,
    pub sectorsize: usize,
    pub startsector: off_t,
    pub parent: [cty::c_char; 33usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_operations {
    pub open: ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> cty::c_int>,
    pub close: ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> cty::c_int>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut inode,
            buffer: *mut cty::c_uchar,
            start_sector: blkcnt_t,
            nsectors: cty::c_uint,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut inode,
            buffer: *const cty::c_uchar,
            start_sector: blkcnt_t,
            nsectors: cty::c_uint,
        ) -> isize,
    >,
    pub geometry: ::core::option::Option<
        unsafe extern "C" fn(inode: *mut inode, geometry: *mut geometry) -> cty::c_int,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(inode: *mut inode, cmd: cty::c_int, arg: cty::c_ulong) -> cty::c_int,
    >,
    pub unlink: ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mountpt_operations {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            filep: *mut file,
            relpath: *const cty::c_char,
            oflags: cty::c_int,
            mode: mode_t,
        ) -> cty::c_int,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(filep: *mut file) -> cty::c_int>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, buffer: *mut cty::c_char, buflen: usize) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, buffer: *const cty::c_char, buflen: usize) -> isize,
    >,
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, offset: off_t, whence: cty::c_int) -> off_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, cmd: cty::c_int, arg: cty::c_ulong) -> cty::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, map: *mut mm_map_entry_s) -> cty::c_int,
    >,
    pub truncate:
        ::core::option::Option<unsafe extern "C" fn(filep: *mut file, length: off_t) -> cty::c_int>,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(filep: *mut file, fds: *mut pollfd, setup: bool) -> cty::c_int,
    >,
    pub sync: ::core::option::Option<unsafe extern "C" fn(filep: *mut file) -> cty::c_int>,
    pub dup: ::core::option::Option<
        unsafe extern "C" fn(oldp: *const file, newp: *mut file) -> cty::c_int,
    >,
    pub fstat: ::core::option::Option<
        unsafe extern "C" fn(filep: *const file, buf: *mut stat) -> cty::c_int,
    >,
    pub fchstat: ::core::option::Option<
        unsafe extern "C" fn(filep: *const file, buf: *const stat, flags: cty::c_int) -> cty::c_int,
    >,
    pub opendir: ::core::option::Option<
        unsafe extern "C" fn(
            mountpt: *mut inode,
            relpath: *const cty::c_char,
            dir: *mut *mut fs_dirent_s,
        ) -> cty::c_int,
    >,
    pub closedir: ::core::option::Option<
        unsafe extern "C" fn(mountpt: *mut inode, dir: *mut fs_dirent_s) -> cty::c_int,
    >,
    pub readdir: ::core::option::Option<
        unsafe extern "C" fn(
            mountpt: *mut inode,
            dir: *mut fs_dirent_s,
            entry: *mut dirent,
        ) -> cty::c_int,
    >,
    pub rewinddir: ::core::option::Option<
        unsafe extern "C" fn(mountpt: *mut inode, dir: *mut fs_dirent_s) -> cty::c_int,
    >,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            blkdriver: *mut inode,
            data: *const cty::c_void,
            handle: *mut *mut cty::c_void,
        ) -> cty::c_int,
    >,
    pub unbind: ::core::option::Option<
        unsafe extern "C" fn(
            handle: *mut cty::c_void,
            blkdriver: *mut *mut inode,
            flags: cty::c_uint,
        ) -> cty::c_int,
    >,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(mountpt: *mut inode, buf: *mut statfs) -> cty::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(mountpt: *mut inode, relpath: *const cty::c_char) -> cty::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            mountpt: *mut inode,
            relpath: *const cty::c_char,
            mode: mode_t,
        ) -> cty::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(mountpt: *mut inode, relpath: *const cty::c_char) -> cty::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            mountpt: *mut inode,
            oldrelpath: *const cty::c_char,
            newrelpath: *const cty::c_char,
        ) -> cty::c_int,
    >,
    pub stat: ::core::option::Option<
        unsafe extern "C" fn(
            mountpt: *mut inode,
            relpath: *const cty::c_char,
            buf: *mut stat,
        ) -> cty::c_int,
    >,
    pub chstat: ::core::option::Option<
        unsafe extern "C" fn(
            mountpt: *mut inode,
            relpath: *const cty::c_char,
            buf: *const stat,
            flags: cty::c_int,
        ) -> cty::c_int,
    >,
    pub syncfs: ::core::option::Option<unsafe extern "C" fn(mountpt: *mut inode) -> cty::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode_ops_u {
    pub i_ops: *const file_operations,
    pub i_bops: *const block_operations,
    pub i_mtd: *mut mtd_dev_s,
    pub i_mops: *const mountpt_operations,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_parent: *mut inode,
    pub i_peer: *mut inode,
    pub i_child: *mut inode,
    pub i_crefs: i16,
    pub i_flags: u16,
    pub u: inode_ops_u,
    pub i_ino: ino_t,
    pub i_private: *mut cty::c_void,
    pub i_name: [cty::c_char; 1usize],
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, buf: *mut cty::c_char, size: usize) -> isize,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, buf: *const cty::c_char, size: usize) -> isize,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut cty::c_void, offset: *mut off_t, whence: cty::c_int) -> off_t,
>;
pub type cookie_close_function_t =
    ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void) -> cty::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file {
    pub f_oflags: cty::c_int,
    pub f_pos: off_t,
    pub f_inode: *mut inode,
    pub f_priv: *mut cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filelist {
    pub fl_lock: spinlock_t,
    pub fl_rows: u8,
    pub fl_files: *mut *mut file,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_struct {
    pub fs_next: *mut file_struct,
    pub fs_lock: rmutex_t,
    pub fs_iofunc: cookie_io_functions_t,
    pub fs_cookie: *mut cty::c_void,
    pub fs_bufstart: *mut cty::c_char,
    pub fs_bufend: *mut cty::c_char,
    pub fs_bufpos: *mut cty::c_char,
    pub fs_bufread: *mut cty::c_char,
    pub fs_buffer: [cty::c_char; 64usize],
    pub fs_oflags: u16,
    pub fs_flags: u8,
    pub fs_nungotten: u8,
    pub fs_ungotten: [cty::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct streamlist {
    pub sl_lock: mutex_t,
    pub sl_std: [file_struct; 3usize],
    pub sl_head: *mut file_struct,
    pub sl_tail: *mut file_struct,
}
extern "C" {
    #[doc = " Name: fs_initialize\n\n Description:\n   This is called from the OS initialization logic to configure the file\n   system.\n"]
    pub fn fs_initialize();
}
extern "C" {
    #[doc = " Name: register_driver\n\n Description:\n   Register a character driver inode the pseudo file system.\n\n Input Parameters:\n   path - The path to the inode to create\n   fops - The file operations structure\n   mode - Access privileges\n   priv - Private, user data that will be associated with the inode.\n\n Returned Value:\n   Zero on success (with the inode point in 'inode'); A negated errno\n   value is returned on a failure (all error values returned by\n   inode_reserve):\n\n   EINVAL - 'path' is invalid for this operation\n   EEXIST - An inode already exists at 'path'\n   ENOMEM - Failed to allocate in-memory resources for the operation\n"]
    pub fn register_driver(
        path: *const cty::c_char,
        fops: *const file_operations,
        mode: mode_t,
        priv_: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn register_blockdriver(
        path: *const cty::c_char,
        bops: *const block_operations,
        mode: mode_t,
        priv_: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn register_blockpartition(
        partition: *const cty::c_char,
        mode: mode_t,
        parent: *const cty::c_char,
        firstsector: off_t,
        nsectors: off_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: unregister_driver\n\n Description:\n   Remove the character driver inode at 'path' from the pseudo-file system\n"]
    pub fn unregister_driver(path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: unregister_blockdriver\n\n Description:\n   Remove the block driver inode at 'path' from the pseudo-file system\n"]
    pub fn unregister_blockdriver(path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn nx_mount(
        source: *const cty::c_char,
        target: *const cty::c_char,
        filesystemtype: *const cty::c_char,
        mountflags: cty::c_ulong,
        data: *const cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn nx_umount2(target: *const cty::c_char, flags: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: files_initlist\n\n Description:\n   Initializes the list of files for a new task\n"]
    pub fn files_initlist(list: *mut filelist);
}
extern "C" {
    #[doc = " Name: files_releaselist\n\n Description:\n   Release a reference to the file list\n"]
    pub fn files_releaselist(list: *mut filelist);
}
extern "C" {
    #[doc = " Name: files_countlist\n\n Description:\n   Get file count from file list\n\n Returned Value:\n   file count of file list\n"]
    pub fn files_countlist(list: *mut filelist) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: files_duplist\n\n Description:\n   Duplicate parent task's file descriptors.\n\n Returned Value:\n   Zero (OK) is returned on success; a negated errno value is returned on\n   any failure.\n"]
    pub fn files_duplist(
        plist: *mut filelist,
        clist: *mut filelist,
        actions: *const posix_spawn_file_actions_t,
        cloexec: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: files_fget\n\n Description:\n   Get the instance of struct file from file list by file descriptor.\n\n Input Parameters:\n   list - The list of files for a task.\n   fd   - A valid descriptor between 0 and files_countlist(list).\n\n Returned Value:\n   Pointer to file structure of list[fd].\n"]
    pub fn files_fget(list: *mut filelist, fd: cty::c_int) -> *mut file;
}
extern "C" {
    #[doc = " Name: file_allocate_from_tcb\n\n Description:\n   Allocate a struct files instance and associate it with an inode\n   instance.\n\n Returned Value:\n     Returns the file descriptor == index into the files array on success;\n     a negated errno value is returned on any failure.\n"]
    pub fn file_allocate_from_tcb(
        tcb: *mut tcb_s,
        inode: *mut inode,
        oflags: cty::c_int,
        pos: off_t,
        priv_: *mut cty::c_void,
        minfd: cty::c_int,
        addref: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_allocate\n\n Description:\n   Allocate a struct files instance and associate it with an inode\n   instance.\n\n Returned Value:\n     Returns the file descriptor == index into the files array on success;\n     a negated errno value is returned on any failure.\n"]
    pub fn file_allocate(
        inode: *mut inode,
        oflags: cty::c_int,
        pos: off_t,
        priv_: *mut cty::c_void,
        minfd: cty::c_int,
        addref: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_dup\n\n Description:\n   Equivalent to the standard dup() function except that it\n   accepts a struct file instance instead of a file descriptor.\n\n Returned Value:\n   Zero (OK) is returned on success; a negated errno value is returned on\n   any failure.\n"]
    pub fn file_dup(filep: *mut file, minfd: cty::c_int, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_dup2\n\n Description:\n   Assign an inode to a specific files structure.  This is the heart of\n   dup2.\n\n   Equivalent to the non-standard dup2() function except that it\n   accepts struct file instances instead of file descriptors.\n\n Returned Value:\n   Zero (OK) is returned on success; a negated errno value is return on\n   any failure.\n"]
    pub fn file_dup2(filep1: *mut file, filep2: *mut file) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_dup2_from_tcb\n\n Description:\n   nx_dup2_from_tcb() is similar to the standard 'dup2' interface\n   except that is not a cancellation point and it does not modify the\n   errno variable.\n\n   nx_dup2_from_tcb() is an internal NuttX interface and should not be\n   called from applications.\n\n   Clone a file descriptor to a specific descriptor number.\n\n Returned Value:\n   fd2 is returned on success; a negated errno value is return on\n   any failure.\n"]
    pub fn nx_dup2_from_tcb(tcb: *mut tcb_s, fd1: cty::c_int, fd2: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_dup2\n\n Description:\n   nx_dup2() is similar to the standard 'dup2' interface except that is\n   not a cancellation point and it does not modify the errno variable.\n\n   nx_dup2() is an internal NuttX interface and should not be called from\n   applications.\n\n Returned Value:\n   fd2 is returned on success; a negated errno value is return on\n   any failure.\n"]
    pub fn nx_dup2(fd1: cty::c_int, fd2: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_dup3\n\n Description:\n   Assign an inode to a specific files structure.  This is the heart of\n   dup3.\n\n   Equivalent to the non-standard dup3() function except that it\n   accepts struct file instances instead of file descriptors.\n\n Returned Value:\n   Zero (OK) is returned on success; a negated errno value is return on\n   any failure.\n"]
    pub fn file_dup3(filep1: *mut file, filep2: *mut file, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_open\n\n Description:\n   file_open() is similar to the standard 'open' interface except that it\n   returns an instance of 'struct file' rather than a file descriptor.  It\n   also is not a cancellation point and does not modify the errno variable.\n\n Input Parameters:\n   filep  - The caller provided location in which to return the 'struct\n            file' instance.\n   path   - The full path to the file to be open.\n   oflags - open flags\n   ...    - Variable number of arguments, may include 'mode_t mode'\n\n Returned Value:\n   Zero (OK) is returned on success.  On failure, a negated errno value is\n   returned.\n"]
    pub fn file_open(
        filep: *mut file,
        path: *const cty::c_char,
        oflags: cty::c_int,
        ...
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_open_from_tcb\n\n Description:\n   nx_open_from_tcb() is similar to the standard 'open' interface except\n   that it is not a cancellation point and it does not modify the errno\n   variable.\n\n   nx_open_from_tcb() is an internal NuttX interface and should not be\n   called from applications.\n\n Input Parameters:\n   tcb    - Address of the task's TCB\n   path   - The full path to the file to be opened.\n   oflags - open flags.\n   ...    - Variable number of arguments, may include 'mode_t mode'\n\n Returned Value:\n   The new file descriptor is returned on success; a negated errno value is\n   returned on any failure.\n"]
    pub fn nx_open_from_tcb(
        tcb: *mut tcb_s,
        path: *const cty::c_char,
        oflags: cty::c_int,
        ...
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_open\n\n Description:\n   nx_open() is similar to the standard 'open' interface except that is is\n   not a cancellation point and it does not modify the errno variable.\n\n   nx_open() is an internal NuttX interface and should not be called\n   from applications.\n\n Returned Value:\n   The new file descriptor is returned on success; a negated errno value is\n   returned on any failure.\n"]
    pub fn nx_open(path: *const cty::c_char, oflags: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: fs_getfilep\n\n Description:\n   Given a file descriptor, return the corresponding instance of struct\n   file.  NOTE that this function will currently fail if it is provided\n   with a socket descriptor.\n\n Input Parameters:\n   fd    - The file descriptor\n   filep - The location to return the struct file instance\n\n Returned Value:\n   Zero (OK) is returned on success; a negated errno value is returned on\n   any failure.\n"]
    pub fn fs_getfilep(fd: cty::c_int, filep: *mut *mut file) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_close\n\n Description:\n   Close a file that was previously opened with file_open().\n\n Input Parameters:\n   filep - A pointer to a user provided memory location containing the\n           open file data returned by file_open().\n\n Returned Value:\n   Zero (OK) is returned on success; A negated errno value is returned on\n   any failure to indicate the nature of the failure.\n"]
    pub fn file_close(filep: *mut file) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_close_from_tcb\n\n Description:\n   nx_close_from_tcb() is similar to the standard 'close' interface\n   except that is not a cancellation point and it does not modify the\n   errno variable.\n\n   nx_close_from_tcb() is an internal NuttX interface and should not\n   be called from applications.\n\n   Close an inode (if open)\n\n Returned Value:\n   Zero (OK) is returned on success; A negated errno value is returned on\n   on any failure.\n\n Assumptions:\n   Caller holds the list mutex because the file descriptor will be\n   freed.\n"]
    pub fn nx_close_from_tcb(tcb: *mut tcb_s, fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_close\n\n Description:\n   nx_close() is similar to the standard 'close' interface except that is\n   not a cancellation point and it does not modify the errno variable.\n\n   nx_close() is an internal NuttX interface and should not be called from\n   applications.\n\n Returned Value:\n   The new file descriptor is returned on success; a negated errno value is\n   returned on any failure.\n"]
    pub fn nx_close(fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: open_blockdriver\n\n Description:\n   Return the inode of the block driver specified by 'pathname'\n\n Input Parameters:\n   pathname - the full path to the block driver to be opened\n   mountflags - if MS_RDONLY is not set, then driver must support write\n     operations (see include/sys/mount.h)\n   ppinode - address of the location to return the inode reference\n\n Returned Value:\n   Returns zero on success or a negated errno on failure:\n\n   EINVAL  - pathname or pinode is NULL\n   ENOENT  - No block driver of this name is registered\n   ENOTBLK - The inode associated with the pathname is not a block driver\n   EACCESS - The MS_RDONLY option was not set but this driver does not\n     support write access\n"]
    pub fn open_blockdriver(
        pathname: *const cty::c_char,
        mountflags: cty::c_int,
        ppinode: *mut *mut inode,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: close_blockdriver\n\n Description:\n   Call the close method and release the inode\n\n Input Parameters:\n   inode - reference to the inode of a block driver opened by\n           open_blockdriver\n\n Returned Value:\n   Returns zero on success or a negated errno on failure:\n\n   EINVAL  - inode is NULL\n   ENOTBLK - The inode is not a block driver\n"]
    pub fn close_blockdriver(inode: *mut inode) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: find_blockdriver\n\n Description:\n   Return the inode of the block driver specified by 'pathname'\n\n Input Parameters:\n   pathname   - The full path to the block driver to be located\n   mountflags - If MS_RDONLY is not set, then driver must support write\n                operations (see include/sys/mount.h)\n   ppinode    - Address of the location to return the inode reference\n\n Returned Value:\n   Returns zero on success or a negated errno on failure:\n\n   ENOENT  - No block driver of this name is registered\n   ENOTBLK - The inode associated with the pathname is not a block driver\n   EACCESS - The MS_RDONLY option was not set but this driver does not\n             support write access\n"]
    pub fn find_blockdriver(
        pathname: *const cty::c_char,
        mountflags: cty::c_int,
        ppinode: *mut *mut inode,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: find_mtddriver\n\n Description:\n   Return the inode of the named MTD driver specified by 'pathname'\n\n Input Parameters:\n   pathname   - the full path to the named MTD driver to be located\n   ppinode    - address of the location to return the inode reference\n\n Returned Value:\n   Returns zero on success or a negated errno on failure:\n\n   ENOENT  - No MTD driver of this name is registered\n   ENOTBLK - The inode associated with the pathname is not an MTD driver\n"]
    pub fn find_mtddriver(pathname: *const cty::c_char, ppinode: *mut *mut inode) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: close_mtddriver\n\n Description:\n   Release the inode got by function find_mtddriver()\n\n Input Parameters:\n   pinode    - pointer to the inode\n\n Returned Value:\n   Returns zero on success or a negated errno on failure:\n\n   EINVAL  - inode is NULL\n"]
    pub fn close_mtddriver(pinode: *mut inode) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_read\n\n Description:\n   file_read() is an internal OS interface.  It is functionally similar to\n   the standard read() interface except:\n\n    - It does not modify the errno variable,\n    - It is not a cancellation point,\n    - It does not handle socket descriptors, and\n    - It accepts a file structure instance instead of file descriptor.\n\n Input Parameters:\n   filep  - File structure instance\n   buf    - User-provided to save the data\n   nbytes - The maximum size of the user-provided buffer\n\n Returned Value:\n   The positive non-zero number of bytes read on success, 0 on if an\n   end-of-file condition, or a negated errno value on any failure.\n"]
    pub fn file_read(filep: *mut file, buf: *mut cty::c_void, nbytes: usize) -> isize;
}
extern "C" {
    #[doc = " Name: nx_read\n\n Description:\n   nx_read() is an internal OS interface.  It is functionally similar to\n   the standard read() interface except:\n\n    - It does not modify the errno variable, and\n    - It is not a cancellation point.\n\n Input Parameters:\n   fd     - File descriptor to read from\n   buf    - User-provided to save the data\n   nbytes - The maximum size of the user-provided buffer\n\n Returned Value:\n   The positive non-zero number of bytes read on success, 0 on if an\n   end-of-file condition, or a negated errno value on any failure.\n"]
    pub fn nx_read(fd: cty::c_int, buf: *mut cty::c_void, nbytes: usize) -> isize;
}
extern "C" {
    #[doc = " Name: file_write\n\n Description:\n   Equivalent to the standard write() function except that is accepts a\n   struct file instance instead of a file descriptor.  It is functionally\n   equivalent to write() except that in addition to the differences in\n   input parameters:\n\n  - It does not modify the errno variable,\n  - It is not a cancellation point, and\n  - It does not handle socket descriptors.\n\n Input Parameters:\n   filep  - Instance of struct file to use with the write\n   buf    - Data to write\n   nbytes - Length of data to write\n\n Returned Value:\n  On success, the number of bytes written are returned (zero indicates\n  nothing was written).  On any failure, a negated errno value is returned\n  (see comments withwrite() for a description of the appropriate errno\n  values).\n"]
    pub fn file_write(filep: *mut file, buf: *const cty::c_void, nbytes: usize) -> isize;
}
extern "C" {
    #[doc = " Name: nx_write\n\n Description:\n  nx_write() writes up to nbytes bytes to the file referenced by the file\n  descriptor fd from the buffer starting at buf.  nx_write() is an\n  internal OS function.  It is functionally equivalent to write() except\n  that:\n\n  - It does not modify the errno variable, and\n  - It is not a cancellation point.\n\n Input Parameters:\n   fd     - file descriptor (or socket descriptor) to write to\n   buf    - Data to write\n   nbytes - Length of data to write\n\n Returned Value:\n  On success, the number of bytes written are returned (zero indicates\n  nothing was written).  On any failure, a negated errno value is returned\n  (see comments with write() for a description of the appropriate errno\n   values).\n"]
    pub fn nx_write(fd: cty::c_int, buf: *const cty::c_void, nbytes: usize) -> isize;
}
extern "C" {
    #[doc = " Name: file_pread\n\n Description:\n   Equivalent to the standard pread function except that is accepts a\n   struct file instance instead of a file descriptor.  Currently used\n   only by aio_read();\n"]
    pub fn file_pread(
        filep: *mut file,
        buf: *mut cty::c_void,
        nbytes: usize,
        offset: off_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Name: file_pwrite\n\n Description:\n   Equivalent to the standard pwrite function except that is accepts a\n   struct file instance instead of a file descriptor.  Currently used\n   only by aio_write();\n"]
    pub fn file_pwrite(
        filep: *mut file,
        buf: *const cty::c_void,
        nbytes: usize,
        offset: off_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Name: file_sendfile\n\n Description:\n   Equivalent to the standard sendfile function except that is accepts a\n   struct file instance instead of a file descriptor.\n"]
    pub fn file_sendfile(
        outfile: *mut file,
        infile: *mut file,
        offset: *mut off_t,
        count: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Name: file_seek\n\n Description:\n   Equivalent to the standard lseek() function except that is accepts a\n   struct file instance instead of a file descriptor.  Currently used\n   only by net_sendfile()\n"]
    pub fn file_seek(filep: *mut file, offset: off_t, whence: cty::c_int) -> off_t;
}
extern "C" {
    #[doc = " Name: nx_seek\n\n Description:\n  nx_seek() function repositions the offset of the open file associated\n  with the file descriptor fd to the argument 'offset' according to the\n  directive 'whence'.  nx_seek() is an internal OS function. It is\n  functionally equivalent to lseek() except that:\n\n  - It does not modify the errno variable, and\n  - It is not a cancellation point.\n"]
    pub fn nx_seek(fd: cty::c_int, offset: off_t, whence: cty::c_int) -> off_t;
}
extern "C" {
    #[doc = " Name: file_fsync\n\n Description:\n   Equivalent to the standard fsync() function except that is accepts a\n   struct file instance instead of a file descriptor and it does not set\n   the errno variable.\n"]
    pub fn file_fsync(filep: *mut file) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_syncfs\n\n Description:\n   Equivalent to the standard syncsf() function except that is accepts a\n   struct file instance instead of a fd descriptor and it does not set\n   the errno variable\n"]
    pub fn file_syncfs(filep: *mut file) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_truncate\n\n Description:\n   Equivalent to the standard ftruncate() function except that is accepts\n   a struct file instance instead of a file descriptor and it does not set\n   the errno variable.\n"]
    pub fn file_truncate(filep: *mut file, length: off_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_mmap\n\n Description:\n   Equivalent to the standard mmap() function except that is accepts\n   a struct file instance instead of a file descriptor and it does not set\n   the errno variable.\n"]
    pub fn file_mmap(
        filep: *mut file,
        start: *mut cty::c_void,
        length: usize,
        prot: cty::c_int,
        flags: cty::c_int,
        offset: off_t,
        mapped: *mut *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_mummap\n\n Description:\n   Equivalent to the standard mummap() function except it does not set\n   the errno variable.\n"]
    pub fn file_munmap(start: *mut cty::c_void, length: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_ioctl\n\n Description:\n   Perform device specific operations.\n\n Input Parameters:\n   file     File structure instance\n   req      The ioctl command\n   ap       The argument of the ioctl cmd\n\n Returned Value:\n   Returns a non-negative number on success;  A negated errno value is\n   returned on any failure (see comments ioctl() for a list of appropriate\n   errno values).\n"]
    pub fn file_ioctl(filep: *mut file, req: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_fcntl\n\n Description:\n   Similar to the standard fcntl function except that is accepts a struct\n   struct file instance instead of a file descriptor.\n\n Input Parameters:\n   filep - Instance for struct file for the opened file.\n   cmd   - Identifies the operation to be performed.  Command specific\n           arguments may follow.\n\n Returned Value:\n   The nature of the return value depends on the command.  Non-negative\n   values indicate success.  Failures are reported as negated errno\n   values.\n"]
    pub fn file_fcntl(filep: *mut file, cmd: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_poll\n\n Description:\n   Low-level poll operation based on struct file.  This is used both to (1)\n   support detached file, and also (2) by poll_fdsetup() to perform all\n   normal operations on file descriptors.\n\n Input Parameters:\n   file     File structure instance\n   fds   - The structure describing the events to be monitored, OR NULL if\n           this is a request to stop monitoring events.\n   setup - true: Setup up the poll; false: Teardown the poll\n\n Returned Value:\n  0: Success; Negated errno on failure\n"]
    pub fn file_poll(filep: *mut file, fds: *mut pollfd, setup: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_fstat\n\n Description:\n   file_fstat() is an internal OS interface.  It is functionally similar to\n   the standard fstat() interface except:\n\n    - It does not modify the errno variable,\n    - It is not a cancellation point,\n    - It does not handle socket descriptors, and\n    - It accepts a file structure instance instead of file descriptor.\n\n Input Parameters:\n   filep  - File structure instance\n   buf    - The caller provide location in which to return information\n            about the open file.\n\n Returned Value:\n   Upon successful completion, 0 shall be returned. Otherwise, -1 shall be\n   returned and errno set to indicate the error.\n"]
    pub fn file_fstat(filep: *mut file, buf: *mut stat) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_fstat\n\n Description:\n   nx_fstat() is similar to the standard 'fstat' interface except that is\n   not a cancellation point and it does not modify the errno variable.\n\n   nx_fstat() is an internal NuttX interface and should not be called from\n   applications.\n\n Returned Value:\n   Zero is returned on success; a negated value is returned on any failure.\n"]
    pub fn nx_fstat(fd: cty::c_int, buf: *mut stat) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_stat\n\n Description:\n   nx_stat() is similar to the standard 'stat' interface except that is\n   not a cancellation point and it does not modify the errno variable.\n\n   nx_stat() is an internal NuttX interface and should not be called from\n   applications.\n\n Returned Value:\n   Zero is returned on success; a negated value is returned on any failure.\n"]
    pub fn nx_stat(path: *const cty::c_char, buf: *mut stat, resolve: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: file_fchstat\n\n Description:\n   file_fchstat() is an internal OS interface. It is functionally similar\n   to the combination of fchmod/fchown/futimens standard interface except:\n\n    - It does not modify the errno variable,\n    - It is not a cancellation point,\n    - It does not handle socket descriptors, and\n    - It accepts a file structure instance instead of file descriptor.\n\n Input Parameters:\n   filep  - File structure instance\n   buf    - The stat to be modified\n   flags  - The valid field in buf\n\n Returned Value:\n   Upon successful completion, 0 shall be returned. Otherwise, the\n   negative errno shall be returned to indicate the error.\n"]
    pub fn file_fchstat(filep: *mut file, buf: *mut stat, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nx_unlink\n\n Description:\n   nx_unlink() is similar to the standard 'unlink' interface except that\n   is not a cancellation point and it does not modify the errno variable.\n\n   nx_unlink() is an internal NuttX interface and should not be called\n   from applications.\n\n Returned Value:\n   Zero is returned on success; a negated value is returned on any failure.\n"]
    pub fn nx_unlink(pathname: *const cty::c_char) -> cty::c_int;
}
#[doc = " Public Types"]
pub type spi_mediachange_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
pub const spi_devtype_e_SPIDEVTYPE_NONE: spi_devtype_e = 0;
pub const spi_devtype_e_SPIDEVTYPE_MMCSD: spi_devtype_e = 1;
pub const spi_devtype_e_SPIDEVTYPE_FLASH: spi_devtype_e = 2;
pub const spi_devtype_e_SPIDEVTYPE_ETHERNET: spi_devtype_e = 3;
pub const spi_devtype_e_SPIDEVTYPE_DISPLAY: spi_devtype_e = 4;
pub const spi_devtype_e_SPIDEVTYPE_CAMERA: spi_devtype_e = 5;
pub const spi_devtype_e_SPIDEVTYPE_WIRELESS: spi_devtype_e = 6;
pub const spi_devtype_e_SPIDEVTYPE_TOUCHSCREEN: spi_devtype_e = 7;
pub const spi_devtype_e_SPIDEVTYPE_EXPANDER: spi_devtype_e = 8;
pub const spi_devtype_e_SPIDEVTYPE_MUX: spi_devtype_e = 9;
pub const spi_devtype_e_SPIDEVTYPE_AUDIO_DATA: spi_devtype_e = 10;
pub const spi_devtype_e_SPIDEVTYPE_AUDIO_CTRL: spi_devtype_e = 11;
pub const spi_devtype_e_SPIDEVTYPE_EEPROM: spi_devtype_e = 12;
pub const spi_devtype_e_SPIDEVTYPE_ACCELEROMETER: spi_devtype_e = 13;
pub const spi_devtype_e_SPIDEVTYPE_BAROMETER: spi_devtype_e = 14;
pub const spi_devtype_e_SPIDEVTYPE_TEMPERATURE: spi_devtype_e = 15;
pub const spi_devtype_e_SPIDEVTYPE_IEEE802154: spi_devtype_e = 16;
pub const spi_devtype_e_SPIDEVTYPE_CONTACTLESS: spi_devtype_e = 17;
pub const spi_devtype_e_SPIDEVTYPE_CANBUS: spi_devtype_e = 18;
pub const spi_devtype_e_SPIDEVTYPE_USBHOST: spi_devtype_e = 19;
pub const spi_devtype_e_SPIDEVTYPE_LPWAN: spi_devtype_e = 20;
pub const spi_devtype_e_SPIDEVTYPE_ADC: spi_devtype_e = 21;
pub const spi_devtype_e_SPIDEVTYPE_MOTOR: spi_devtype_e = 22;
pub const spi_devtype_e_SPIDEVTYPE_IMU: spi_devtype_e = 23;
pub const spi_devtype_e_SPIDEVTYPE_USER: spi_devtype_e = 24;
pub type spi_devtype_e = cty::c_uint;
pub const spi_mode_e_SPIDEV_MODE0: spi_mode_e = 0;
pub const spi_mode_e_SPIDEV_MODE1: spi_mode_e = 1;
pub const spi_mode_e_SPIDEV_MODE2: spi_mode_e = 2;
pub const spi_mode_e_SPIDEV_MODE3: spi_mode_e = 3;
pub const spi_mode_e_SPIDEV_MODETI: spi_mode_e = 4;
pub type spi_mode_e = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_ops_s {
    pub lock:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut spi_dev_s, lock: bool) -> cty::c_int>,
    pub select: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut spi_dev_s, devid: u32, selected: bool),
    >,
    pub setfrequency:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut spi_dev_s, frequency: u32) -> u32>,
    pub setmode:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut spi_dev_s, mode: spi_mode_e)>,
    pub setbits:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut spi_dev_s, nbits: cty::c_int)>,
    pub status: ::core::option::Option<unsafe extern "C" fn(dev: *mut spi_dev_s, devid: u32) -> u8>,
    pub send: ::core::option::Option<unsafe extern "C" fn(dev: *mut spi_dev_s, wd: u32) -> u32>,
    pub exchange: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut spi_dev_s,
            txbuffer: *const cty::c_void,
            rxbuffer: *mut cty::c_void,
            nwords: usize,
        ),
    >,
    pub registercallback: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut spi_dev_s,
            callback: spi_mediachange_t,
            arg: *mut cty::c_void,
        ) -> cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s {
    pub ops: *const spi_ops_s,
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: u16,
    pub ws_col: u16,
    pub ws_xpixel: u16,
    pub ws_ypixel: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serial_rs485 {
    pub flags: u32,
    pub delay_rts_before_send: u32,
    pub delay_rts_after_send: u32,
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_peek_s {
    pub buf: *mut cty::c_void,
    pub size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_ops_s {
    pub transfer: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut i2c_master_s,
            msgs: *mut i2c_msg_s,
            count: cty::c_int,
        ) -> cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_config_s {
    pub frequency: u32,
    pub address: u16,
    pub addrlen: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_msg_s {
    pub frequency: u32,
    pub addr: u16,
    pub flags: u16,
    pub buffer: *mut u8,
    pub length: isize,
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_master_s {
    pub ops: *const i2c_ops_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_transfer_s {
    pub msgv: *mut i2c_msg_s,
    pub msgc: usize,
}
extern "C" {
    #[doc = " Name: i2c_writeread\n\n Description:\n   Send a block of data on I2C followed by restarted read access.  This\n   provides a convenient wrapper to the transfer function.\n\n Input Parameters:\n   dev     - Device-specific state data\n   config  - Described the I2C configuration\n   wbuffer - A pointer to the read-only buffer of data to be written to\n             device\n   wbuflen - The number of bytes to send from the buffer\n   rbuffer - A pointer to a buffer of data to receive the data from the\n             device\n   rbuflen - The requested number of bytes to be read\n\n Returned Value:\n   0: success, <0: A negated errno\n"]
    pub fn i2c_writeread(
        dev: *mut i2c_master_s,
        config: *const i2c_config_s,
        wbuffer: *const u8,
        wbuflen: cty::c_int,
        rbuffer: *mut u8,
        rbuflen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: i2c_write\n\n Description:\n   Send a block of data on I2C. Each write operation will be an 'atomic'\n   operation in the sense that any other I2C actions will be serialized\n   and pend until this write completes.\n\n Input Parameters:\n   dev    - Device-specific state data\n   config  - Described the I2C configuration\n   buffer - A pointer to the read-only buffer of data to be written to\n            device\n   buflen - The number of bytes to send from the buffer\n\n Returned Value:\n   0: success, <0: A negated errno\n"]
    pub fn i2c_write(
        dev: *mut i2c_master_s,
        config: *const i2c_config_s,
        buffer: *const u8,
        buflen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: i2c_read\n\n Description:\n   Receive a block of data from I2C. Each read operation will be an\n   'atomic' operation in the sense that any other I2C actions will be\n   serialized and pend until this read completes.\n\n Input Parameters:\n   dev    - Device-specific state data\n   buffer - A pointer to a buffer of data to receive the data from the\n            device\n   buflen - The requested number of bytes to be read\n\n Returned Value:\n   0: success, <0: A negated errno\n"]
    pub fn i2c_read(
        dev: *mut i2c_master_s,
        config: *const i2c_config_s,
        buffer: *mut u8,
        buflen: cty::c_int,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_callback_s {
    pub au_receive: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut adc_dev_s, ch: u8, data: i32) -> cty::c_int,
    >,
    pub au_reset: ::core::option::Option<unsafe extern "C" fn(dev: *mut adc_dev_s) -> cty::c_int>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct adc_msg_s {
    pub am_channel: u8,
    pub am_data: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_fifo_s {
    pub af_sem: sem_t,
    pub af_head: u8,
    pub af_tail: u8,
    pub af_buffer: [adc_msg_s; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_ops_s {
    pub ao_bind: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut adc_dev_s, callback: *const adc_callback_s) -> cty::c_int,
    >,
    pub ao_reset: ::core::option::Option<unsafe extern "C" fn(dev: *mut adc_dev_s)>,
    pub ao_setup: ::core::option::Option<unsafe extern "C" fn(dev: *mut adc_dev_s) -> cty::c_int>,
    pub ao_shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut adc_dev_s)>,
    pub ao_rxint: ::core::option::Option<unsafe extern "C" fn(dev: *mut adc_dev_s, enable: bool)>,
    pub ao_ioctl: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut adc_dev_s, cmd: cty::c_int, arg: cty::c_ulong) -> cty::c_int,
    >,
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_dev_s {
    pub ad_ops: *const adc_ops_s,
    pub ad_priv: *mut cty::c_void,
}
extern "C" {
    #[doc = " Name: adc_register\n\n Description:\n   Register a ADC driver. This function binds an instance of a \"lower half\"\n   ADC driver with the \"upper half\" ADC device and registers that device\n   so that can be used by application code.\n\n Input Parameters:\n   path - The full path to the driver to be registers in the NuttX pseudo-\n     filesystem.  The recommended convention is to name all PWM drivers\n     as \"/dev/adc\", \"/dev/adc1\", etc.  where the driver path differs only\n     in the \"minor\" number at the end of the device name.\n   dev - A pointer to an instance of lower half ADC driver.  This instance\n     is bound to the upper half ADC driver and must persists as long as the\n     upper half driver driver persists.\n\n Returned Value:\n   Zero on success; a negated errno value on failure.\n"]
    pub fn adc_register(path: *const cty::c_char, dev: *mut adc_dev_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_ads1255initialize\n\n Description:\n   Initialize the TI ADS 125X lower half driver\n"]
    pub fn up_ads1255initialize(spi: *mut spi_dev_s, devno: cty::c_uint) -> *mut adc_dev_s;
}
extern "C" {
    #[doc = " Name: lmp92001_adc_initialize\n\n Description:\n   Initialize ADC\n\n Input Parameters:\n   I2C Port number\n   Device address\n\n Returned Value:\n   Valid LM92001 device structure reference on success; a NULL on failure\n"]
    pub fn lmp92001_adc_initialize(i2c: *mut i2c_master_s, addr: u8) -> *mut adc_dev_s;
}
extern "C" {
    #[doc = " Name: ads7828_initialize\n\n Description:\n   Initialize ADC\n\n Input Parameters:\n   i2c - Pointer to a valid I2C master struct.\n   addr - I2C device address.\n\n Returned Value:\n   Valid ADS7828 device structure reference on success; a NULL on failure\n"]
    pub fn ads7828_initialize(i2c: *mut i2c_master_s, addr: u8) -> *mut adc_dev_s;
}
extern "C" {
    #[doc = " Name: max1161x_initialize\n\n Description:\n   Initialize ADC\n\n Input Parameters:\n   i2c - Pointer to a valid I2C master struct.\n\n Returned Value:\n   Valid MX1161X device structure reference on success; a NULL on failure\n"]
    pub fn max1161x_initialize(i2c: *mut i2c_master_s) -> *mut adc_dev_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpu_config_s {
    pub i2c: *mut i2c_master_s,
    pub addr: cty::c_int,
}
extern "C" {
    pub fn mpu60x0_register(path: *const cty::c_char, config: *mut mpu_config_s) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_s {
    pub quot: cty::c_int,
    pub rem: cty::c_int,
}
#[doc = " Public Type Definitions"]
pub type div_t = div_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_s {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
pub type ldiv_t = ldiv_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_s {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
pub type lldiv_t = lldiv_s;
extern "C" {
    pub fn srand(seed: cty::c_uint);
}
extern "C" {
    pub fn rand() -> cty::c_int;
}
extern "C" {
    pub fn rand_r(seedp: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn lcong48(param: *mut cty::c_ushort);
}
extern "C" {
    pub fn seed48(seed16v: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn srand48(seedval: cty::c_long);
}
extern "C" {
    pub fn jrand48(xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn lrand48() -> cty::c_long;
}
extern "C" {
    pub fn mrand48() -> cty::c_long;
}
extern "C" {
    pub fn nrand48(xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(xsubi: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn random() -> cty::c_long;
}
extern "C" {
    pub fn get_environ_ptr() -> *mut *mut cty::c_char;
}
extern "C" {
    pub fn getenv(name: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putenv(string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn clearenv() -> cty::c_int;
}
extern "C" {
    pub fn setenv(
        name: *const cty::c_char,
        value: *const cty::c_char,
        overwrite: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn unsetenv(name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn exit(status: cty::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(status: cty::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn at_quick_exit(func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn on_exit(
        func: ::core::option::Option<
            unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void),
        >,
        arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _Exit(status: cty::c_int) -> !;
}
extern "C" {
    pub fn system(cmd: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn realpath(path: *const cty::c_char, resolved: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtol(
        nptr: *const cty::c_char,
        endptr: *mut *mut cty::c_char,
        base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoul(
        nptr: *const cty::c_char,
        endptr: *mut *mut cty::c_char,
        base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strtoll(
        nptr: *const cty::c_char,
        endptr: *mut *mut cty::c_char,
        base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        nptr: *const cty::c_char,
        endptr: *mut *mut cty::c_char,
        base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn strtof(str_: *const cty::c_char, endptr: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    pub fn strtod(str_: *const cty::c_char, endptr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn strtold(str_: *const cty::c_char, endptr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn atoi(nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn atol(nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn atoll(nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn atof(nptr: *const cty::c_char) -> f64;
}
extern "C" {
    pub fn itoa(val: cty::c_int, str_: *mut cty::c_char, base: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn mblen(s: *const cty::c_char, n: usize) -> cty::c_int;
}
extern "C" {
    pub fn mbtowc(pwc: *mut wchar_t, s: *const cty::c_char, n: usize) -> cty::c_int;
}
extern "C" {
    pub fn mbstowcs(dst: *mut wchar_t, src: *const cty::c_char, len: usize) -> usize;
}
extern "C" {
    pub fn wctomb(s: *mut cty::c_char, wchar: wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn wcstombs(dst: *mut cty::c_char, src: *const wchar_t, len: usize) -> usize;
}
extern "C" {
    pub fn malloc(arg1: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn free(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn realloc(arg1: *mut cty::c_void, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn memalign(arg1: cty::c_uint, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn zalloc(arg1: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn calloc(arg1: cty::c_uint, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn aligned_alloc(arg1: cty::c_uint, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn posix_memalign(arg1: *mut *mut cty::c_void, arg2: usize, arg3: usize) -> cty::c_int;
}
extern "C" {
    pub fn abs(j: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn labs(j: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn llabs(j: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn div(number: cty::c_int, denom: cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(number: cty::c_long, denom: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(number: cty::c_longlong, denom: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mktemp(path_template: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn mkstemp(path_template: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn mkdtemp(path_template: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn qsort(
        base: *mut cty::c_void,
        nel: usize,
        width: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
        >,
    );
}
extern "C" {
    pub fn bsearch(
        key: *const cty::c_void,
        base: *const cty::c_void,
        nel: usize,
        width: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
        >,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn getprogname() -> *const cty::c_char;
}
extern "C" {
    pub fn __cxa_atexit(
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg: *mut cty::c_void,
        dso_handle: *mut cty::c_void,
    ) -> cty::c_int;
}
pub type wdparm_t = usize;
pub type wdentry_t = ::core::option::Option<unsafe extern "C" fn(arg: wdparm_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wdog_s {
    pub next: *mut wdog_s,
    pub arg: wdparm_t,
    pub func: wdentry_t,
    pub lag: sclock_t,
}
extern "C" {
    #[doc = " Name: wd_start\n\n Description:\n   This function adds a watchdog timer to the active timer queue.  The\n   specified watchdog function at 'wdentry' will be called from the\n   interrupt level after the specified number of ticks has elapsed.\n   Watchdog timers may be started from the interrupt level.\n\n   Watchdog timers execute in the address environment that was in effect\n   when wd_start() is called.\n\n   Watchdog timers execute only once.\n\n   To replace either the timeout delay or the function to be executed,\n   call wd_start again with the same wdog; only the most recent wdStart()\n   on a given watchdog ID has any effect.\n\n Input Parameters:\n   wdog     - Watchdog ID\n   delay    - Delay count in clock ticks\n   wdentry  - Function to call on timeout\n   arg      - Parameter to pass to wdentry.\n\n   NOTE:  The parameter must be of type wdparm_t.\n\n Returned Value:\n   Zero (OK) is returned on success; a negated errno value is return to\n   indicate the nature of any failure.\n\n Assumptions:\n   The watchdog routine runs in the context of the timer interrupt handler\n   and is subject to all ISR restrictions.\n"]
    pub fn wd_start(
        wdog: *mut wdog_s,
        delay: sclock_t,
        wdentry: wdentry_t,
        arg: wdparm_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: wd_cancel\n\n Description:\n   This function cancels a currently running watchdog timer. Watchdog\n   timers may be cancelled from the interrupt level.\n\n Input Parameters:\n   wdog - ID of the watchdog to cancel.\n\n Returned Value:\n   Zero (OK) is returned on success;  A negated errno value is returned to\n   indicate the nature of any failure.\n"]
    pub fn wd_cancel(wdog: *mut wdog_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: wd_gettime\n\n Description:\n   This function returns the time remaining before the specified watchdog\n   timer expires.\n\n Input Parameters:\n   wdog - watchdog ID\n\n Returned Value:\n   The time in system ticks remaining until the watchdog time expires.\n   Zero means either that wdog is not valid or that the wdog has already\n   expired.\n"]
    pub fn wd_gettime(wdog: *mut wdog_s) -> sclock_t;
}
pub type worker_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct work_s {
    pub u: work_s__bindgen_ty_1,
    pub worker: worker_t,
    pub arg: *mut cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union work_s__bindgen_ty_1 {
    pub s: work_s__bindgen_ty_1__bindgen_ty_1,
    pub timer: wdog_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_s__bindgen_ty_1__bindgen_ty_1 {
    pub dq: dq_entry_s,
    pub qtime: clock_t,
}
pub const work_evtype_e_WORK_IOB_AVAIL: work_evtype_e = 1;
pub const work_evtype_e_WORK_NET_DOWN: work_evtype_e = 2;
pub const work_evtype_e_WORK_TCP_READAHEAD: work_evtype_e = 3;
pub const work_evtype_e_WORK_TCP_WRITEBUFFER: work_evtype_e = 4;
pub const work_evtype_e_WORK_TCP_DISCONNECT: work_evtype_e = 5;
pub const work_evtype_e_WORK_UDP_READAHEAD: work_evtype_e = 6;
pub const work_evtype_e_WORK_UDP_WRITEBUFFER: work_evtype_e = 7;
pub const work_evtype_e_WORK_NETLINK_RESPONSE: work_evtype_e = 8;
pub const work_evtype_e_WORK_CAN_READAHEAD: work_evtype_e = 9;
pub const work_evtype_e_WORK_USB_MSC_CONNECT: work_evtype_e = 10;
pub const work_evtype_e_WORK_USB_MSC_DISCONNECT: work_evtype_e = 11;
pub type work_evtype_e = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_notifier_s {
    pub evtype: u8,
    pub qid: u8,
    pub qualifier: *mut cty::c_void,
    pub arg: *mut cty::c_void,
    pub worker: worker_t,
}
pub type work_foreach_t =
    ::core::option::Option<unsafe extern "C" fn(tid: cty::c_int, arg: *mut cty::c_void)>;
extern "C" {
    #[doc = " Name: work_queue\n\n Description:\n   Queue work to be performed at a later time.  All queued work will be\n   performed on the worker thread of execution (not the caller's).\n\n   The work structure is allocated and must be initialized to all zero by\n   the caller.  Otherwise, the work structure is completely managed by the\n   work queue logic.  The caller should never modify the contents of the\n   work queue structure directly.  If work_queue() is called before the\n   previous work has been performed and removed from the queue, then any\n   pending work will be canceled and lost.\n\n Input Parameters:\n   qid    - The work queue ID\n   work   - The work structure to queue\n   worker - The worker callback to be invoked.  The callback will be\n            invoked on the worker thread of execution.\n   arg    - The argument that will be passed to the worker callback when\n            it is invoked.\n   delay  - Delay (in clock ticks) from the time queue until the worker\n            is invoked. Zero means to perform the work immediately.\n\n Returned Value:\n   Zero on success, a negated errno on failure\n"]
    pub fn work_queue(
        qid: cty::c_int,
        work: *mut work_s,
        worker: worker_t,
        arg: *mut cty::c_void,
        delay: clock_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: work_cancel\n\n Description:\n   Cancel previously queued work.  This removes work from the work queue.\n   After work has been cancelled, it may be requeued by calling\n   work_queue() again.\n\n Input Parameters:\n   qid    - The work queue ID\n   work   - The previously queued work structure to cancel\n\n Returned Value:\n   Zero on success, a negated errno on failure\n\n   -ENOENT - There is no such work queued.\n   -EINVAL - An invalid work queue was specified\n"]
    pub fn work_cancel(qid: cty::c_int, work: *mut work_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: work_cancel_sync\n\n Description:\n   Blocked cancel previously queued user-mode work.  This removes work\n   from the user mode work queue.  After work has been cancelled, it may\n   be requeued by calling work_queue() again.\n\n Input Parameters:\n   qid    - The work queue ID (must be HPWORK or LPWORK)\n   work   - The previously queued work structure to cancel\n\n Returned Value:\n   Zero (OK) on success, a negated errno on failure.  This error may be\n   reported:\n\n   -ENOENT - There is no such work queued.\n   -EINVAL - An invalid work queue was specified\n"]
    pub fn work_cancel_sync(qid: cty::c_int, work: *mut work_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: work_foreach\n\n Description:\n   Enumerate over each work thread and provide the tid of each task to a\n   user callback functions.\n\n Input Parameters:\n   qid     - The work queue ID\n   handler - The function to be called with the pid of each task\n   arg     - The function callback\n\n Returned Value:\n   None\n"]
    pub fn work_foreach(qid: cty::c_int, handler: work_foreach_t, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn vfork() -> cty::c_int;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getpgid(pid: pid_t) -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn gettid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn _exit(status: cty::c_int) -> !;
}
extern "C" {
    pub fn sleep(seconds: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn usleep(usec: useconds_t) -> cty::c_int;
}
extern "C" {
    pub fn pause() -> cty::c_int;
}
extern "C" {
    pub fn nice(inc: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn daemon(nochdir: cty::c_int, noclose: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn close(fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dup(fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dup2(fd1: cty::c_int, fd2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dup3(fd1: cty::c_int, fd2: cty::c_int, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsync(fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lseek(fd: cty::c_int, offset: off_t, whence: cty::c_int) -> off_t;
}
extern "C" {
    pub fn read(fd: cty::c_int, buf: *mut cty::c_void, nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(fd: cty::c_int, buf: *const cty::c_void, nbytes: usize) -> isize;
}
extern "C" {
    pub fn pread(fd: cty::c_int, buf: *mut cty::c_void, nbytes: usize, offset: off_t) -> isize;
}
extern "C" {
    pub fn pwrite(fd: cty::c_int, buf: *const cty::c_void, nbytes: usize, offset: off_t) -> isize;
}
extern "C" {
    pub fn ftruncate(fd: cty::c_int, length: off_t) -> cty::c_int;
}
extern "C" {
    pub fn fchown(fd: cty::c_int, owner: uid_t, group: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn isatty(fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ttyname(fd: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn ttyname_r(fd: cty::c_int, buf: *mut cty::c_char, buflen: usize) -> cty::c_int;
}
extern "C" {
    pub fn pipe2(pipefd: *mut cty::c_int, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn alarm(seconds: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn chdir(path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn fchdir(fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getcwd(buf: *mut cty::c_char, size: usize) -> *mut cty::c_char;
}
extern "C" {
    pub fn access(path: *const cty::c_char, amode: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn faccessat(
        dirfd: cty::c_int,
        path: *const cty::c_char,
        mode: cty::c_int,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn rmdir(pathname: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn unlink(pathname: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn unlinkat(
        dirfd: cty::c_int,
        pathname: *const cty::c_char,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn truncate(path: *const cty::c_char, length: off_t) -> cty::c_int;
}
extern "C" {
    pub fn link(path1: *const cty::c_char, path2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn linkat(
        olddirfd: cty::c_int,
        path1: *const cty::c_char,
        newdirfd: cty::c_int,
        path2: *const cty::c_char,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn symlink(path1: *const cty::c_char, path2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn symlinkat(
        path1: *const cty::c_char,
        dirfd: cty::c_int,
        path2: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn readlink(path: *const cty::c_char, buf: *mut cty::c_char, bufsize: usize) -> isize;
}
extern "C" {
    pub fn readlinkat(
        dirfd: cty::c_int,
        path: *const cty::c_char,
        buf: *mut cty::c_char,
        bufsize: usize,
    ) -> isize;
}
extern "C" {
    pub fn chown(path: *const cty::c_char, owner: uid_t, group: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn lchown(path: *const cty::c_char, owner: uid_t, group: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn fchownat(
        dirfd: cty::c_int,
        path: *const cty::c_char,
        owner: uid_t,
        group: gid_t,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn swab(src: *const cty::c_void, dest: *mut cty::c_void, nbytes: isize);
}
extern "C" {
    pub fn getopt(
        argc: cty::c_int,
        argv: *const *mut cty::c_char,
        optstring: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn getoptargp() -> *mut *mut cty::c_char;
}
extern "C" {
    pub fn getopterrp() -> *mut cty::c_int;
}
extern "C" {
    pub fn getoptindp() -> *mut cty::c_int;
}
extern "C" {
    pub fn getoptoptp() -> *mut cty::c_int;
}
extern "C" {
    pub fn gethostname(name: *mut cty::c_char, namelen: usize) -> cty::c_int;
}
extern "C" {
    pub fn sethostname(name: *const cty::c_char, namelen: usize) -> cty::c_int;
}
extern "C" {
    pub fn sysconf(name: cty::c_int) -> cty::c_long;
}
extern "C" {
    pub fn fpathconf(fildes: cty::c_int, name: cty::c_int) -> cty::c_long;
}
extern "C" {
    pub fn pathconf(path: *const cty::c_char, name: cty::c_int) -> cty::c_long;
}
extern "C" {
    pub fn setuid(uid: uid_t) -> cty::c_int;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn setgid(gid: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn seteuid(uid: uid_t) -> cty::c_int;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn setegid(gid: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn setreuid(ruid: uid_t, euid: uid_t) -> cty::c_int;
}
extern "C" {
    pub fn setregid(rgid: gid_t, egid: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn getentropy(buffer: *mut cty::c_void, length: usize) -> cty::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn syncfs(fd: cty::c_int) -> cty::c_int;
}
pub type pthread_key_t = cty::c_int;
pub type pthread_addr_t = *mut cty::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: pthread_addr_t) -> pthread_addr_t>;
pub type pthread_func_t = pthread_startroutine_t;
pub type pthread_trampoline_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: pthread_startroutine_t, arg2: pthread_addr_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_s {
    pub priority: u8,
    pub policy: u8,
    pub inheritsched: u8,
    pub detachstate: u8,
    pub stackaddr: *mut cty::c_void,
    pub stacksize: usize,
}
pub type pthread_attr_t = pthread_attr_s;
pub type pthread_t = pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_s {
    pub pshared: cty::c_int,
    pub clockid: clockid_t,
}
pub type pthread_condattr_t = pthread_condattr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_s {
    pub sem: sem_t,
    pub clockid: clockid_t,
}
pub type pthread_cond_t = pthread_cond_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_s {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl pthread_mutexattr_s {
    #[inline]
    pub fn pshared(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pshared(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pshared: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pshared: u8 = unsafe { ::core::mem::transmute(pshared) };
            pshared as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type pthread_mutexattr_t = pthread_mutexattr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_s {
    pub flink: *mut pthread_mutex_s,
    pub sem: sem_t,
    pub pid: pid_t,
    pub flags: u8,
}
pub type pthread_mutex_t = pthread_mutex_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr_s {
    pub pshared: cty::c_int,
}
pub type pthread_barrierattr_t = pthread_barrierattr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_s {
    pub sem: sem_t,
    pub count: cty::c_uint,
}
pub type pthread_barrier_t = pthread_barrier_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_s {
    pub done: bool,
    pub mutex: pthread_mutex_t,
}
pub type pthread_once_t = pthread_once_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr_s {
    pub pshared: cty::c_int,
}
pub type pthread_rwlockattr_t = pthread_rwlockattr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_s {
    pub lock: pthread_mutex_t,
    pub cv: pthread_cond_t,
    pub num_readers: cty::c_uint,
    pub num_writers: cty::c_uint,
    pub write_in_progress: bool,
}
pub type pthread_rwlock_t = pthread_rwlock_s;
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn pthread_attr_init(attr: *mut pthread_attr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(attr: *mut pthread_attr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(attr: *mut pthread_attr_t, policy: cty::c_int)
        -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        attr: *const pthread_attr_t,
        policy: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        attr: *mut pthread_attr_t,
        param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        attr: *const pthread_attr_t,
        param: *mut sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        attr: *mut pthread_attr_t,
        inheritsched: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        attr: *const pthread_attr_t,
        inheritsched: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        attr: *const pthread_attr_t,
        detachstate: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        attr: *mut pthread_attr_t,
        detachstate: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        attr: *mut pthread_attr_t,
        stackaddr: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        attr: *const pthread_attr_t,
        stackaddr: *mut *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(attr: *mut pthread_attr_t, stacksize: usize) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        attr: *const pthread_attr_t,
        stacksize: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        attr: *mut pthread_attr_t,
        stackaddr: *mut cty::c_void,
        stacksize: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        attr: *const pthread_attr_t,
        stackaddr: *mut *mut cty::c_void,
        stacksize: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(attr: *mut pthread_attr_t, scope: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(attr: *const pthread_attr_t, scope: *mut cty::c_int)
        -> cty::c_int;
}
extern "C" {
    pub fn pthread_setname_np(thread: pthread_t, name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn pthread_getname_np(thread: pthread_t, name: *mut cty::c_char, len: usize) -> cty::c_int;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(thread: pthread_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn pthread_get_stacksize_np(thread: pthread_t) -> isize;
}
extern "C" {
    pub fn pthread_create(
        thread: *mut pthread_t,
        attr: *const pthread_attr_t,
        startroutine: pthread_startroutine_t,
        arg: pthread_addr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_detach(thread: pthread_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_exit(value: pthread_addr_t) -> !;
}
extern "C" {
    pub fn pthread_cancel(thread: pthread_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(state: cty::c_int, oldstate: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(type_: cty::c_int, oldtype: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_join(thread: pthread_t, value: *mut pthread_addr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_yield();
}
extern "C" {
    pub fn pthread_getschedparam(
        thread: pthread_t,
        policy: *mut cty::c_int,
        param: *mut sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        thread: pthread_t,
        policy: cty::c_int,
        param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(thread: pthread_t, prio: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        key: *mut pthread_key_t,
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setspecific(key: pthread_key_t, value: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn pthread_getspecific(key: pthread_key_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn pthread_key_delete(key: pthread_key_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(attr: *mut pthread_mutexattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        attr: *const pthread_mutexattr_t,
        pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        attr: *mut pthread_mutexattr_t,
        pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        attr: *const pthread_mutexattr_t,
        type_: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        attr: *mut pthread_mutexattr_t,
        type_: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        attr: *const pthread_mutexattr_t,
        protocol: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        attr: *mut pthread_mutexattr_t,
        protocol: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        attr: *const pthread_mutexattr_t,
        robust: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        attr: *mut pthread_mutexattr_t,
        robust: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        mutex: *mut pthread_mutex_t,
        attr: *const pthread_mutexattr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        mutex: *mut pthread_mutex_t,
        abs_timeout: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(attr: *mut pthread_condattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(attr: *mut pthread_condattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        attr: *const pthread_condattr_t,
        pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        attr: *mut pthread_condattr_t,
        pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        attr: *const pthread_condattr_t,
        clock_id: *mut clockid_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        attr: *mut pthread_condattr_t,
        clock_id: clockid_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        cond: *mut pthread_cond_t,
        attr: *const pthread_condattr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(cond: *mut pthread_cond_t, mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_clockwait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(attr: *mut pthread_barrierattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(attr: *mut pthread_barrierattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        attr: *const pthread_barrierattr_t,
        pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        attr: *mut pthread_barrierattr_t,
        pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(barrier: *mut pthread_barrier_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        barrier: *mut pthread_barrier_t,
        attr: *const pthread_barrierattr_t,
        count: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(barrier: *mut pthread_barrier_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_once(
        once_control: *mut pthread_once_t,
        init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(attr: *mut pthread_rwlockattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(attr: *mut pthread_rwlockattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        attr: *const pthread_rwlockattr_t,
        pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        attr: *mut pthread_rwlockattr_t,
        pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(rw_lock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        rw_lock: *mut pthread_rwlock_t,
        attr: *const pthread_rwlockattr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        lock: *mut pthread_rwlock_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        lock: *mut pthread_rwlock_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        lock: *mut pthread_rwlock_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        lock: *mut pthread_rwlock_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_kill(thread: pthread_t, sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        how: cty::c_int,
        set: *const sigset_t,
        oset: *mut sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(thread_id: pthread_t, clock_id: *mut clockid_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        prepare: ::core::option::Option<unsafe extern "C" fn()>,
        parent: ::core::option::Option<unsafe extern "C" fn()>,
        child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> cty::c_int;
}
extern "C" {
    pub fn up_get_icache_linesize() -> usize;
}
extern "C" {
    pub fn up_get_icache_size() -> usize;
}
extern "C" {
    pub fn up_enable_icache();
}
extern "C" {
    pub fn up_disable_icache();
}
extern "C" {
    pub fn up_invalidate_icache(start: usize, end: usize);
}
extern "C" {
    pub fn up_invalidate_icache_all();
}
extern "C" {
    pub fn up_get_dcache_linesize() -> usize;
}
extern "C" {
    pub fn up_get_dcache_size() -> usize;
}
extern "C" {
    pub fn up_enable_dcache();
}
extern "C" {
    pub fn up_disable_dcache();
}
extern "C" {
    pub fn up_invalidate_dcache(start: usize, end: usize);
}
extern "C" {
    pub fn up_invalidate_dcache_all();
}
extern "C" {
    pub fn up_clean_dcache(start: usize, end: usize);
}
extern "C" {
    pub fn up_clean_dcache_all();
}
extern "C" {
    pub fn up_flush_dcache(start: usize, end: usize);
}
extern "C" {
    pub fn up_flush_dcache_all();
}
extern "C" {
    pub fn up_coherent_dcache(addr: usize, len: usize);
}
pub const tstate_e_TSTATE_TASK_INVALID: tstate_e = 0;
pub const tstate_e_TSTATE_TASK_PENDING: tstate_e = 1;
pub const tstate_e_TSTATE_TASK_READYTORUN: tstate_e = 2;
pub const tstate_e_TSTATE_TASK_RUNNING: tstate_e = 3;
pub const tstate_e_TSTATE_TASK_INACTIVE: tstate_e = 4;
pub const tstate_e_TSTATE_WAIT_SEM: tstate_e = 5;
pub const tstate_e_TSTATE_WAIT_SIG: tstate_e = 6;
pub const tstate_e_TSTATE_WAIT_MQNOTEMPTY: tstate_e = 7;
pub const tstate_e_TSTATE_WAIT_MQNOTFULL: tstate_e = 8;
pub const tstate_e_NUM_TASK_STATES: tstate_e = 9;
pub type tstate_e = cty::c_uint;
pub use self::tstate_e as tstate_t;
pub type start_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union entry_u {
    pub pthread: pthread_startroutine_t,
    pub main: main_t,
}
pub type entry_t = entry_u;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stackinfo_s {
    pub adj_stack_size: usize,
    pub stack_alloc_ptr: *mut cty::c_void,
    pub stack_base_ptr: *mut cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_info_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct join_s {
    _unused: [u8; 0],
}
#[doc = " Forward declarations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_group_s {
    pub flink: *mut task_group_s,
    pub tg_pid: pid_t,
    pub tg_ppid: pid_t,
    pub tg_flags: u8,
    pub tg_nmembers: u8,
    pub tg_mxmembers: u8,
    pub tg_members: *mut pid_t,
    pub tg_nwaiters: u8,
    pub tg_waitflags: u8,
    pub tg_exitsem: sem_t,
    pub tg_statloc: *mut cty::c_int,
    pub tg_joinlock: mutex_t,
    pub tg_joinhead: *mut join_s,
    pub tg_jointail: *mut join_s,
    pub tg_info: *mut task_info_s,
    pub tg_sigactionq: sq_queue_t,
    pub tg_sigpendingq: sq_queue_t,
    pub tg_envp: *mut *mut cty::c_char,
    pub tg_envc: isize,
    pub itimer: timer_t,
    pub tg_filelist: filelist,
    pub tg_mm_map: mm_map_s,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcb_s {
    pub flink: *mut tcb_s,
    pub blink: *mut tcb_s,
    pub group: *mut task_group_s,
    pub pid: pid_t,
    pub sched_priority: u8,
    pub init_priority: u8,
    pub start: start_t,
    pub entry: entry_t,
    pub task_state: u8,
    pub flags: u16,
    pub lockcount: i16,
    pub errcode: i16,
    pub timeslice: i32,
    pub waitdog: wdog_s,
    pub adj_stack_size: usize,
    pub stack_alloc_ptr: *mut cty::c_void,
    pub stack_base_ptr: *mut cty::c_void,
    pub waitobj: *mut cty::c_void,
    pub sigprocmask: sigset_t,
    pub sigwaitmask: sigset_t,
    pub sigpendactionq: sq_queue_t,
    pub sigpostedq: sq_queue_t,
    pub sigunbinfo: siginfo_t,
    pub mhead: *mut pthread_mutex_s,
    pub xcp: xcptcontext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_tcb_s {
    pub cmn: tcb_s,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_tcb_s {
    pub cmn: tcb_s,
    pub trampoline: pthread_trampoline_t,
    pub arg: pthread_addr_t,
    pub joininfo: *mut cty::c_void,
    pub join_complete: bool,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tcbinfo_s {
    pub pid_off: u16,
    pub state_off: u16,
    pub pri_off: u16,
    pub name_off: u16,
    pub stack_off: u16,
    pub stack_size_off: u16,
    pub regs_off: u16,
    pub regs_num: u16,
    pub reg_off: tcbinfo_s__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tcbinfo_s__bindgen_ty_1 {
    pub u: [u8; 8usize],
    pub p: *const u16,
}
pub type nxsched_foreach_t =
    ::core::option::Option<unsafe extern "C" fn(tcb: *mut tcb_s, arg: *mut cty::c_void)>;
extern "C" {
    pub static g_tcbinfo: tcbinfo_s;
}
extern "C" {
    #[doc = " Name: nxsched_self\n\n Description:\n   Return the current threads TCB.  Basically, this function just wraps the\n   head of the ready-to-run list and manages access to the TCB from outside\n   of the sched/ sub-directory.\n"]
    pub fn nxsched_self() -> *mut tcb_s;
}
extern "C" {
    #[doc = " Name: nxsched_foreach\n\n Description:\n   Enumerate over each task and provide the TCB of each task to a user\n   callback functions.\n\n   NOTE:  This function examines the TCB and calls each handler within a\n   critical section.  However, that critical section is released and\n   reacquired for each TCB.  When it is released, there may be changes in\n   tasking.  If the caller requires absolute stability through the\n   traversal, then the caller should establish the critical section BEFORE\n   calling this function.\n\n Input Parameters:\n   handler - The function to be called with the TCB of\n     each task\n\n Returned Value:\n   None\n"]
    pub fn nxsched_foreach(handler: nxsched_foreach_t, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " Name: nxsched_get_tcb\n\n Description:\n   Given a task ID, this function will return the a pointer to the\n   corresponding TCB (or NULL if there is no such task ID).\n\n   NOTE:  This function holds a critical section while examining TCB data\n   data structures but releases that critical section before returning.\n   When it is released, the TCB may become unstable.  If the caller\n   requires absolute stability while using the TCB, then the caller\n   should establish the critical section BEFORE calling this function and\n   hold that critical section as long as necessary.\n"]
    pub fn nxsched_get_tcb(pid: pid_t) -> *mut tcb_s;
}
extern "C" {
    #[doc = " Name:  nxsched_releasepid\n\n Description:\n   When a task is destroyed, this function must be called to make its\n   process ID available for re-use.\n"]
    pub fn nxsched_release_tcb(tcb: *mut tcb_s, ttype: u8) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsched_get_files_from_tcb\n\n Description:\n   Return a pointer to the file list from task context\n\n Input Parameters:\n   tcb - Address of the new task's TCB\n\n Returned Value:\n   A pointer to the errno.\n\n Assumptions:\n"]
    pub fn nxsched_get_files_from_tcb(tcb: *mut tcb_s) -> *mut filelist;
}
extern "C" {
    #[doc = " Name: nxsched_get_files\n\n Description:\n   Return a pointer to the file list for this thread\n\n Input Parameters:\n   None\n\n Returned Value:\n   A pointer to the errno.\n\n Assumptions:\n"]
    pub fn nxsched_get_files() -> *mut filelist;
}
extern "C" {
    #[doc = " Name: nxtask_init\n\n Description:\n   This function initializes a Task Control Block (TCB) in preparation for\n   starting a new thread.  It performs a subset of the functionality of\n   task_create()\n\n   Unlike task_create():\n     1. Allocate the TCB.  The pre-allocated TCB is passed in argv.\n     2. Allocate the stack.  The pre-allocated stack is passed in argv.\n     3. Activate the task. This must be done by calling nxtask_activate().\n\n   Certain fields of the pre-allocated TCB may be set to change the\n   nature of the created task.  For example:\n\n     - Task type may be set in the TCB flags to create kernel thread\n\n Input Parameters:\n   tcb        - Address of the new task's TCB\n   name       - Name of the new task (not used)\n   priority   - Priority of the new task\n   stack      - Start of the pre-allocated stack\n   stack_size - Size (in bytes) of the stack allocated\n   entry      - Application start point of the new task\n   argv       - A pointer to an array of input parameters.  The array\n                should be terminated with a NULL argv[] value. If no\n                parameters are required, argv may be NULL.\n   envp       - A pointer to the program's environment, envp may be NULL\n\n Returned Value:\n   OK on success; negative error value on failure appropriately.  (See\n   nxtask_setup_scheduler() for possible failure conditions).  On failure,\n   the caller is responsible for freeing the stack memory and for calling\n   nxsched_release_tcb() to free the TCB (which could be in most any\n   state).\n"]
    pub fn nxtask_init(
        tcb: *mut task_tcb_s,
        name: *const cty::c_char,
        priority: cty::c_int,
        stack: *mut cty::c_void,
        stack_size: u32,
        entry: main_t,
        argv: *const *mut cty::c_char,
        envp: *const *mut cty::c_char,
        actions: *const posix_spawn_file_actions_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxtask_uninit\n\n Description:\n   Undo all operations on a TCB performed by task_init() and release the\n   TCB by calling kmm_free().  This is intended primarily to support\n   error recovery operations after a successful call to task_init() such\n   was when a subsequent call to task_activate fails.\n\n   Caution:  Freeing of the TCB itself might be an unexpected side-effect.\n\n Input Parameters:\n   tcb - Address of the TCB initialized by task_init()\n\n Returned Value:\n   OK on success; negative error value on failure appropriately.\n"]
    pub fn nxtask_uninit(tcb: *mut task_tcb_s);
}
extern "C" {
    #[doc = " Name: nxtask_create\n\n Description:\n   This function creates and activates a new user task with a specified\n   priority and returns its system-assigned ID.\n\n   The entry address entry is the address of the \"main\" function of the\n   task.  This function will be called once the C environment has been\n   set up.  The specified function will be called with four arguments.\n   Should the specified routine return, a call to exit() will\n   automatically be made.\n\n   Note that four (and only four) arguments must be passed for the spawned\n   functions.\n\n   nxtask_create() is identical to the function task_create(), differing\n   only in its return value:  This function does not modify the errno\n   variable.  This is a non-standard, internal OS function and is not\n   intended for use by application logic.  Applications should use\n   task_create().\n\n Input Parameters:\n   name       - Name of the new task\n   priority   - Priority of the new task\n   stack_size - size (in bytes) of the stack needed\n   entry      - Entry point of a new task\n   arg        - A pointer to an array of input parameters.  The array\n                should be terminated with a NULL argv[] value. If no\n                parameters are required, argv may be NULL.\n   envp       - A pointer to an array of environment strings. Terminated\n                with a NULL entry.\n\n Returned Value:\n   Returns the positive, non-zero process ID of the new task or a negated\n   errno value to indicate the nature of any failure.  If memory is\n   insufficient or the task cannot be created -ENOMEM will be returned.\n"]
    pub fn nxtask_create(
        name: *const cty::c_char,
        priority: cty::c_int,
        stack_addr: *mut cty::c_void,
        stack_size: cty::c_int,
        entry: main_t,
        argv: *const *mut cty::c_char,
        envp: *const *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxtask_delete\n\n Description:\n   This function causes a specified task to cease to exist.  Its stack and\n   TCB will be deallocated.\n\n   The logic in this function only deletes non-running tasks.  If the\n   'pid' parameter refers to the currently running task, then processing\n   is redirected to exit(). This can only happen if a task calls\n   nxtask_delete() in order to delete itself.\n\n   This function obeys the semantics of pthread cancellation:  task\n   deletion is deferred if cancellation is disabled or if deferred\n   cancellation is supported (with cancellation points enabled).\n\n Input Parameters:\n   pid - The task ID of the task to delete.  A pid of zero\n         signifies the calling task.\n\n Returned Value:\n   OK on success; or negated errno on failure\n"]
    pub fn nxtask_delete(pid: pid_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxtask_activate\n\n Description:\n   This function activates tasks initialized by nxtask_setup_scheduler().\n   Without activation, a task is ineligible for execution by the\n   scheduler.\n\n Input Parameters:\n   tcb - The TCB for the task (same as the nxtask_init argument).\n\n Returned Value:\n   None\n"]
    pub fn nxtask_activate(tcb: *mut tcb_s);
}
extern "C" {
    pub fn nxtask_startup(entrypt: main_t, argc: cty::c_int, argv: *mut *mut cty::c_char);
}
extern "C" {
    #[doc = " Internal fork support.  The overall sequence is:\n\n 1) User code calls fork().  fork() is provided in architecture-specific\n    code.\n 2) fork()and calls nxtask_setup_fork().\n 3) nxtask_setup_fork() allocates and configures the child task's TCB.\n    This consists of:\n    - Allocation of the child task's TCB.\n    - Initialization of file descriptors and streams\n    - Configuration of environment variables\n    - Allocate and initialize the stack\n    - Setup the input parameters for the task.\n    - Initialization of the TCB (including call to up_initial_state())\n 4) fork() provides any additional operating context. fork must:\n    - Initialize special values in any CPU registers that were not\n      already configured by up_initial_state()\n 5) fork() then calls nxtask_start_fork()\n 6) nxtask_start_fork() then executes the child thread.\n\n nxtask_abort_fork() may be called if an error occurs between\n steps 3 and 6.\n"]
    pub fn nxtask_setup_fork(retaddr: start_t) -> *mut task_tcb_s;
}
extern "C" {
    pub fn nxtask_start_fork(child: *mut task_tcb_s) -> pid_t;
}
extern "C" {
    pub fn nxtask_abort_fork(child: *mut task_tcb_s, errcode: cty::c_int);
}
extern "C" {
    #[doc = " Name: group_argvstr\n\n Description:\n   Safely read the contents of a task's argument vector, into a a safe\n   buffer. Function skips the process's name.\n\n Input Parameters:\n   tcb  - tcb of the task.\n   args - Output buffer for the argument vector.\n   size - Size of the buffer.\n\n Returned Value:\n   The actual string length that was written.\n"]
    pub fn group_argvstr(tcb: *mut tcb_s, args: *mut cty::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn nxsched_resume_scheduler(tcb: *mut tcb_s);
}
extern "C" {
    #[doc = " Name: nxsched_get_param\n\n Description:\n   This function gets the scheduling priority of the task specified by\n   pid.  It is identical in function, differing only in its return value:\n   This function does not modify the errno variable.\n\n   This is a non-standard, internal OS function and is not intended for\n   use by application logic.  Applications should use the standard\n   sched_getparam().\n\n Input Parameters:\n   pid - the task ID of the task.  If pid is zero, the priority\n     of the calling task is returned.\n   param - A structure whose member sched_priority is the integer\n     priority.  The task's priority is copied to the sched_priority\n     element of this structure.\n\n Returned Value:\n   0 (OK) if successful, otherwise a negated errno value is returned to\n   indicate the nature of the failure..\n\n   This function can fail if param is null (EINVAL) or if pid does\n   not correspond to any task (ESRCH).\n"]
    pub fn nxsched_get_param(pid: pid_t, param: *mut sched_param) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  nxsched_set_param\n\n Description:\n   This function sets the priority of a specified task.  It is identical\n   to the function sched_setparam(), differing only in its return value:\n   This function does not modify the errno variable.\n\n   NOTE: Setting a task's priority to the same value has a similar effect\n   to sched_yield() -- The task will be moved to  after all other tasks\n   with the same priority.\n\n   This is a non-standard, internal OS function and is not intended for\n   use by application logic.  Applications should use the standard\n   sched_setparam().\n\n Input Parameters:\n   pid - the task ID of the task to reprioritize.  If pid is zero, the\n      priority of the calling task is changed.\n   param - A structure whose member sched_priority is the integer priority.\n      The range of valid priority numbers is from SCHED_PRIORITY_MIN\n      through SCHED_PRIORITY_MAX.\n\n Returned Value:\n   0 (OK) if successful, otherwise a negated errno value is returned to\n   indicate the nature of the failure..\n\n   EINVAL The parameter 'param' is invalid or does not make sense for the\n          current scheduling policy.\n   EPERM  The calling task does not have appropriate privileges.\n   ESRCH  The task whose ID is pid could not be found.\n"]
    pub fn nxsched_set_param(pid: pid_t, param: *const sched_param) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsched_get_scheduler\n\n Description:\n   sched_getscheduler() returns the scheduling policy currently\n   applied to the task identified by pid.  If pid equals zero, the\n   policy of the calling task will be retrieved.\n\n   This functions is identical to the function sched_getscheduler(),\n   differing only in its return value:  This function does not modify\n   the errno variable.\n\n   This is a non-standard, internal OS function and is not intended for\n   use by application logic.  Applications should use the standard\n   sched_getscheduler().\n\n Input Parameters:\n   pid - the task ID of the task to query.  If pid is zero, the\n     calling task is queried.\n\n Returned Value:\n    On success, sched_getscheduler() returns the policy for the task\n    (either SCHED_FIFO or SCHED_RR).  On error,  a negated errno value\n    returned:\n\n      ESRCH  The task whose ID is pid could not be found.\n"]
    pub fn nxsched_get_scheduler(pid: pid_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsched_set_scheduler\n\n Description:\n   nxsched_set_scheduler() sets both the scheduling policy and the priority\n   for the task identified by pid. If pid equals zero, the scheduler of\n   the calling task will be set.  The parameter 'param' holds the priority\n   of the thread under the new policy.\n\n   nxsched_set_scheduler() is identical to the function sched_getparam(),\n   differing only in its return value:  This function does not modify the\n    errno variable.\n\n   This is a non-standard, internal OS function and is not intended for\n   use by application logic.  Applications should use the standard\n   sched_getparam().\n\n Input Parameters:\n   pid - the task ID of the task to modify.  If pid is zero, the calling\n      task is modified.\n   policy - Scheduling policy requested (either SCHED_FIFO or SCHED_RR)\n   param - A structure whose member sched_priority is the new priority.\n      The range of valid priority numbers is from SCHED_PRIORITY_MIN\n      through SCHED_PRIORITY_MAX.\n\n Returned Value:\n   On success, nxsched_set_scheduler() returns OK (zero).  On error, a\n   negated errno value is returned:\n\n   EINVAL The scheduling policy is not one of the recognized policies.\n   ESRCH  The task whose ID is pid could not be found.\n"]
    pub fn nxsched_set_scheduler(
        pid: pid_t,
        policy: cty::c_int,
        param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsched_get_stackinfo\n\n Description:\n   Report information about a thread's stack allocation.\n\n Input Parameters:\n   pid       - Identifies the thread to query.  Zero is interpreted as the\n               the calling thread, -1 is interpreted as the calling task.\n   stackinfo - User-provided location to return the stack information.\n\n Returned Value:\n   Zero (OK) if successful.  Otherwise, a negated errno value is returned.\n\n     -ENOENT  Returned if pid does not refer to an active task\n     -EACCES  The calling thread does not have privileges to access the\n              stack of the thread associated with the pid.\n"]
    pub fn nxsched_get_stackinfo(pid: pid_t, stackinfo: *mut stackinfo_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsched_get_stateinfo\n\n Description:\n   Report information about a thread's state\n\n Input Parameters:\n   tcb    - The TCB for the task (same as the nxtask_init argument).\n   state  - User-provided location to return the state information.\n   length - The size of the state\n"]
    pub fn nxsched_get_stateinfo(tcb: *mut tcb_s, state: *mut cty::c_char, length: usize);
}
extern "C" {
    pub fn nxsched_waitpid(pid: pid_t, stat_loc: *mut cty::c_int, options: cty::c_int) -> pid_t;
}
extern "C" {
    #[doc = " Name: nxsched_gettid\n\n Description:\n   Get the thread ID of the currently executing thread.\n\n Input parameters:\n   None\n\n Returned Value:\n   On success, returns the thread ID of the calling process.\n"]
    pub fn nxsched_gettid() -> pid_t;
}
extern "C" {
    #[doc = " Name: nxsched_getpid\n\n Description:\n   Get the Process ID of the currently executing task.\n\n Input parameters:\n   None\n\n Returned Value:\n   Normally when called from user applications, nxsched_getpid() will\n   return the Process ID of the currently executing task. that is,\n   the main task for the task groups. There is no specification for\n   any errors returned from nxsched_getpid().\n"]
    pub fn nxsched_getpid() -> pid_t;
}
extern "C" {
    #[doc = " Name: nxsched_getppid\n\n Description:\n   Get the parent task ID of the currently executing task.\n\n Input parameters:\n   None\n\n Returned Value:\n   Normally when called from user applications, nxsched_getppid() will\n   return the parent task ID of the currently executing task, that is,\n   the task at the head of the ready-to-run list.\n   There is no specification for any errors returned from\n   nxsched_getppid().\n\n   nxsched_getppid(), however, may be called from within the OS in some\n   cases. There are certain situations during context switching when the\n   OS data structures are in flux and where the current task at the head\n   of the ready-to-run task list is not actually running.\n   In that case, nxsched_getppid() will return the error: -ESRCH\n"]
    pub fn nxsched_getppid() -> pid_t;
}
extern "C" {
    #[doc = " Name: nxsched_collect_deadlock\n\n Description:\n   Check if there is a deadlock and get the thread pid of the deadlock.\n\n Input parameters:\n   pid   - The array to store the thread pid of the deadlock.\n   count - The size of the pid array.\n\n Returned Value:\n   The number of thread deadlocks.\n"]
    pub fn nxsched_collect_deadlock(pid: *mut pid_t, count: usize) -> usize;
}
#[doc = " Public Types"]
pub type sig_deliver_t = ::core::option::Option<unsafe extern "C" fn(tcb: *mut tcb_s)>;
pub type phy_enable_t = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
pub type initializer_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type debug_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: cty::c_int,
        addr: *mut cty::c_void,
        size: usize,
        arg: *mut cty::c_void,
    ),
>;
extern "C" {
    pub static mut _sinit: [initializer_t; 0usize];
}
extern "C" {
    pub static mut _einit: [initializer_t; 0usize];
}
extern "C" {
    #[doc = " Name: up_fork\n\n Description:\n   The up_fork() function is the base of fork() function that provided in\n   libc, and fork() is implemented as a wrapper of up_fork() function.\n\n Returned Value:\n   Upon successful completion, up_fork() returns 0 to the child process\n   and returns the process ID of the child process to the parent process.\n   Otherwise, -1 is returned to the parent, no child process is created,\n   and errno is set to indicate the error.\n"]
    pub fn up_fork() -> pid_t;
}
extern "C" {
    #[doc = " Name: up_initialize\n\n Description:\n   up_initialize will be called once during OS initialization after the\n   basic OS services have been initialized.  The architecture specific\n   details of initializing the OS will be handled here.  Such things as\n   setting up interrupt service routines, starting the clock, and\n   registering device drivers are some of the things that are different\n   for each processor and hardware platform.\n\n   up_initialize is called after the OS initialized but before the initial\n   application has been started and before the libraries have been\n   initialized. OS services and driver services are available.\n"]
    pub fn up_initialize();
}
extern "C" {
    #[doc = " Name: up_systemreset\n\n Description:\n   The function up_systemreset() will reset the MCU.  Optional!\n   Availability of this function is dependent upon the architecture\n   support.\n"]
    pub fn up_systemreset() -> !;
}
extern "C" {
    #[doc = " Name: up_idle\n\n Description:\n   up_idle() is the logic that will be executed when there is no other\n   ready-to-run task.  This is processor idle time and will continue until\n   some interrupt occurs to cause a context switch from the idle task.\n\n   Processing in this state may be processor-specific. e.g.,\n   this is where power management operations might be performed.\n"]
    pub fn up_idle();
}
extern "C" {
    #[doc = " Name: up_initial_state\n\n Description:\n   A new thread is being started and a new TCB has been created.\n   This function is called to initialize the processor specific portions\n   of the new TCB.\n\n   This function must setup the initial architecture registers and/or\n   stack so that execution will begin at tcb->start on the next context\n   switch.\n"]
    pub fn up_initial_state(tcb: *mut tcb_s);
}
extern "C" {
    #[doc = " Name: up_create_stack\n\n Description:\n   Allocate a stack for a new thread and setup up stack-related information\n   in the TCB.\n\n   The following TCB fields must be initialized by this function:\n\n   - adj_stack_size: Stack size after adjustment for hardware, processor,\n     etc.  This value is retained only for debug purposes.\n   - stack_alloc_ptr: Pointer to allocated stack\n   - stack_base_ptr: Adjusted stack base pointer after the TLS Data and\n     Arguments has been removed from the stack allocation.\n\n Input Parameters:\n   - tcb: The TCB of new task\n   - stack_size:  The requested stack size.  At least this much\n     must be allocated.\n   - ttype:  The thread type.  This may be one of following (defined in\n     include/nuttx/sched.h):\n\n       TCB_FLAG_TTYPE_TASK     Normal user task\n       TCB_FLAG_TTYPE_PTHREAD  User pthread\n       TCB_FLAG_TTYPE_KERNEL   Kernel thread\n\n     This thread type is normally available in the flags field of the TCB,\n     however, there are certain contexts where the TCB may not be fully\n     initialized when up_create_stack is called.\n\n     If CONFIG_BUILD_PROTECTED or CONFIG_BUILD_KERNEL are is defined, then\n     this thread type may affect how the stack is allocated.  For example,\n     kernel thread stacks should be allocated from protected kernel memory.\n     Stacks for user tasks and threads must come from memory that is\n     accessible to user code.\n"]
    pub fn up_create_stack(tcb: *mut tcb_s, stack_size: usize, ttype: u8) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_use_stack\n\n Description:\n   Setup stack-related information in the TCB using pre-allocated stack\n   memory.  This function is called only from nxtask_init() when a task or\n   kernel thread is started (never for pthreads).\n\n   The following TCB fields must be initialized:\n\n   - adj_stack_size: Stack size after adjustment for hardware,\n     processor, etc.  This value is retained only for debug\n     purposes.\n   - stack_alloc_ptr: Pointer to allocated stack\n   - stack_base_ptr: Adjusted stack base pointer after the TLS Data and\n     Arguments has been removed from the stack allocation.\n\n Input Parameters:\n   - tcb:  The TCB of new task\n   - stack:  The new stack to be used.\n   - stack_size:  The allocated stack size.\n\n   NOTE:  Unlike up_stack_create() and up_stack_release, this function\n   does not require the task type (ttype) parameter.  The TCB flags will\n   always be set to provide the task type to up_use_stack() if it needs\n   that information.\n"]
    pub fn up_use_stack(tcb: *mut tcb_s, stack: *mut cty::c_void, stack_size: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_stack_frame\n\n Description:\n   Allocate a stack frame in the TCB's stack to hold thread-specific data.\n   This function may be called any time after up_create_stack() or\n   up_use_stack() have been called but before the task has been started.\n\n   Thread data may be kept in the stack (instead of in the TCB) if it is\n   accessed by the user code directly.  This includes such things as\n   argv[].  The stack memory is guaranteed to be in the same protection\n   domain as the thread.\n\n   The following TCB fields will be re-initialized:\n\n   - adj_stack_size: Stack size after removal of the stack frame from\n     the stack\n   - stack_base_ptr: Adjusted stack base pointer after the TLS Data and\n     Arguments has been removed from the stack allocation.\n\n   Here is the diagram after some allocation(tls, arg):\n\n                   +-------------+ <-stack_alloc_ptr(lowest)\n                   |  TLS Data   |\n                   +-------------+\n                   |  Arguments  |\n  stack_base_ptr-> +-------------+\\\n                   |  Available  | +\n                   |    Stack    | |\n                |  |             | |\n                |  |             | +->adj_stack_size\n                v  |             | |\n                   |             | |\n                   |             | +\n                   +-------------+/\n\n Input Parameters:\n   - tcb:  The TCB of new task\n   - frame_size:  The size of the stack frame to allocate.\n\n  Returned Value:\n   - A pointer to bottom of the allocated stack frame.  NULL will be\n     returned on any failures.  The alignment of the returned value is\n     the same as the alignment of the stack itself.\n"]
    pub fn up_stack_frame(tcb: *mut tcb_s, frame_size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Name: up_release_stack\n\n Description:\n   A task has been stopped. Free all stack related resources retained in\n   the defunct TCB.\n\n Input Parameters:\n   - dtcb:  The TCB containing information about the stack to be released\n   - ttype:  The thread type.  This may be one of following (defined in\n     include/nuttx/sched.h):\n\n       TCB_FLAG_TTYPE_TASK     Normal user task\n       TCB_FLAG_TTYPE_PTHREAD  User pthread\n       TCB_FLAG_TTYPE_KERNEL   Kernel thread\n\n     This thread type is normally available in the flags field of the TCB,\n     however, there are certain error recovery contexts where the TCB may\n     not be fully initialized when up_release_stack is called.\n\n     If CONFIG_BUILD_PROTECTED or CONFIG_BUILD_KERNEL are defined, then\n     this thread type may affect how the stack is freed.  For example,\n     kernel thread stacks may have been allocated from protected kernel\n     memory.  Stacks for user tasks and threads must have come from memory\n     that is accessible to user code.\n\n Returned Value:\n   None\n"]
    pub fn up_release_stack(dtcb: *mut tcb_s, ttype: u8);
}
extern "C" {
    #[doc = " Name: up_switch_context\n\n Description:\n   A task is currently in the ready-to-run list but has been prepped\n   to execute. Restore its context, and start execution.\n\n   This function is called only from the NuttX scheduling\n   logic.  Interrupts will always be disabled when this\n   function is called.\n\n Input Parameters:\n   tcb: Refers to the head task of the ready-to-run list\n     which will be executed.\n   rtcb: Refers to the running task which will be blocked.\n"]
    pub fn up_switch_context(tcb: *mut tcb_s, rtcb: *mut tcb_s);
}
extern "C" {
    #[doc = " Name: up_exit\n\n Description:\n   This function causes the currently executing task to cease\n   to exist.  This is a special case of task_delete() where the task to\n   be deleted is the currently executing task.  It is more complex because\n   a context switch must be perform to the next ready to run task.\n\n   Unlike other UP APIs, this function may be called directly from user\n   programs in various states.  The implementation of this function should\n   disable interrupts before performing scheduling operations.\n"]
    pub fn up_exit(status: cty::c_int) -> !;
}
extern "C" {
    #[doc = " Name: up_dump_register\n\n Description:\n   Register dump may be handled in an architecture-specific way.\n"]
    pub fn up_dump_register(regs: *mut cty::c_void);
}
extern "C" {
    #[doc = " Name: up_backtrace\n\n Description:\n  up_backtrace()  returns  a backtrace for the TCB, in the array\n  pointed to by buffer.  A backtrace is the series of currently active\n  function calls for the program.  Each item in the array pointed to by\n  buffer is of type void *, and is the return address from the\n  corresponding stack frame.  The size argument specifies the maximum\n  number of addresses that can be stored in buffer.   If  the backtrace is\n  larger than size, then the addresses corresponding to the size most\n  recent function calls are returned; to obtain the complete backtrace,\n  make sure that buffer and size are large enough.\n\n Input Parameters:\n   tcb    - Address of the task's TCB, NULL means dump the running task\n   buffer - Return address from the corresponding stack frame\n   size   - Maximum number of addresses that can be stored in buffer\n   skip   - number of addresses to be skipped\n\n Returned Value:\n   up_backtrace() returns the number of addresses returned in buffer\n"]
    pub fn up_backtrace(
        tcb: *mut tcb_s,
        buffer: *mut *mut cty::c_void,
        size: cty::c_int,
        skip: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_schedule_sigaction\n\n Description:\n   This function is called by the OS when one or more\n   signal handling actions have been queued for execution.\n   The architecture specific code must configure things so\n   that the 'sigdeliver' callback is executed on the thread\n   specified by 'tcb' as soon as possible.\n\n   This function may be called from interrupt handling logic.\n\n   This operation should not cause the task to be unblocked\n   nor should it cause any immediate execution of sigdeliver.\n   Typically, a few cases need to be considered:\n\n   (1) This function may be called from an interrupt handler\n       During interrupt processing, all xcptcontext structures\n       should be valid for all tasks.  That structure should\n       be modified to invoke sigdeliver() either on return\n       from (this) interrupt or on some subsequent context\n       switch to the recipient task.\n   (2) If not in an interrupt handler and the tcb is NOT\n       the currently executing task, then again just modify\n       the saved xcptcontext structure for the recipient\n       task so it will invoke sigdeliver when that task is\n       later resumed.\n   (3) If not in an interrupt handler and the tcb IS the\n       currently executing task -- just call the signal\n       handler now.\n"]
    pub fn up_schedule_sigaction(tcb: *mut tcb_s, sigdeliver: sig_deliver_t);
}
extern "C" {
    #[doc = " Name: up_allocate_heap\n\n Description:\n   This function will be called to dynamically set aside the heap region.\n\n   For the kernel build (CONFIG_BUILD_PROTECTED=y) with both kernel- and\n   user-space heaps (CONFIG_MM_KERNEL_HEAP=y), this function provides the\n   size of the unprotected, user-space heap.\n\n   If a protected kernel-space heap is provided, the kernel heap must be\n   allocated (and protected) by an analogous up_allocate_kheap().\n"]
    pub fn up_allocate_heap(heap_start: *mut *mut cty::c_void, heap_size: *mut usize);
}
extern "C" {
    #[doc = " Name: up_addrenv_pa_to_va\n\n Description:\n   Map phy address to virtual address.  Not supported by all architectures.\n\n   REVISIT:  Should this not then be conditional on having that\n   architecture-specific support?\n\n Input Parameters:\n   pa - The phy address to be mapped.\n\n Returned Value:\n   Virtual address on success; NULL on failure.\n"]
    pub fn up_addrenv_pa_to_va(pa: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Name: up_addrenv_va_to_pa\n\n Description:\n   Map virtual address to phy address.  Not supported by all architectures.\n\n   REVISIT:  Should this not then be conditional on having that\n   architecture-specific support?\n\n Input Parameters:\n   va - The virtual address to be mapped.  Not supported by all\n        architectures.\n\n Returned Value:\n   Phy address on success; NULL on failure.\n"]
    pub fn up_addrenv_va_to_pa(va: *mut cty::c_void) -> usize;
}
extern "C" {
    #[doc = " Name: up_irqinitialize"]
    pub fn up_irqinitialize();
}
extern "C" {
    pub fn up_enable_irq(irq: cty::c_int);
}
extern "C" {
    pub fn up_disable_irq(irq: cty::c_int);
}
extern "C" {
    pub fn up_trigger_irq(irq: cty::c_int, cpuset: cpu_set_t);
}
extern "C" {
    #[doc = " Function:  up_timer_initialize\n\n Description:\n   This function is called during start-up to initialize\n   the timer hardware.\n"]
    pub fn up_timer_initialize();
}
extern "C" {
    #[doc = " Name: up_getusrsp\n\n Input Parameters:\n   regs - regs to get sp\n\n Returned Value:\n   User stack pointer.\n"]
    pub fn up_getusrsp(regs: *mut cty::c_void) -> usize;
}
extern "C" {
    pub fn up_fetchadd32(addr: *mut i32, value: i32) -> i32;
}
extern "C" {
    pub fn up_fetchadd16(addr: *mut i16, value: i16) -> i16;
}
extern "C" {
    pub fn up_fetchadd8(addr: *mut i8, value: i8) -> i8;
}
extern "C" {
    pub fn up_fetchsub32(addr: *mut i32, value: i32) -> i32;
}
extern "C" {
    pub fn up_fetchsub16(addr: *mut i16, value: i16) -> i16;
}
extern "C" {
    pub fn up_fetchsub8(addr: *mut i8, value: i8) -> i8;
}
extern "C" {
    #[doc = " Name: up_cpu_idlestack\n\n Description:\n   Allocate a stack for the CPU[n] IDLE task (n > 0) if appropriate and\n   setup up stack-related information in the IDLE task's TCB.  This\n   function is always called before up_cpu_start().  This function is\n   only called for the CPU's initial IDLE task; up_create_task is used for\n   all normal tasks, pthreads, and kernel threads for all CPUs.\n\n   The initial IDLE task is a special case because the CPUs can be started\n   in different wans in different environments:\n\n   1. The CPU may already have been started and waiting in a low power\n      state for up_cpu_start().  In this case, the IDLE thread's stack\n      has already been allocated and is already in use.  Here\n      up_cpu_idlestack() only has to provide information about the\n      already allocated stack.\n\n   2. The CPU may be disabled but started when up_cpu_start() is called.\n      In this case, a new stack will need to be created for the IDLE\n      thread and this function is then equivalent to:\n\n      return up_create_stack(tcb, stack_size, TCB_FLAG_TTYPE_KERNEL);\n\n   The following TCB fields must be initialized by this function:\n\n   - adj_stack_size: Stack size after adjustment for hardware, processor,\n     etc.  This value is retained only for debug purposes.\n   - stack_alloc_ptr: Pointer to allocated stack\n   - stack_base_ptr: Adjusted stack base pointer after the TLS Data and\n     Arguments has been removed from the stack allocation.\n\n Input Parameters:\n   - cpu:         CPU index that indicates which CPU the IDLE task is\n                  being created for.\n   - tcb:         The TCB of new CPU IDLE task\n   - stack_size:  The requested stack size for the IDLE task.  At least\n                  this much must be allocated.  This should be\n                  CONFIG_IDLETHREAD_STACKSIZE.\n"]
    pub fn up_cpu_idlestack(cpu: cty::c_int, tcb: *mut tcb_s, stack_size: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_mdelay and up_udelay\n\n Description:\n   Some device drivers may require that the platform-specific logic\n   provides these timing loops for short delays.\n"]
    pub fn up_mdelay(milliseconds: cty::c_uint);
}
extern "C" {
    pub fn up_udelay(microseconds: useconds_t);
}
extern "C" {
    pub fn nxsched_process_timer();
}
extern "C" {
    #[doc = " Name: irq_dispatch\n\n Description:\n   This function must be called from the architecture-specific logic in\n   order to dispatch an interrupt to the appropriate, registered handling\n   logic.\n"]
    pub fn irq_dispatch(irq: cty::c_int, context: *mut cty::c_void);
}
extern "C" {
    pub fn up_check_tcbstack(tcb: *mut tcb_s) -> usize;
}
extern "C" {
    #[doc = " Name: up_putc\n\n Description:\n   Output one character on the console\n"]
    pub fn up_putc(ch: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn up_nputs(str_: *const cty::c_char, len: usize);
}
extern "C" {
    #[doc = " Name: up_perf_*\n\n Description:\n   The first interface simply provides the current time value in unknown\n   units.  NOTE:  This function may be called early before the timer has\n   been initialized.  In that event, the function should just return a\n   start time of zero.\n\n   Nothing is assumed about the units of this time value.  The following\n   are assumed, however: (1) The time is an unsigned integer value, (2)\n   the time is monotonically increasing, and (3) the elapsed time (also\n   in unknown units) can be obtained by subtracting a start time from\n   the current time.\n\n   The second interface simple converts an elapsed time into well known\n   units.\n"]
    pub fn up_perf_init(arg: *mut cty::c_void);
}
extern "C" {
    pub fn up_perf_gettime() -> cty::c_ulong;
}
extern "C" {
    pub fn up_perf_getfreq() -> cty::c_ulong;
}
extern "C" {
    pub fn up_perf_convert(elapsed: cty::c_ulong, ts: *mut timespec);
}
extern "C" {
    #[doc = " Name: up_show_cpuinfo\n\n Description:\n   This function will be called when reading /proc/cpufinfo.\n   This function should be implemented by each arch to show its cpuinfo.\n\n Input Parameters:\n   buf          - The address of the user's receive buffer.\n   buf_size     - The size (in bytes) of the user's receive buffer.\n   file_off     - The /proc/cpuinfo file offset.\n\n Returned Value:\n   The number of bytes actually transferred into the user's receive buffer.\n"]
    pub fn up_show_cpuinfo(buf: *mut cty::c_char, buf_size: usize, file_off: off_t) -> isize;
}
extern "C" {
    #[doc = " Name: up_saveusercontext\n\n Description:\n   Save the current thread context\n"]
    pub fn up_saveusercontext(saveregs: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_debugpoint\n\n Description:\n   Add a debugpoint.\n\n Input Parameters:\n   type     - The debugpoint type. optional value:\n              DEBUGPOINT_WATCHPOINT_RO - Read only watchpoint.\n              DEBUGPOINT_WATCHPOINT_WO - Write only watchpoint.\n              DEBUGPOINT_WATCHPOINT_RW - Read and write watchpoint.\n              DEBUGPOINT_BREAKPOINT    - Breakpoint.\n              DEBUGPOINT_STEPPOINT     - Single step.\n   addr     - The address to be debugged.\n   size     - The watchpoint size. only for watchpoint.\n   callback - The callback function when debugpoint triggered.\n              if NULL, the debugpoint will be removed.\n   arg      - The argument of callback function.\n\n Returned Value:\n  Zero on success; a negated errno value on failure\n"]
    pub fn up_debugpoint_add(
        type_: cty::c_int,
        addr: *mut cty::c_void,
        size: usize,
        callback: debug_callback_t,
        arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: up_debugpoint_remove\n\n Description:\n   Remove a debugpoint.\n\n Input Parameters:\n   type     - The debugpoint type. optional value:\n              DEBUGPOINT_WATCHPOINT_RO - Read only watchpoint.\n              DEBUGPOINT_WATCHPOINT_WO - Write only watchpoint.\n              DEBUGPOINT_WATCHPOINT_RW - Read and write watchpoint.\n              DEBUGPOINT_BREAKPOINT    - Breakpoint.\n              DEBUGPOINT_STEPPOINT     - Single step.\n   addr     - The address to be debugged.\n   size     - The watchpoint size. only for watchpoint.\n\n Returned Value:\n  Zero on success; a negated errno value on failure\n"]
    pub fn up_debugpoint_remove(
        type_: cty::c_int,
        addr: *mut cty::c_void,
        size: usize,
    ) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: cty::c_int,
    pub ordblks: cty::c_int,
    pub aordblks: cty::c_int,
    pub mxordblk: cty::c_int,
    pub uordblks: cty::c_int,
    pub fordblks: cty::c_int,
    pub usmblks: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malltask {
    pub pid: pid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo_task {
    pub aordblks: cty::c_int,
    pub uordblks: cty::c_int,
}
extern "C" {
    pub fn mallopt(param: cty::c_int, value: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn malloc_size(ptr: *mut cty::c_void) -> usize;
}
extern "C" {
    pub fn mallinfo_task(task: *const malltask) -> mallinfo_task;
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_heap_s {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut g_mmheap: *mut mm_heap_s;
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn mm_initialize(
        name: *const cty::c_char,
        heap_start: *mut cty::c_void,
        heap_size: usize,
    ) -> *mut mm_heap_s;
}
extern "C" {
    pub fn mm_addregion(heap: *mut mm_heap_s, heapstart: *mut cty::c_void, heapsize: usize);
}
extern "C" {
    pub fn mm_uninitialize(heap: *mut mm_heap_s);
}
extern "C" {
    pub fn umm_initialize(heap_start: *mut cty::c_void, heap_size: usize);
}
extern "C" {
    pub fn umm_addregion(heapstart: *mut cty::c_void, heapsize: usize);
}
extern "C" {
    pub fn mm_malloc(heap: *mut mm_heap_s, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn mm_malloc_size(heap: *mut mm_heap_s, mem: *mut cty::c_void) -> usize;
}
extern "C" {
    pub fn mm_free(heap: *mut mm_heap_s, mem: *mut cty::c_void);
}
extern "C" {
    pub fn mm_realloc(
        heap: *mut mm_heap_s,
        oldmem: *mut cty::c_void,
        size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn mm_calloc(heap: *mut mm_heap_s, n: usize, elem_size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn mm_zalloc(heap: *mut mm_heap_s, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn mm_memalign(heap: *mut mm_heap_s, alignment: usize, size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn mm_heapmember(heap: *mut mm_heap_s, mem: *mut cty::c_void) -> bool;
}
extern "C" {
    pub fn umm_heapmember(mem: *mut cty::c_void) -> bool;
}
extern "C" {
    pub fn mm_brkaddr(heap: *mut mm_heap_s, region: cty::c_int) -> *mut cty::c_void;
}
extern "C" {
    pub fn umm_brkaddr(region: cty::c_int) -> *mut cty::c_void;
}
extern "C" {
    pub fn mm_extend(heap: *mut mm_heap_s, mem: *mut cty::c_void, size: usize, region: cty::c_int);
}
extern "C" {
    pub fn umm_extend(mem: *mut cty::c_void, size: usize, region: cty::c_int);
}
extern "C" {
    pub fn mm_mallinfo(heap: *mut mm_heap_s) -> mallinfo;
}
extern "C" {
    pub fn mm_mallinfo_task(heap: *mut mm_heap_s, task: *const malltask) -> mallinfo_task;
}
extern "C" {
    pub fn mm_memdump(heap: *mut mm_heap_s, dump: *const malltask);
}
#[doc = " Public Types"]
pub type userled_set_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct userled_s {
    pub ul_led: u8,
    pub ul_on: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct userled_lowerhalf_s {
    pub ll_supported: ::core::option::Option<
        unsafe extern "C" fn(lower: *const userled_lowerhalf_s) -> userled_set_t,
    >,
    pub ll_setled: ::core::option::Option<
        unsafe extern "C" fn(lower: *const userled_lowerhalf_s, led: cty::c_int, ledon: bool),
    >,
    pub ll_setall: ::core::option::Option<
        unsafe extern "C" fn(lower: *const userled_lowerhalf_s, ledset: userled_set_t),
    >,
}
extern "C" {
    #[doc = " Name: userled_register\n\n Description:\n   Bind the lower half LED driver to an instance of the upper half\n   LED driver and register the composite character driver as the\n   specified device.\n\n Input Parameters:\n   devname - The name of the LED device to be registered.\n     This should be a string of the form \"/dev/ledN\" where N is the\n     minor device number.\n   lower - An instance of the platform-specific LED lower half driver.\n\n Returned Value:\n   Zero (OK) is returned on success.  Otherwise a negated errno value is\n   returned to indicate the nature of the failure.\n"]
    pub fn userled_register(
        devname: *const cty::c_char,
        lower: *const userled_lowerhalf_s,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: stm32_i2cbus_initialize\n\n Description:\n   Initialize the selected I2C port. And return a unique instance of struct\n   struct i2c_master_s.  This function may be called to obtain multiple\n   instances of the interface, each of which may be set up with a\n   different frequency and slave address.\n\n Input Parameters:\n   Port number (for hardware that has multiple I2C interfaces)\n\n Returned Value:\n   Valid I2C device structure reference on success; a NULL on failure\n"]
    pub fn stm32_i2cbus_initialize(port: cty::c_int) -> *mut i2c_master_s;
}
extern "C" {
    #[doc = " Name: stm32_i2cbus_uninitialize\n\n Description:\n   De-initialize the selected I2C port, and power down the device.\n\n Input Parameters:\n   Device structure as returned by the stm32_i2cbus_initialize()\n\n Returned Value:\n   OK on success, ERROR when internal reference count mismatch or dev\n   points to invalid hardware device.\n"]
    pub fn stm32_i2cbus_uninitialize(dev: *mut i2c_master_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: syslog and vsyslog\n\n Description:\n   syslog() generates a log message. The priority argument is formed by\n   ORing the facility and the level values (see include/syslog.h). The\n   remaining arguments are a format, as in printf and any arguments to the\n   format.\n\n   The NuttX implementation does not support any special formatting\n   characters beyond those supported by printf.\n\n   The function vsyslog() performs the same task as syslog() with the\n   difference that it takes a set of arguments which have been obtained\n   using the stdarg variable argument list macros.\n"]
    pub fn syslog(priority: cty::c_int, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn vsyslog(priority: cty::c_int, fmt: *const cty::c_char, ap: va_list);
}
extern "C" {
    #[doc = " Name: setlogmask\n\n Description:\n   The setlogmask() function sets the logmask and returns the previous\n   mask. If the mask argument is 0, the current logmask is not modified.\n\n   The SYSLOG priorities are: LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,\n   LOG_WARNING, LOG_NOTICE, LOG_INFO, and LOG_DEBUG.  The bit corresponding\n   to a priority p is LOG_MASK(p); LOG_UPTO(p) provides the mask of all\n   priorities in the above list up to and including p.\n\n   Per OpenGroup.org \"If the maskpri argument is 0, the current log mask\n   is not modified.\"  In this implementation, the value zero is permitted\n   in order to disable all syslog levels.\n\n   NOTE:  setlogmask is not a thread-safe, re-entrant function.  Concurrent\n   use of setlogmask() will have undefined behavior.\n\n   REVISIT: Per POSIX the syslog mask should be a per-process value but in\n   NuttX, the scope of the mask is dependent on the nature of the build:\n\n   Flat Build:  There is one, global SYSLOG mask that controls all output.\n   Protected Build:  There are two SYSLOG masks.  One within the kernel\n     that controls only kernel output.  And one in user-space that controls\n     only user SYSLOG output.\n   Kernel Build:  The kernel build is compliant with the POSIX requirement:\n     There will be one mask for for each user process, controlling the\n     SYSLOG output only form that process.  There will be a separate mask\n     accessible only in the kernel code to control kernel SYSLOG output.\n"]
    pub fn setlogmask(mask: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lib_get_streams() -> *mut streamlist;
}
extern "C" {
    pub fn lib_get_stream(fd: cty::c_int) -> *mut file_struct;
}
extern "C" {
    pub fn nrand(limit: cty::c_ulong) -> cty::c_ulong;
}
#[doc = " Public Type Definitions"]
pub type FILE = file_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct va_format {
    pub fmt: *const cty::c_char,
    pub va: *mut va_list,
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn clearerr(stream: *mut FILE);
}
extern "C" {
    pub fn clearerr_unlocked(stream: *mut FILE);
}
extern "C" {
    pub fn fclose(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn feof(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetpos(stream: *mut FILE, pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fgets(s: *mut cty::c_char, n: cty::c_int, stream: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        s: *mut cty::c_char,
        n: cty::c_int,
        stream: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fopen(path: *const cty::c_char, type_: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(stream: *mut FILE, format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fputc(c: cty::c_int, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(c: cty::c_int, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputs(s: *const cty::c_char, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputs_unlocked(s: *const cty::c_char, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        ptr: *mut cty::c_void,
        size: cty::c_uint,
        n_items: cty::c_uint,
        stream: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fread_unlocked(
        ptr: *mut cty::c_void,
        size: usize,
        n_items: usize,
        stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        path: *const cty::c_char,
        mode: *const cty::c_char,
        stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(stream: *mut FILE, fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fseek(stream: *mut FILE, offset: cty::c_long, whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fseeko(stream: *mut FILE, offset: off_t, whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(stream: *mut FILE, pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn ftell(stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn ftello(stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn fwrite(
        ptr: *const cty::c_void,
        size: cty::c_uint,
        n_items: cty::c_uint,
        stream: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fwrite_unlocked(
        ptr: *const cty::c_void,
        size: usize,
        n_items: usize,
        stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn getdelim(
        lineptr: *mut *mut cty::c_char,
        n: *mut usize,
        delimiter: cty::c_int,
        stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(lineptr: *mut *mut cty::c_char, n: *mut usize, stream: *mut FILE) -> isize;
}
extern "C" {
    pub fn gets(s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn gets_s(s: *mut cty::c_char, n: rsize_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn rewind(stream: *mut FILE);
}
extern "C" {
    pub fn setbuf(stream: *mut FILE, buf: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        stream: *mut FILE,
        buffer: *mut cty::c_char,
        mode: cty::c_int,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setbuffer(stream: *mut FILE, buf: *mut cty::c_char, size: usize);
}
extern "C" {
    pub fn ungetc(c: cty::c_int, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn flockfile(stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(stream: *mut FILE);
}
extern "C" {
    pub fn perror(s: *const cty::c_char);
}
extern "C" {
    pub fn printf(fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn putc(c: cty::c_int, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc_unlocked(c: cty::c_int, stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn puts(s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(oldpath: *const cty::c_char, newpath: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        olddirfd: cty::c_int,
        oldpath: *const cty::c_char,
        newdirfd: cty::c_int,
        newpath: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut cty::c_char, fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn asprintf(ptr: *mut *mut cty::c_char, fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut cty::c_char,
        size: cty::c_uint,
        fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(buf: *const cty::c_char, fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vasprintf(
        ptr: *mut *mut cty::c_char,
        fmt: *const cty::c_char,
        ap: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(stream: *mut FILE, fmt: *const cty::c_char, ap: u32) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(stream: *mut FILE, fmt: *const cty::c_char, ap: u32) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(fmt: *const cty::c_char, ap: u32) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(fmt: *const cty::c_char, ap: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut cty::c_char,
        size: cty::c_uint,
        fmt: *const cty::c_char,
        ap: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut cty::c_char, fmt: *const cty::c_char, ap: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(buf: *const cty::c_char, fmt: *const cty::c_char, ap: u32) -> cty::c_int;
}
extern "C" {
    pub fn fdopen(fd: cty::c_int, type_: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn dprintf(fd: cty::c_int, fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vdprintf(fd: cty::c_int, fmt: *const cty::c_char, ap: va_list) -> cty::c_int;
}
extern "C" {
    pub fn fopencookie(
        cookie: *mut cty::c_void,
        mode: *const cty::c_char,
        io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(buf: *mut cty::c_void, size: usize, mode: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(bufp: *mut *mut cty::c_char, sizep: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(dir: *const cty::c_char, pfx: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn remove(path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn pclose(stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(command: *const cty::c_char, mode: *const cty::c_char) -> *mut FILE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ctrlreq_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_map_entry {
    pub _address: u8,
}
