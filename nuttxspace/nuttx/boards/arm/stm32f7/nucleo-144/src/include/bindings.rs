/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub const CONFIG_y: u8 = 1;
pub const CONFIG_m: u8 = 2;
pub const CONFIG_HOST_LINUX: u8 = 1;
pub const CONFIG_APPS_DIR: &[u8; 8] = b"../apps\0";
pub const CONFIG_BASE_DEFCONFIG: &[u8; 20] = b"nucleo-144:f746-nsh\0";
pub const CONFIG_BUILD_FLAT: u8 = 1;
pub const CONFIG_RAW_BINARY: u8 = 1;
pub const CONFIG_ARCH_HAVE_STDARG_H: u8 = 1;
pub const CONFIG_ARCH_HAVE_SETJMP: u8 = 1;
pub const CONFIG_ARCH_NONE_DEBUG_H: u8 = 1;
pub const CONFIG_FORTIFY_SOURCE: u8 = 0;
pub const CONFIG_NDEBUG: u8 = 1;
pub const CONFIG_DEBUG_ALERT: u8 = 1;
pub const CONFIG_ARCH_HAVE_STACKCHECK: u8 = 1;
pub const CONFIG_STACK_COLORATION: u8 = 1;
pub const CONFIG_STACK_USAGE_WARNING: u8 = 0;
pub const CONFIG_ARCH_HAVE_HEAPCHECK: u8 = 1;
pub const CONFIG_DEBUG_SYMBOLS: u8 = 1;
pub const CONFIG_ARCH_HAVE_CUSTOMOPT: u8 = 1;
pub const CONFIG_DEBUG_NOOPT: u8 = 1;
pub const CONFIG_DEBUG_OPT_UNUSED_SECTIONS: u8 = 1;
pub const CONFIG_DEBUG_LINK_MAP: u8 = 1;
pub const CONFIG_ARCH_ARM: u8 = 1;
pub const CONFIG_ARCH: &[u8; 4] = b"arm\0";
pub const CONFIG_ARM_TOOLCHAIN_GNU_EABI: u8 = 1;
pub const CONFIG_ARCH_CHIP_STM32F7: u8 = 1;
pub const CONFIG_ARCH_ARMV7M: u8 = 1;
pub const CONFIG_ARCH_CORTEXM7: u8 = 1;
pub const CONFIG_ARCH_FAMILY: &[u8; 8] = b"armv7-m\0";
pub const CONFIG_ARCH_CHIP: &[u8; 8] = b"stm32f7\0";
pub const CONFIG_ARM_THUMB: u8 = 1;
pub const CONFIG_ARM_HAVE_MPU_UNIFIED: u8 = 1;
pub const CONFIG_ARCH_HAVE_HARDFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_MEMFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_BUSFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_USAGEFAULT_DEBUG: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_ICACHE: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_DCACHE: u8 = 1;
pub const CONFIG_ARMV7M_ICACHE: u8 = 1;
pub const CONFIG_ARMV7M_DCACHE: u8 = 1;
pub const CONFIG_ARMV7M_DCACHE_WRITETHROUGH: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_ITCM: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_DTCM: u8 = 1;
pub const CONFIG_ARMV7M_DTCM: u8 = 1;
pub const CONFIG_ARMV7M_HAVE_STACKCHECK: u8 = 1;
pub const CONFIG_ARCH_CHIP_STM32F746ZG: u8 = 1;
pub const CONFIG_STM32F7_STM32F74XX: u8 = 1;
pub const CONFIG_STM32F7_IO_CONFIG_Z: u8 = 1;
pub const CONFIG_STM32F7_STM32F746XX: u8 = 1;
pub const CONFIG_STM32F7_FLASH_CONFIG_G: u8 = 1;
pub const CONFIG_STM32F7_FLASH_OVERRIDE_DEFAULT: u8 = 1;
pub const CONFIG_STM32F7_HAVE_LTDC: u8 = 1;
pub const CONFIG_STM32F7_HAVE_FMC: u8 = 1;
pub const CONFIG_STM32F7_HAVE_ETHRNET: u8 = 1;
pub const CONFIG_STM32F7_HAVE_RNG: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SPI4: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SPI5: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SPI6: u8 = 1;
pub const CONFIG_STM32F7_HAVE_CAN2: u8 = 1;
pub const CONFIG_STM32F7_HAVE_DCMI: u8 = 1;
pub const CONFIG_STM32F7_HAVE_DMA2D: u8 = 1;
pub const CONFIG_STM32F7_HAVE_EXTERNAL_ULPI: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SAI1: u8 = 1;
pub const CONFIG_STM32F7_HAVE_SAI2: u8 = 1;
pub const CONFIG_STM32F7_USART: u8 = 1;
pub const CONFIG_STM32F7_SYSCFG: u8 = 1;
pub const CONFIG_STM32F7_USART3: u8 = 1;
pub const CONFIG_STM32F7_SERIAL_DISABLE_REORDERING: u8 = 1;
pub const CONFIG_STM32F7_USART_BREAKS: u8 = 1;
pub const CONFIG_STM32F7_SERIALBRK_BSDCOMPAT: u8 = 1;
pub const CONFIG_STM32F7_HAVE_RTC_SUBSECONDS: u8 = 1;
pub const CONFIG_ARCH_BOARD: &[u8; 11] = b"nucleo-144\0";
pub const CONFIG_ARCH_TOOLCHAIN_GNU: u8 = 1;
pub const CONFIG_LTO_NONE: u8 = 1;
pub const CONFIG_ARCH_HAVE_IRQTRIGGER: u8 = 1;
pub const CONFIG_ARCH_HAVE_IRQPRIO: u8 = 1;
pub const CONFIG_ARCH_ICACHE: u8 = 1;
pub const CONFIG_ARCH_DCACHE: u8 = 1;
pub const CONFIG_ARCH_HAVE_FORK: u8 = 1;
pub const CONFIG_ARCH_HAVE_FPU: u8 = 1;
pub const CONFIG_ARCH_HAVE_MPU: u8 = 1;
pub const CONFIG_ARCH_HAVE_PROGMEM: u8 = 1;
pub const CONFIG_ARCH_HAVE_RESET: u8 = 1;
pub const CONFIG_ARCH_HAVE_TESTSET: u8 = 1;
pub const CONFIG_ARCH_HAVE_THREAD_LOCAL: u8 = 1;
pub const CONFIG_ARCH_HAVE_FETCHADD: u8 = 1;
pub const CONFIG_ARCH_HAVE_RTC_SUBSECONDS: u8 = 1;
pub const CONFIG_ARCH_HAVE_SYSCALL_HOOKS: u8 = 1;
pub const CONFIG_ARCH_HAVE_BACKTRACE: u8 = 1;
pub const CONFIG_ARCH_HAVE_DEBUG: u8 = 1;
pub const CONFIG_ARCH_HAVE_PERF_EVENTS: u8 = 1;
pub const CONFIG_ARCH_HAVE_CPUINFO: u8 = 1;
pub const CONFIG_ARCH_HAVE_TCBINFO: u8 = 1;
pub const CONFIG_ARCH_STACKDUMP: u8 = 1;
pub const CONFIG_ARCH_STACKDUMP_MAX_LENGTH: u8 = 0;
pub const CONFIG_ARCH_HAVE_RAMVECTORS: u8 = 1;
pub const CONFIG_BOARD_LOOPSPERMSEC: u16 = 43103;
pub const CONFIG_ARCH_HAVE_INTERRUPTSTACK: u8 = 1;
pub const CONFIG_ARCH_INTERRUPTSTACK: u8 = 0;
pub const CONFIG_ARCH_HAVE_HIPRI_INTERRUPT: u8 = 1;
pub const CONFIG_BOOT_RUNFROMFLASH: u8 = 1;
pub const CONFIG_RAM_START: u32 = 536936448;
pub const CONFIG_RAM_SIZE: u32 = 245760;
pub const CONFIG_ARCH_BOARD_NUCLEO_144: u8 = 1;
pub const CONFIG_ARCH_HAVE_LEDS: u8 = 1;
pub const CONFIG_ARCH_LEDS: u8 = 1;
pub const CONFIG_ARCH_HAVE_BUTTONS: u8 = 1;
pub const CONFIG_ARCH_BUTTONS: u8 = 1;
pub const CONFIG_ARCH_HAVE_IRQBUTTONS: u8 = 1;
pub const CONFIG_NUCLEO_CONSOLE_VIRTUAL: u8 = 1;
pub const CONFIG_BOARDCTL: u8 = 1;
pub const CONFIG_BOARDCTL_MKRD: u8 = 1;
pub const CONFIG_BOARD_MEMORY_RANGE: &[u8; 1] = b"\0";
pub const CONFIG_DISABLE_OS_API: u8 = 1;
pub const CONFIG_ARCH_HAVE_TICKLESS: u8 = 1;
pub const CONFIG_USEC_PER_TICK: u16 = 10000;
pub const CONFIG_ARCH_HAVE_TIMEKEEPING: u8 = 1;
pub const CONFIG_START_YEAR: u16 = 2015;
pub const CONFIG_START_MONTH: u8 = 11;
pub const CONFIG_START_DAY: u8 = 30;
pub const CONFIG_PREALLOC_TIMERS: u8 = 4;
pub const CONFIG_INIT_ENTRY: u8 = 1;
pub const CONFIG_INIT_STACKSIZE: u16 = 2048;
pub const CONFIG_INIT_PRIORITY: u8 = 100;
pub const CONFIG_INIT_ENTRYNAME: &[u8; 9] = b"nsh_main\0";
pub const CONFIG_RR_INTERVAL: u8 = 200;
pub const CONFIG_TASK_NAME_SIZE: u8 = 0;
pub const CONFIG_SCHED_WAITPID: u8 = 1;
pub const CONFIG_PTHREAD_MUTEX_ROBUST: u8 = 1;
pub const CONFIG_PTHREAD_MUTEX_DEFAULT_PRIO_NONE: u8 = 1;
pub const CONFIG_PTHREAD_CLEANUP_STACKSIZE: u8 = 0;
pub const CONFIG_SCHED_CPULOAD_NONE: u8 = 1;
pub const CONFIG_SCHED_STACK_RECORD: u8 = 0;
pub const CONFIG_DEV_CONSOLE: u8 = 1;
pub const CONFIG_NFILE_DESCRIPTORS_PER_BLOCK: u8 = 8;
pub const CONFIG_FILE_STREAM: u8 = 1;
pub const CONFIG_NAME_MAX: u8 = 32;
pub const CONFIG_PATH_MAX: u16 = 256;
pub const CONFIG_SIG_PREALLOC_IRQ_ACTIONS: u8 = 8;
pub const CONFIG_PREALLOC_MQ_MSGS: u8 = 8;
pub const CONFIG_PREALLOC_MQ_IRQ_MSGS: u8 = 8;
pub const CONFIG_MQ_MAXMSGSIZE: u8 = 32;
pub const CONFIG_DEFAULT_TASK_STACKSIZE: u16 = 2048;
pub const CONFIG_IDLETHREAD_STACKSIZE: u16 = 1024;
pub const CONFIG_PTHREAD_STACK_MIN: u16 = 256;
pub const CONFIG_PTHREAD_STACK_DEFAULT: u16 = 2048;
pub const CONFIG_ARCH_HAVE_I2CRESET: u8 = 1;
pub const CONFIG_ARCH_HAVE_SPI_BITORDER: u8 = 1;
pub const CONFIG_SPI: u8 = 1;
pub const CONFIG_SPI_EXCHANGE: u8 = 1;
pub const CONFIG_DEV_NULL: u8 = 1;
pub const CONFIG_DEV_OPTEE_NONE: u8 = 1;
pub const CONFIG_DRVR_MKRD: u8 = 1;
pub const CONFIG_ARCH_HAVE_RDWR_MEM_CPU_RUN: u8 = 1;
pub const CONFIG_ARCH_HAVE_SERIAL_TERMIOS: u8 = 1;
pub const CONFIG_SERIAL: u8 = 1;
pub const CONFIG_SERIAL_CONSOLE: u8 = 1;
pub const CONFIG_MCU_SERIAL: u8 = 1;
pub const CONFIG_STANDARD_SERIAL: u8 = 1;
pub const CONFIG_SERIAL_NPOLLWAITERS: u8 = 4;
pub const CONFIG_USART3_SERIAL_CONSOLE: u8 = 1;
pub const CONFIG_USART3_SERIALDRIVER: u8 = 1;
pub const CONFIG_USART3_RXBUFSIZE: u16 = 256;
pub const CONFIG_USART3_TXBUFSIZE: u16 = 256;
pub const CONFIG_USART3_BAUD: u32 = 115200;
pub const CONFIG_USART3_BITS: u8 = 8;
pub const CONFIG_USART3_PARITY: u8 = 0;
pub const CONFIG_USART3_2STOP: u8 = 0;
pub const CONFIG_SYSLOG_MAX_CHANNELS: u8 = 1;
pub const CONFIG_SYSLOG_DEVPATH: &[u8; 11] = b"/dev/ttyS1\0";
pub const CONFIG_SYSLOG_DEFAULT: u8 = 1;
pub const CONFIG_FS_NEPOLL_DESCRIPTORS: u8 = 8;
pub const CONFIG_SENDFILE_BUFSIZE: u16 = 512;
pub const CONFIG_FS_MQUEUE_VFS_PATH: &[u8; 12] = b"/var/mqueue\0";
pub const CONFIG_FS_MQUEUE_NPOLLWAITERS: u8 = 4;
pub const CONFIG_FS_ANONMAP: u8 = 1;
pub const CONFIG_NXFONTS_PACKEDMSFIRST: u8 = 1;
pub const CONFIG_MM_DEFAULT_MANAGER: u8 = 1;
pub const CONFIG_MM_DFAULT_ALIGNMENT: u8 = 0;
pub const CONFIG_MM_REGIONS: u8 = 2;
pub const CONFIG_MM_MAP_COUNT_MAX: u16 = 1024;
pub const CONFIG_MM_HEAP_MEMPOOL_THRESHOLD: u8 = 0;
pub const CONFIG_MM_BACKTRACE: i8 = -1;
pub const CONFIG_MM_FREE_DELAYCOUNT_MAX: u8 = 0;
pub const CONFIG_BINFMT_ELF_RELOCATABLE: u8 = 1;
pub const CONFIG_STDIO_BUFFER_SIZE: u8 = 64;
pub const CONFIG_STDIO_LINEBUFFER: u8 = 1;
pub const CONFIG_NUNGET_CHARS: u8 = 2;
pub const CONFIG_LIBC_LONG_LONG: u8 = 1;
pub const CONFIG_ARCH_LOWPUTC: u8 = 1;
pub const CONFIG_LIBC_RAND_ORDER: u8 = 1;
pub const CONFIG_LIBC_HOMEDIR: &[u8; 2] = b"/\0";
pub const CONFIG_LIBC_TMPDIR: &[u8; 5] = b"/tmp\0";
pub const CONFIG_LIBC_MAX_TMPFILE: u8 = 32;
pub const CONFIG_LIBC_MAX_EXITFUNS: u8 = 0;
pub const CONFIG_POSIX_SPAWN_DEFAULT_STACKSIZE: u16 = 2048;
pub const CONFIG_LIBC_HOSTNAME: &[u8; 1] = b"\0";
pub const CONFIG_LIBC_OPEN_MAX: u16 = 256;
pub const CONFIG_LIBC_STRERROR_ERRNUM: u8 = 1;
pub const CONFIG_LIBC_STRSIGNAL: u8 = 1;
pub const CONFIG_TLS_NELEM: u8 = 0;
pub const CONFIG_TLS_TASK_NELEM: u8 = 0;
pub const CONFIG_LIBC_GAISTRERROR_ERRNUM: u8 = 1;
pub const CONFIG_LIBC_FTOK_VFS_PATH: &[u8; 10] = b"/var/ftok\0";
pub const CONFIG_LIBC_MEMFD_ERROR: u8 = 1;
pub const CONFIG_BUILTIN: u8 = 1;
pub const CONFIG_STREAM_OUT_BUFFER_SIZE: u8 = 64;
pub const CONFIG_STREAM_HEXDUMP_BUFFER_SIZE: u8 = 128;
pub const CONFIG_LIBM_TOOLCHAIN: u8 = 1;
pub const CONFIG_HAVE_CXX: u8 = 1;
pub const CONFIG_HAVE_CXXINITIALIZE: u8 = 1;
pub const CONFIG_LIBCXXMINI: u8 = 1;
pub const CONFIG_CXX_STANDARD: &[u8; 8] = b"gnu++17\0";
pub const CONFIG_NSH_LIBRARY: u8 = 1;
pub const CONFIG_NSH_PROMPT_STRING: &[u8; 6] = b"nsh> \0";
pub const CONFIG_NSH_READLINE: u8 = 1;
pub const CONFIG_NSH_LINELEN: u8 = 64;
pub const CONFIG_NSH_QUOTE: u8 = 1;
pub const CONFIG_NSH_MAXARGUMENTS: u8 = 7;
pub const CONFIG_NSH_ARGCAT: u8 = 1;
pub const CONFIG_NSH_NESTDEPTH: u8 = 3;
pub const CONFIG_NSH_ALIAS: u8 = 1;
pub const CONFIG_NSH_ALIAS_MAX_AMOUNT: u8 = 1;
pub const CONFIG_NSH_BUILTIN_APPS: u8 = 1;
pub const CONFIG_NSH_DISABLE_DATE: u8 = 1;
pub const CONFIG_NSH_DISABLE_IFUPDOWN: u8 = 1;
pub const CONFIG_NSH_DISABLE_LOSMART: u8 = 1;
pub const CONFIG_NSH_DISABLE_LOMTD: u8 = 1;
pub const CONFIG_NSH_DISABLE_MB: u8 = 1;
pub const CONFIG_NSH_DISABLE_MH: u8 = 1;
pub const CONFIG_NSH_DISABLE_MW: u8 = 1;
pub const CONFIG_NSH_DISABLE_TIMEDATECTL: u8 = 1;
pub const CONFIG_NSH_CODECS_BUFSIZE: u8 = 128;
pub const CONFIG_NSH_CMDOPT_HEXDUMP: u8 = 1;
pub const CONFIG_NSH_FILEIOSIZE: u16 = 512;
pub const CONFIG_NSH_SYSINITSCRIPT: &[u8; 18] = b"init.d/rc.sysinit\0";
pub const CONFIG_NSH_INITSCRIPT: &[u8; 11] = b"init.d/rcS\0";
pub const CONFIG_NSH_SCRIPT_REDIRECT_PATH: &[u8; 1] = b"\0";
pub const CONFIG_NSH_CONSOLE: u8 = 1;
pub const CONFIG_SYSTEM_NSH: u8 = 1;
pub const CONFIG_SYSTEM_NSH_PRIORITY: u8 = 100;
pub const CONFIG_SYSTEM_NSH_STACKSIZE: u16 = 2048;
pub const CONFIG_SYSTEM_NSH_PROGNAME: &[u8; 4] = b"nsh\0";
pub const CONFIG_SYSTEM_READLINE: u8 = 1;
pub const CONFIG_READLINE_HAVE_EXTMATCH: u8 = 1;
pub const CONFIG_READLINE_ECHO: u8 = 1;
pub const CONFIG_RAM_END: u32 = 537182208;
pub const CONFIG_HAVE_ANONYMOUS_STRUCT: u8 = 1;
pub const CONFIG_HAVE_ANONYMOUS_UNION: u8 = 1;
pub const CONFIG_C99_BOOL: u8 = 1;
pub const CONFIG_DESIGNATED_INITIALIZERS: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_BSWAP16: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_BSWAP32: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_BSWAP64: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_CTZ: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_CLZ: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_POPCOUNT: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_POPCOUNTLL: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_FFS: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_FFSL: u8 = 1;
pub const CONFIG_HAVE_BUILTIN_FFSLL: u8 = 1;
pub const CONFIG_CPP_HAVE_VARARGS: u8 = 1;
pub const CONFIG_CPP_HAVE_WARNING: u8 = 1;
pub const CONFIG_HAVE_FUNCTIONNAME: u8 = 1;
pub const CONFIG_HAVE_FILENAME: u8 = 1;
pub const CONFIG_HAVE_WEAKFUNCTIONS: u8 = 1;
pub const CONFIG_HAVE_LONG_LONG: u8 = 1;
pub const CONFIG_HAVE_FLOAT: u8 = 1;
pub const CONFIG_HAVE_DOUBLE: u8 = 1;
pub const CONFIG_HAVE_LONG_DOUBLE: u8 = 1;
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIdPTR: &[u8; 2] = b"d\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIiPTR: &[u8; 2] = b"i\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIoPTR: &[u8; 2] = b"o\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIuPTR: &[u8; 2] = b"u\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIxPTR: &[u8; 2] = b"x\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIXPTR: &[u8; 2] = b"X\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNdPTR: &[u8; 2] = b"d\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNiPTR: &[u8; 2] = b"i\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNoPTR: &[u8; 2] = b"o\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNuPTR: &[u8; 2] = b"u\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNxPTR: &[u8; 2] = b"x\0";
pub const CHAR_BIT: u8 = 8;
pub const SCHAR_MAX: u8 = 127;
pub const UCHAR_MAX: u8 = 255;
pub const CHAR_MIN: u8 = 0;
pub const CHAR_MAX: u8 = 255;
pub const SHRT_MAX: u16 = 32767;
pub const USHRT_MAX: u16 = 65535;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i8 = -1;
pub const PTR_MAX: u32 = 2147483647;
pub const UPTR_MAX: u32 = 4294967295;
pub const WCHAR_MIN: u8 = 0;
pub const MB_LEN_MAX: u8 = 4;
pub const _POSIX_ARG_MAX: u16 = 4096;
pub const _POSIX_CHILD_MAX: u8 = 6;
pub const _POSIX_LINK_MAX: u8 = 8;
pub const _POSIX_MAX_CANON: u8 = 255;
pub const _POSIX_MAX_INPUT: u8 = 255;
pub const _POSIX_NAME_MAX: u8 = 32;
pub const _POSIX_NGROUPS_MAX: u8 = 0;
pub const _POSIX_OPEN_MAX: u8 = 16;
pub const _POSIX_PATH_MAX: u16 = 256;
pub const _POSIX_PIPE_BUF: u16 = 512;
pub const _POSIX_STREAM_MAX: u8 = 16;
pub const _POSIX_TZNAME_MAX: u8 = 3;
pub const _POSIX_SIZE_MAX: u32 = 4294967295;
pub const _POSIX_SIZE_MIN: u8 = 0;
pub const _POSIX_SSIZE_MAX: u32 = 2147483647;
pub const _POSIX_RTSIG_MAX: u8 = 8;
pub const _POSIX_SIGQUEUE_MAX: u8 = 32;
pub const _POSIX_SYMLOOP_MAX: u8 = 8;
pub const _POSIX_DELAYTIMER_MAX: u8 = 32;
pub const _POSIX_TIMER_MAX: u8 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 10000000;
pub const _POSIX_AIO_LISTIO_MAX: u8 = 2;
pub const _POSIX_AIO_MAX: u8 = 1;
pub const _POSIX_MQ_OPEN_MAX: u8 = 8;
pub const _POSIX_MQ_PRIO_MAX: u8 = 255;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 2147483647;
pub const _POSIX_SEM_VALUE_MAX: u16 = 32767;
pub const ARG_MAX: u16 = 4096;
pub const CHILD_MAX: u8 = 6;
pub const LINK_MAX: u8 = 8;
pub const MAX_CANON: u8 = 255;
pub const MAX_INPUT: u8 = 255;
pub const NAME_MAX: u8 = 32;
pub const TTY_NAME_MAX: u8 = 32;
pub const NGROUPS_MAX: u8 = 0;
pub const OPEN_MAX: u16 = 256;
pub const PATH_MAX: u16 = 256;
pub const PIPE_BUF: u16 = 512;
pub const SIZE_MAX: u32 = 4294967295;
pub const SIZE_MIN: u8 = 0;
pub const RSIZE_MAX: u32 = 4294967295;
pub const SSIZE_MAX: u32 = 2147483647;
pub const STREAM_MAX: u8 = 16;
pub const TZNAME_MAX: u8 = 3;
pub const RTSIG_MAX: u8 = 32;
pub const SIGQUEUE_MAX: u8 = 32;
pub const SYMLOOP_MAX: u8 = 8;
pub const DELAYTIMER_MAX: u8 = 32;
pub const TIMER_MAX: u8 = 32;
pub const CLOCKRES_MIN: u32 = 10000000;
pub const CHARCLASS_NAME_MAX: u8 = 14;
pub const NL_LANGMAX: u8 = 14;
pub const NL_MSGMAX: u16 = 32767;
pub const NL_SETMAX: u8 = 255;
pub const AIO_LISTIO_MAX: u8 = 2;
pub const AIO_MAX: u8 = 1;
pub const MQ_OPEN_MAX: u8 = 8;
pub const MQ_PRIO_MAX: u8 = 255;
pub const SEM_NSEMS_MAX: u32 = 2147483647;
pub const SEM_VALUE_MAX: u16 = 32767;
pub const IOV_MAX: u32 = 2147483647;
pub const HOST_NAME_MAX: u8 = 32;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const STM32_BOARD_XTAL: u32 = 8000000;
pub const STM32_HSI_FREQUENCY: u32 = 16000000;
pub const STM32_LSI_FREQUENCY: u16 = 32000;
pub const STM32_HSE_FREQUENCY: u32 = 8000000;
pub const STM32_LSE_FREQUENCY: u16 = 32768;
pub const STM32_VCO_FREQUENCY: u32 = 432000000;
pub const STM32_SYSCLK_FREQUENCY: u32 = 216000000;
pub const STM32_OTGFS_FREQUENCY: u32 = 48000000;
pub const CONFIG_STM32F7_PLLSAI: u8 = 1;
pub const STM32_RCC_DCKCFGR1_TIMPRESRC: u8 = 0;
pub const STM32_RCC_DCKCFGR1_DFSDM1SRC: u8 = 0;
pub const STM32_RCC_DCKCFGR1_ADFSDM1SRC: u8 = 0;
pub const CONFIG_STM32F7_PLLI2S: u8 = 1;
pub const STM32_HCLK_FREQUENCY: u32 = 216000000;
pub const STM32_PCLK1_FREQUENCY: u32 = 54000000;
pub const STM32_APB1_TIM2_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM3_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM4_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM5_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM6_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM7_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM12_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM13_CLKIN: u32 = 108000000;
pub const STM32_APB1_TIM14_CLKIN: u32 = 108000000;
pub const STM32_PCLK2_FREQUENCY: u32 = 108000000;
pub const STM32_APB2_TIM1_CLKIN: u32 = 216000000;
pub const STM32_APB2_TIM8_CLKIN: u32 = 216000000;
pub const STM32_APB2_TIM9_CLKIN: u32 = 216000000;
pub const STM32_APB2_TIM10_CLKIN: u32 = 216000000;
pub const STM32_APB2_TIM11_CLKIN: u32 = 216000000;
pub const BOARD_FLASH_WAITSTATES: u8 = 7;
pub const BOARD_LED1: u8 = 0;
pub const BOARD_LED2: u8 = 1;
pub const BOARD_LED3: u8 = 2;
pub const BOARD_NLEDS: u8 = 3;
pub const BOARD_LED_GREEN: u8 = 0;
pub const BOARD_LED_BLUE: u8 = 1;
pub const BOARD_LED_RED: u8 = 2;
pub const BOARD_LED1_BIT: u8 = 1;
pub const BOARD_LED2_BIT: u8 = 2;
pub const BOARD_LED3_BIT: u8 = 4;
pub const LED_STARTED: u8 = 0;
pub const LED_HEAPALLOCATE: u8 = 1;
pub const LED_IRQSENABLED: u8 = 2;
pub const LED_STACKCREATED: u8 = 3;
pub const LED_INIRQ: u8 = 4;
pub const LED_SIGNAL: u8 = 5;
pub const LED_ASSERTION: u8 = 6;
pub const LED_PANIC: u8 = 7;
pub const LED_IDLE: u8 = 8;
pub const BUTTON_USER: u8 = 0;
pub const NUM_BUTTONS: u8 = 1;
pub const BUTTON_USER_BIT: u8 = 1;
pub const LED_DRIVER_PATH: &[u8; 14] = b"/dev/userleds\0";
pub const SDIO_SLOTNO: u8 = 0;
pub const BOARD_NGPIOIN: u8 = 4;
pub const BOARD_NGPIOOUT: u8 = 10;
pub const BOARD_NGPIOINT: u8 = 1;
pub const __bool_true_false_are_defined: u8 = 1;
pub const TRUE: u8 = 1;
pub const FALSE: u8 = 0;
pub const SEEK_SET: u8 = 0;
pub const SEEK_CUR: u8 = 1;
pub const SEEK_END: u8 = 2;
pub const CONFIG_SMP_NCPUS: u8 = 1;
pub const SCHED_PRIORITY_MAX: u8 = 255;
pub const SCHED_PRIORITY_DEFAULT: u8 = 100;
pub const SCHED_PRIORITY_MIN: u8 = 1;
pub const SCHED_PRIORITY_IDLE: u8 = 0;
pub const STM32_IRQ_RESERVED: u8 = 0;
pub const STM32_IRQ_NMI: u8 = 2;
pub const STM32_IRQ_HARDFAULT: u8 = 3;
pub const STM32_IRQ_MEMFAULT: u8 = 4;
pub const STM32_IRQ_BUSFAULT: u8 = 5;
pub const STM32_IRQ_USAGEFAULT: u8 = 6;
pub const STM32_IRQ_SVCALL: u8 = 11;
pub const STM32_IRQ_DBGMONITOR: u8 = 12;
pub const STM32_IRQ_PENDSV: u8 = 14;
pub const STM32_IRQ_SYSTICK: u8 = 15;
pub const STM32_IRQ_FIRST: u8 = 16;
pub const STM32_IRQ_WWDG: u8 = 16;
pub const STM32_IRQ_PVD: u8 = 17;
pub const STM32_IRQ_TAMPER: u8 = 18;
pub const STM32_IRQ_TIMESTAMP: u8 = 18;
pub const STM32_IRQ_RTC_WKUP: u8 = 19;
pub const STM32_IRQ_FLASH: u8 = 20;
pub const STM32_IRQ_RCC: u8 = 21;
pub const STM32_IRQ_EXTI0: u8 = 22;
pub const STM32_IRQ_EXTI1: u8 = 23;
pub const STM32_IRQ_EXTI2: u8 = 24;
pub const STM32_IRQ_EXTI3: u8 = 25;
pub const STM32_IRQ_EXTI4: u8 = 26;
pub const STM32_IRQ_DMA1S0: u8 = 27;
pub const STM32_IRQ_DMA1S1: u8 = 28;
pub const STM32_IRQ_DMA1S2: u8 = 29;
pub const STM32_IRQ_DMA1S3: u8 = 30;
pub const STM32_IRQ_DMA1S4: u8 = 31;
pub const STM32_IRQ_DMA1S5: u8 = 32;
pub const STM32_IRQ_DMA1S6: u8 = 33;
pub const STM32_IRQ_ADC: u8 = 34;
pub const STM32_IRQ_CAN1TX: u8 = 35;
pub const STM32_IRQ_CAN1RX0: u8 = 36;
pub const STM32_IRQ_CAN1RX1: u8 = 37;
pub const STM32_IRQ_CAN1SCE: u8 = 38;
pub const STM32_IRQ_EXTI95: u8 = 39;
pub const STM32_IRQ_TIM1BRK: u8 = 40;
pub const STM32_IRQ_TIM9: u8 = 40;
pub const STM32_IRQ_TIM1UP: u8 = 41;
pub const STM32_IRQ_TIM10: u8 = 41;
pub const STM32_IRQ_TIM1TRGCOM: u8 = 42;
pub const STM32_IRQ_TIM11: u8 = 42;
pub const STM32_IRQ_TIM1CC: u8 = 43;
pub const STM32_IRQ_TIM2: u8 = 44;
pub const STM32_IRQ_TIM3: u8 = 45;
pub const STM32_IRQ_TIM4: u8 = 46;
pub const STM32_IRQ_I2C1EV: u8 = 47;
pub const STM32_IRQ_I2C1ER: u8 = 48;
pub const STM32_IRQ_I2C2EV: u8 = 49;
pub const STM32_IRQ_I2C2ER: u8 = 50;
pub const STM32_IRQ_SPI1: u8 = 51;
pub const STM32_IRQ_SPI2: u8 = 52;
pub const STM32_IRQ_USART1: u8 = 53;
pub const STM32_IRQ_USART2: u8 = 54;
pub const STM32_IRQ_USART3: u8 = 55;
pub const STM32_IRQ_EXTI1510: u8 = 56;
pub const STM32_IRQ_RTCALRM: u8 = 57;
pub const STM32_IRQ_OTGFSWKUP: u8 = 58;
pub const STM32_IRQ_TIM8BRK: u8 = 59;
pub const STM32_IRQ_TIM12: u8 = 59;
pub const STM32_IRQ_TIM8UP: u8 = 60;
pub const STM32_IRQ_TIM13: u8 = 60;
pub const STM32_IRQ_TIM8TRGCOM: u8 = 61;
pub const STM32_IRQ_TIM14: u8 = 61;
pub const STM32_IRQ_TIM8CC: u8 = 62;
pub const STM32_IRQ_DMA1S7: u8 = 63;
pub const STM32_IRQ_FMC: u8 = 64;
pub const STM32_IRQ_SDMMC1: u8 = 65;
pub const STM32_IRQ_TIM5: u8 = 66;
pub const STM32_IRQ_SPI3: u8 = 67;
pub const STM32_IRQ_UART4: u8 = 68;
pub const STM32_IRQ_UART5: u8 = 69;
pub const STM32_IRQ_TIM6: u8 = 70;
pub const STM32_IRQ_DAC: u8 = 70;
pub const STM32_IRQ_TIM7: u8 = 71;
pub const STM32_IRQ_DMA2S0: u8 = 72;
pub const STM32_IRQ_DMA2S1: u8 = 73;
pub const STM32_IRQ_DMA2S2: u8 = 74;
pub const STM32_IRQ_DMA2S3: u8 = 75;
pub const STM32_IRQ_DMA2S4: u8 = 76;
pub const STM32_IRQ_ETH: u8 = 77;
pub const STM32_IRQ_ETHWKUP: u8 = 78;
pub const STM32_IRQ_CAN2TX: u8 = 79;
pub const STM32_IRQ_CAN2RX0: u8 = 80;
pub const STM32_IRQ_CAN2RX1: u8 = 81;
pub const STM32_IRQ_CAN2SCE: u8 = 82;
pub const STM32_IRQ_OTGFS: u8 = 83;
pub const STM32_IRQ_DMA2S5: u8 = 84;
pub const STM32_IRQ_DMA2S6: u8 = 85;
pub const STM32_IRQ_DMA2S7: u8 = 86;
pub const STM32_IRQ_USART6: u8 = 87;
pub const STM32_IRQ_I2C3EV: u8 = 88;
pub const STM32_IRQ_I2C3ER: u8 = 89;
pub const STM32_IRQ_OTGHSEP1OUT: u8 = 90;
pub const STM32_IRQ_OTGHSEP1IN: u8 = 91;
pub const STM32_IRQ_OTGHSWKUP: u8 = 92;
pub const STM32_IRQ_OTGHS: u8 = 93;
pub const STM32_IRQ_DCMI: u8 = 94;
pub const STM32_IRQ_CRYP: u8 = 95;
pub const STM32_IRQ_HASH: u8 = 96;
pub const STM32_IRQ_RNG: u8 = 96;
pub const STM32_IRQ_FPU: u8 = 97;
pub const STM32_IRQ_UART7: u8 = 98;
pub const STM32_IRQ_UART8: u8 = 99;
pub const STM32_IRQ_SPI4: u8 = 100;
pub const STM32_IRQ_SPI5: u8 = 101;
pub const STM32_IRQ_SPI6: u8 = 102;
pub const STM32_IRQ_SAI1: u8 = 103;
pub const STM32_IRQ_LTDCINT: u8 = 104;
pub const STM32_IRQ_LTDCERRINT: u8 = 105;
pub const STM32_IRQ_DMA2D: u8 = 106;
pub const STM32_IRQ_SAI2: u8 = 107;
pub const STM32_IRQ_QUADSPI: u8 = 108;
pub const STM32_IRQ_LPTIMER1: u8 = 109;
pub const STM32_IRQ_HDMICEC: u8 = 110;
pub const STM32_IRQ_I2C4EV: u8 = 111;
pub const STM32_IRQ_I2C4ER: u8 = 112;
pub const STM32_IRQ_SPDIFRX: u8 = 113;
pub const STM32_IRQ_NEXTINTS: u8 = 98;
pub const NR_IRQS: u8 = 114;
pub const STM32F7_SRAM1_SIZE: u32 = 245760;
pub const STM32F7_SRAM2_SIZE: u16 = 16384;
pub const STM32F7_DTCM_SRAM_SIZE: u32 = 65536;
pub const STM32F7_ITCM_SRAM_SIZE: u16 = 16384;
pub const STM32F7_NSPDIFRX: u8 = 4;
pub const STM32F7_NGPIO: u8 = 11;
pub const STM32F7_NI2C: u8 = 4;
pub const STM32F7_NATIM: u8 = 2;
pub const STM32F7_NGTIM32: u8 = 2;
pub const STM32F7_NGTIM16: u8 = 2;
pub const STM32F7_NGTIMNDMA: u8 = 6;
pub const STM32F7_NBTIM: u8 = 2;
pub const STM32F7_NUART: u8 = 4;
pub const STM32F7_NUSART: u8 = 4;
pub const STM32F7_NI2S: u8 = 3;
pub const STM32F7_NUSBOTGFS: u8 = 1;
pub const STM32F7_NUSBOTGHS: u8 = 1;
pub const STM32F7_NSAI: u8 = 2;
pub const STM32F7_NDMA: u8 = 2;
pub const STM32F7_NADC: u8 = 3;
pub const STM32F7_NDAC: u8 = 2;
pub const STM32F7_NCAPSENSE: u8 = 0;
pub const STM32F7_NCRC: u8 = 1;
pub const STM32F7_NFMC: u8 = 1;
pub const STM32F7_NETHERNET: u8 = 1;
pub const STM32F7_NRNG: u8 = 1;
pub const STM32F7_NSPI: u8 = 6;
pub const STM32F7_NSDMMC: u8 = 1;
pub const STM32F7_NCAN: u8 = 2;
pub const STM32F7_NDCMI: u8 = 1;
pub const STM32F7_NDSIHOST: u8 = 0;
pub const STM32F7_NLCDTFT: u8 = 1;
pub const STM32F7_NDMA2D: u8 = 1;
pub const STM32F7_NJPEG: u8 = 0;
pub const STM32F7_NCRYP: u8 = 0;
pub const STM32F7_NHASH: u8 = 0;
pub const STM32F7_NDFSDM: u8 = 0;
pub const NVIC_SYSH_PRIORITY_MIN: u8 = 240;
pub const NVIC_SYSH_PRIORITY_DEFAULT: u8 = 128;
pub const NVIC_SYSH_PRIORITY_MAX: u8 = 0;
pub const NVIC_SYSH_PRIORITY_STEP: u8 = 16;
pub const NVIC_SYSH_MAXNORMAL_PRIORITY: u8 = 128;
pub const NVIC_SYSH_HIGH_PRIORITY: u8 = 96;
pub const NVIC_SYSH_DISABLE_PRIORITY: u8 = 128;
pub const NVIC_SYSH_SVCALL_PRIORITY: u8 = 112;
pub const CONFIG_SYS_NNEST: u8 = 2;
pub const REG_R13: u8 = 0;
pub const REG_PRIMASK: u8 = 1;
pub const REG_R4: u8 = 2;
pub const REG_R5: u8 = 3;
pub const REG_R6: u8 = 4;
pub const REG_R7: u8 = 5;
pub const REG_R8: u8 = 6;
pub const REG_R9: u8 = 7;
pub const REG_R10: u8 = 8;
pub const REG_R11: u8 = 9;
pub const REG_CONTROL: u8 = 10;
pub const REG_EXC_RETURN: u8 = 11;
pub const SW_INT_REGS: u8 = 12;
pub const SW_FPU_REGS: u8 = 0;
pub const SW_XCPT_REGS: u8 = 12;
pub const SW_XCPT_SIZE: u8 = 48;
pub const REG_R0: u8 = 12;
pub const REG_R1: u8 = 13;
pub const REG_R2: u8 = 14;
pub const REG_R3: u8 = 15;
pub const REG_R12: u8 = 16;
pub const REG_R14: u8 = 17;
pub const REG_R15: u8 = 18;
pub const REG_XPSR: u8 = 19;
pub const HW_INT_REGS: u8 = 8;
pub const HW_FPU_REGS: u8 = 0;
pub const HW_XCPT_REGS: u8 = 8;
pub const HW_XCPT_SIZE: u8 = 32;
pub const XCPTCONTEXT_REGS: u8 = 20;
pub const XCPTCONTEXT_SIZE: u8 = 80;
pub const REG_A1: u8 = 12;
pub const REG_A2: u8 = 13;
pub const REG_A3: u8 = 14;
pub const REG_A4: u8 = 15;
pub const REG_V1: u8 = 2;
pub const REG_V2: u8 = 3;
pub const REG_V3: u8 = 4;
pub const REG_V4: u8 = 5;
pub const REG_V5: u8 = 6;
pub const REG_V6: u8 = 7;
pub const REG_V7: u8 = 8;
pub const REG_SB: u8 = 7;
pub const REG_SL: u8 = 8;
pub const REG_FP: u8 = 5;
pub const REG_IP: u8 = 16;
pub const REG_SP: u8 = 0;
pub const REG_LR: u8 = 17;
pub const REG_PC: u8 = 18;
pub const REG_PIC: u8 = 8;
pub const CONTROL_FPCA: u8 = 4;
pub const CONTROL_SPSEL: u8 = 2;
pub const CONTROL_NPRIV: u8 = 1;
pub const STM32_GPIO_MODER_OFFSET: u8 = 0;
pub const STM32_GPIO_OTYPER_OFFSET: u8 = 4;
pub const STM32_GPIO_OSPEED_OFFSET: u8 = 8;
pub const STM32_GPIO_PUPDR_OFFSET: u8 = 12;
pub const STM32_GPIO_IDR_OFFSET: u8 = 16;
pub const STM32_GPIO_ODR_OFFSET: u8 = 20;
pub const STM32_GPIO_BSRR_OFFSET: u8 = 24;
pub const STM32_GPIO_LCKR_OFFSET: u8 = 28;
pub const STM32_GPIO_AFRL_OFFSET: u8 = 32;
pub const STM32_GPIO_AFRH_OFFSET: u8 = 36;
pub const GPIO_MODER_INPUT: u8 = 0;
pub const GPIO_MODER_OUTPUT: u8 = 1;
pub const GPIO_MODER_ALT: u8 = 2;
pub const GPIO_MODER_ANALOG: u8 = 3;
pub const GPIO_MODER0_SHIFT: u8 = 0;
pub const GPIO_MODER0_MASK: u8 = 3;
pub const GPIO_MODER1_SHIFT: u8 = 2;
pub const GPIO_MODER1_MASK: u8 = 12;
pub const GPIO_MODER2_SHIFT: u8 = 4;
pub const GPIO_MODER2_MASK: u8 = 48;
pub const GPIO_MODER3_SHIFT: u8 = 6;
pub const GPIO_MODER3_MASK: u8 = 192;
pub const GPIO_MODER4_SHIFT: u8 = 8;
pub const GPIO_MODER4_MASK: u16 = 768;
pub const GPIO_MODER5_SHIFT: u8 = 10;
pub const GPIO_MODER5_MASK: u16 = 3072;
pub const GPIO_MODER6_SHIFT: u8 = 12;
pub const GPIO_MODER6_MASK: u16 = 12288;
pub const GPIO_MODER7_SHIFT: u8 = 14;
pub const GPIO_MODER7_MASK: u16 = 49152;
pub const GPIO_MODER8_SHIFT: u8 = 16;
pub const GPIO_MODER8_MASK: u32 = 196608;
pub const GPIO_MODER9_SHIFT: u8 = 18;
pub const GPIO_MODER9_MASK: u32 = 786432;
pub const GPIO_MODER10_SHIFT: u8 = 20;
pub const GPIO_MODER10_MASK: u32 = 3145728;
pub const GPIO_MODER11_SHIFT: u8 = 22;
pub const GPIO_MODER11_MASK: u32 = 12582912;
pub const GPIO_MODER12_SHIFT: u8 = 24;
pub const GPIO_MODER12_MASK: u32 = 50331648;
pub const GPIO_MODER13_SHIFT: u8 = 26;
pub const GPIO_MODER13_MASK: u32 = 201326592;
pub const GPIO_MODER14_SHIFT: u8 = 28;
pub const GPIO_MODER14_MASK: u32 = 805306368;
pub const GPIO_MODER15_SHIFT: u8 = 30;
pub const GPIO_MODER15_MASK: u32 = 3221225472;
pub const GPIO_OSPEED_2MHz: u8 = 0;
pub const GPIO_OSPEED_25MHz: u8 = 1;
pub const GPIO_OSPEED_50MHz: u8 = 2;
pub const GPIO_OSPEED_100MHz: u8 = 3;
pub const GPIO_OSPEED0_SHIFT: u8 = 0;
pub const GPIO_OSPEED0_MASK: u8 = 3;
pub const GPIO_OSPEED1_SHIFT: u8 = 2;
pub const GPIO_OSPEED1_MASK: u8 = 12;
pub const GPIO_OSPEED2_SHIFT: u8 = 4;
pub const GPIO_OSPEED2_MASK: u8 = 48;
pub const GPIO_OSPEED3_SHIFT: u8 = 6;
pub const GPIO_OSPEED3_MASK: u8 = 192;
pub const GPIO_OSPEED4_SHIFT: u8 = 8;
pub const GPIO_OSPEED4_MASK: u16 = 768;
pub const GPIO_OSPEED5_SHIFT: u8 = 10;
pub const GPIO_OSPEED5_MASK: u16 = 3072;
pub const GPIO_OSPEED6_SHIFT: u8 = 12;
pub const GPIO_OSPEED6_MASK: u16 = 12288;
pub const GPIO_OSPEED7_SHIFT: u8 = 14;
pub const GPIO_OSPEED7_MASK: u16 = 49152;
pub const GPIO_OSPEED8_SHIFT: u8 = 16;
pub const GPIO_OSPEED8_MASK: u32 = 196608;
pub const GPIO_OSPEED9_SHIFT: u8 = 18;
pub const GPIO_OSPEED9_MASK: u32 = 786432;
pub const GPIO_OSPEED10_SHIFT: u8 = 20;
pub const GPIO_OSPEED10_MASK: u32 = 3145728;
pub const GPIO_OSPEED11_SHIFT: u8 = 22;
pub const GPIO_OSPEED11_MASK: u32 = 12582912;
pub const GPIO_OSPEED12_SHIFT: u8 = 24;
pub const GPIO_OSPEED12_MASK: u32 = 50331648;
pub const GPIO_OSPEED13_SHIFT: u8 = 26;
pub const GPIO_OSPEED13_MASK: u32 = 201326592;
pub const GPIO_OSPEED14_SHIFT: u8 = 28;
pub const GPIO_OSPEED14_MASK: u32 = 805306368;
pub const GPIO_OSPEED15_SHIFT: u8 = 30;
pub const GPIO_OSPEED15_MASK: u32 = 3221225472;
pub const GPIO_PUPDR_NONE: u8 = 0;
pub const GPIO_PUPDR_PULLUP: u8 = 1;
pub const GPIO_PUPDR_PULLDOWN: u8 = 2;
pub const GPIO_PUPDR0_SHIFT: u8 = 0;
pub const GPIO_PUPDR0_MASK: u8 = 3;
pub const GPIO_PUPDR1_SHIFT: u8 = 2;
pub const GPIO_PUPDR1_MASK: u8 = 12;
pub const GPIO_PUPDR2_SHIFT: u8 = 4;
pub const GPIO_PUPDR2_MASK: u8 = 48;
pub const GPIO_PUPDR3_SHIFT: u8 = 6;
pub const GPIO_PUPDR3_MASK: u8 = 192;
pub const GPIO_PUPDR4_SHIFT: u8 = 8;
pub const GPIO_PUPDR4_MASK: u16 = 768;
pub const GPIO_PUPDR5_SHIFT: u8 = 10;
pub const GPIO_PUPDR5_MASK: u16 = 3072;
pub const GPIO_PUPDR6_SHIFT: u8 = 12;
pub const GPIO_PUPDR6_MASK: u16 = 12288;
pub const GPIO_PUPDR7_SHIFT: u8 = 14;
pub const GPIO_PUPDR7_MASK: u16 = 49152;
pub const GPIO_PUPDR8_SHIFT: u8 = 16;
pub const GPIO_PUPDR8_MASK: u32 = 196608;
pub const GPIO_PUPDR9_SHIFT: u8 = 18;
pub const GPIO_PUPDR9_MASK: u32 = 786432;
pub const GPIO_PUPDR10_SHIFT: u8 = 20;
pub const GPIO_PUPDR10_MASK: u32 = 3145728;
pub const GPIO_PUPDR11_SHIFT: u8 = 22;
pub const GPIO_PUPDR11_MASK: u32 = 12582912;
pub const GPIO_PUPDR12_SHIFT: u8 = 24;
pub const GPIO_PUPDR12_MASK: u32 = 50331648;
pub const GPIO_PUPDR13_SHIFT: u8 = 26;
pub const GPIO_PUPDR13_MASK: u32 = 201326592;
pub const GPIO_PUPDR14_SHIFT: u8 = 28;
pub const GPIO_PUPDR14_MASK: u32 = 805306368;
pub const GPIO_PUPDR15_SHIFT: u8 = 30;
pub const GPIO_PUPDR15_MASK: u32 = 3221225472;
pub const GPIO_LCKK: u32 = 65536;
pub const GPIO_AFRL0_SHIFT: u8 = 0;
pub const GPIO_AFRL0_MASK: u8 = 15;
pub const GPIO_AFRL1_SHIFT: u8 = 4;
pub const GPIO_AFRL1_MASK: u8 = 240;
pub const GPIO_AFRL2_SHIFT: u8 = 8;
pub const GPIO_AFRL2_MASK: u16 = 3840;
pub const GPIO_AFRL3_SHIFT: u8 = 12;
pub const GPIO_AFRL3_MASK: u16 = 61440;
pub const GPIO_AFRL4_SHIFT: u8 = 16;
pub const GPIO_AFRL4_MASK: u32 = 983040;
pub const GPIO_AFRL5_SHIFT: u8 = 20;
pub const GPIO_AFRL5_MASK: u32 = 15728640;
pub const GPIO_AFRL6_SHIFT: u8 = 24;
pub const GPIO_AFRL6_MASK: u32 = 251658240;
pub const GPIO_AFRL7_SHIFT: u8 = 28;
pub const GPIO_AFRL7_MASK: u32 = 4026531840;
pub const GPIO_AFRH8_SHIFT: u8 = 0;
pub const GPIO_AFRH8_MASK: u8 = 15;
pub const GPIO_AFRH9_SHIFT: u8 = 4;
pub const GPIO_AFRH9_MASK: u8 = 240;
pub const GPIO_AFRH10_SHIFT: u8 = 8;
pub const GPIO_AFRH10_MASK: u16 = 3840;
pub const GPIO_AFRH11_SHIFT: u8 = 12;
pub const GPIO_AFRH11_MASK: u16 = 61440;
pub const GPIO_AFRH12_SHIFT: u8 = 16;
pub const GPIO_AFRH12_MASK: u32 = 983040;
pub const GPIO_AFRH13_SHIFT: u8 = 20;
pub const GPIO_AFRH13_MASK: u32 = 15728640;
pub const GPIO_AFRH14_SHIFT: u8 = 24;
pub const GPIO_AFRH14_MASK: u32 = 251658240;
pub const GPIO_AFRH15_SHIFT: u8 = 28;
pub const GPIO_AFRH15_MASK: u32 = 4026531840;
pub const GPIO_MODE_SHIFT: u8 = 18;
pub const GPIO_MODE_MASK: u32 = 786432;
pub const GPIO_INPUT: u8 = 0;
pub const GPIO_OUTPUT: u32 = 262144;
pub const GPIO_ALT: u32 = 524288;
pub const GPIO_ANALOG: u32 = 786432;
pub const GPIO_PUPD_SHIFT: u8 = 16;
pub const GPIO_PUPD_MASK: u32 = 196608;
pub const GPIO_FLOAT: u8 = 0;
pub const GPIO_PULLUP: u32 = 65536;
pub const GPIO_PULLDOWN: u32 = 131072;
pub const GPIO_AF_SHIFT: u8 = 12;
pub const GPIO_AF_MASK: u16 = 61440;
pub const GPIO_AF0: u8 = 0;
pub const GPIO_AF1: u16 = 4096;
pub const GPIO_AF2: u16 = 8192;
pub const GPIO_AF3: u16 = 12288;
pub const GPIO_AF4: u16 = 16384;
pub const GPIO_AF5: u16 = 20480;
pub const GPIO_AF6: u16 = 24576;
pub const GPIO_AF7: u16 = 28672;
pub const GPIO_AF8: u16 = 32768;
pub const GPIO_AF9: u16 = 36864;
pub const GPIO_AF10: u16 = 40960;
pub const GPIO_AF11: u16 = 45056;
pub const GPIO_AF12: u16 = 49152;
pub const GPIO_AF13: u16 = 53248;
pub const GPIO_AF14: u16 = 57344;
pub const GPIO_AF15: u16 = 61440;
pub const GPIO_SPEED_SHIFT: u8 = 10;
pub const GPIO_SPEED_MASK: u16 = 3072;
pub const GPIO_SPEED_2MHz: u8 = 0;
pub const GPIO_SPEED_25MHz: u16 = 1024;
pub const GPIO_SPEED_50MHz: u16 = 2048;
pub const GPIO_SPEED_100MHz: u16 = 3072;
pub const GPIO_OPENDRAIN: u16 = 512;
pub const GPIO_PUSHPULL: u8 = 0;
pub const GPIO_OUTPUT_SET: u16 = 256;
pub const GPIO_OUTPUT_CLEAR: u8 = 0;
pub const GPIO_EXTI: u16 = 256;
pub const GPIO_PORT_SHIFT: u8 = 4;
pub const GPIO_PORT_MASK: u8 = 240;
pub const GPIO_PORTA: u8 = 0;
pub const GPIO_PORTB: u8 = 16;
pub const GPIO_PORTC: u8 = 32;
pub const GPIO_PORTD: u8 = 48;
pub const GPIO_PORTE: u8 = 64;
pub const GPIO_PORTF: u8 = 80;
pub const GPIO_PORTG: u8 = 96;
pub const GPIO_PORTH: u8 = 112;
pub const GPIO_PORTI: u8 = 128;
pub const GPIO_PORTJ: u8 = 144;
pub const GPIO_PORTK: u8 = 160;
pub const GPIO_PIN_SHIFT: u8 = 0;
pub const GPIO_PIN_MASK: u8 = 15;
pub const GPIO_PIN0: u8 = 0;
pub const GPIO_PIN1: u8 = 1;
pub const GPIO_PIN2: u8 = 2;
pub const GPIO_PIN3: u8 = 3;
pub const GPIO_PIN4: u8 = 4;
pub const GPIO_PIN5: u8 = 5;
pub const GPIO_PIN6: u8 = 6;
pub const GPIO_PIN7: u8 = 7;
pub const GPIO_PIN8: u8 = 8;
pub const GPIO_PIN9: u8 = 9;
pub const GPIO_PIN10: u8 = 10;
pub const GPIO_PIN11: u8 = 11;
pub const GPIO_PIN12: u8 = 12;
pub const GPIO_PIN13: u8 = 13;
pub const GPIO_PIN14: u8 = 14;
pub const GPIO_PIN15: u8 = 15;
pub const __DEBUG_ASSERT_FILE__: u8 = 0;
pub const __DEBUG_ASSERT_LINE__: u8 = 0;
pub const __ASSERT_FILE__: u8 = 0;
pub const __ASSERT_LINE__: u8 = 0;
pub const EPERM: u8 = 1;
pub const EPERM_STR: &[u8; 24] = b"Operation not permitted\0";
pub const ENOENT: u8 = 2;
pub const ENOENT_STR: &[u8; 26] = b"No such file or directory\0";
pub const ESRCH: u8 = 3;
pub const ESRCH_STR: &[u8; 16] = b"No such process\0";
pub const EINTR: u8 = 4;
pub const EINTR_STR: &[u8; 24] = b"Interrupted system call\0";
pub const EIO: u8 = 5;
pub const EIO_STR: &[u8; 10] = b"I/O error\0";
pub const ENXIO: u8 = 6;
pub const ENXIO_STR: &[u8; 26] = b"No such device or address\0";
pub const E2BIG: u8 = 7;
pub const E2BIG_STR: &[u8; 18] = b"Arg list too long\0";
pub const ENOEXEC: u8 = 8;
pub const ENOEXEC_STR: &[u8; 18] = b"Exec format error\0";
pub const EBADF: u8 = 9;
pub const EBADF_STR: &[u8; 16] = b"Bad file number\0";
pub const ECHILD: u8 = 10;
pub const ECHILD_STR: &[u8; 19] = b"No child processes\0";
pub const EAGAIN: u8 = 11;
pub const EAGAIN_STR: &[u8; 10] = b"Try again\0";
pub const ENOMEM: u8 = 12;
pub const ENOMEM_STR: &[u8; 14] = b"Out of memory\0";
pub const EACCES: u8 = 13;
pub const EACCES_STR: &[u8; 18] = b"Permission denied\0";
pub const EFAULT: u8 = 14;
pub const EFAULT_STR: &[u8; 12] = b"Bad address\0";
pub const ENOTBLK: u8 = 15;
pub const ENOTBLK_STR: &[u8; 22] = b"Block device required\0";
pub const EBUSY: u8 = 16;
pub const EBUSY_STR: &[u8; 24] = b"Device or resource busy\0";
pub const EEXIST: u8 = 17;
pub const EEXIST_STR: &[u8; 12] = b"File exists\0";
pub const EXDEV: u8 = 18;
pub const EXDEV_STR: &[u8; 18] = b"Cross-device link\0";
pub const ENODEV: u8 = 19;
pub const ENODEV_STR: &[u8; 15] = b"No such device\0";
pub const ENOTDIR: u8 = 20;
pub const ENOTDIR_STR: &[u8; 16] = b"Not a directory\0";
pub const EISDIR: u8 = 21;
pub const EISDIR_STR: &[u8; 15] = b"Is a directory\0";
pub const EINVAL: u8 = 22;
pub const EINVAL_STR: &[u8; 17] = b"Invalid argument\0";
pub const ENFILE: u8 = 23;
pub const ENFILE_STR: &[u8; 20] = b"File table overflow\0";
pub const EMFILE: u8 = 24;
pub const EMFILE_STR: &[u8; 20] = b"Too many open files\0";
pub const ENOTTY: u8 = 25;
pub const ENOTTY_STR: &[u8; 17] = b"Not a typewriter\0";
pub const ETXTBSY: u8 = 26;
pub const ETXTBSY_STR: &[u8; 15] = b"Text file busy\0";
pub const EFBIG: u8 = 27;
pub const EFBIG_STR: &[u8; 15] = b"File too large\0";
pub const ENOSPC: u8 = 28;
pub const ENOSPC_STR: &[u8; 24] = b"No space left on device\0";
pub const ESPIPE: u8 = 29;
pub const ESPIPE_STR: &[u8; 13] = b"Illegal seek\0";
pub const EROFS: u8 = 30;
pub const EROFS_STR: &[u8; 22] = b"Read-only file system\0";
pub const EMLINK: u8 = 31;
pub const EMLINK_STR: &[u8; 15] = b"Too many links\0";
pub const EPIPE: u8 = 32;
pub const EPIPE_STR: &[u8; 12] = b"Broken pipe\0";
pub const EDOM: u8 = 33;
pub const EDOM_STR: &[u8; 36] = b"Math argument out of domain of func\0";
pub const ERANGE: u8 = 34;
pub const ERANGE_STR: &[u8; 30] = b"Math result not representable\0";
pub const EDEADLK: u8 = 35;
pub const EDEADLK_STR: &[u8; 30] = b"Resource deadlock would occur\0";
pub const ENAMETOOLONG: u8 = 36;
pub const ENAMETOOLONG_STR: &[u8; 19] = b"File name too long\0";
pub const ENOLCK: u8 = 37;
pub const ENOLCK_STR: &[u8; 26] = b"No record locks available\0";
pub const ENOSYS: u8 = 38;
pub const ENOSYS_STR: &[u8; 27] = b"Invalid system call number\0";
pub const ENOTEMPTY: u8 = 39;
pub const ENOTEMPTY_STR: &[u8; 20] = b"Directory not empty\0";
pub const ELOOP: u8 = 40;
pub const ELOOP_STR: &[u8; 36] = b"Too many symbolic links encountered\0";
pub const EWOULDBLOCK: u8 = 11;
pub const EWOULDBLOCK_STR: &[u8; 22] = b"Operation would block\0";
pub const ENOMSG: u8 = 42;
pub const ENOMSG_STR: &[u8; 27] = b"No message of desired type\0";
pub const EIDRM: u8 = 43;
pub const EIDRM_STR: &[u8; 19] = b"Identifier removed\0";
pub const ECHRNG: u8 = 44;
pub const ECHRNG_STR: &[u8; 28] = b"Channel number out of range\0";
pub const EL2NSYNC: u8 = 45;
pub const EL2NSYNC_STR: &[u8; 25] = b"Level 2 not synchronized\0";
pub const EL3HLT: u8 = 46;
pub const EL3HLT_STR: &[u8; 15] = b"Level 3 halted\0";
pub const EL3RST: u8 = 47;
pub const EL3RST_STR: &[u8; 14] = b"Level 3 reset\0";
pub const ELNRNG: u8 = 48;
pub const ELNRNG_STR: &[u8; 25] = b"Link number out of range\0";
pub const EUNATCH: u8 = 49;
pub const EUNATCH_STR: &[u8; 29] = b"Protocol driver not attached\0";
pub const ENOCSI: u8 = 50;
pub const ENOCSI_STR: &[u8; 27] = b"No CSI structure available\0";
pub const EL2HLT: u8 = 51;
pub const EL2HLT_STR: &[u8; 15] = b"Level 2 halted\0";
pub const EBADE: u8 = 52;
pub const EBADE_STR: &[u8; 17] = b"Invalid exchange\0";
pub const EBADR: u8 = 53;
pub const EBADR_STR: &[u8; 27] = b"Invalid request descriptor\0";
pub const EXFULL: u8 = 54;
pub const EXFULL_STR: &[u8; 14] = b"Exchange full\0";
pub const ENOANO: u8 = 55;
pub const ENOANO_STR: &[u8; 9] = b"No anode\0";
pub const EBADRQC: u8 = 56;
pub const EBADRQC_STR: &[u8; 21] = b"Invalid request code\0";
pub const EBADSLT: u8 = 57;
pub const EBADSLT_STR: &[u8; 13] = b"Invalid slot\0";
pub const EDEADLOCK: u8 = 35;
pub const EDEADLOCK_STR: &[u8; 28] = b"File locking deadlock error\0";
pub const EBFONT: u8 = 59;
pub const EBFONT_STR: &[u8; 21] = b"Bad font file format\0";
pub const ENOSTR: u8 = 60;
pub const ENOSTR_STR: &[u8; 20] = b"Device not a stream\0";
pub const ENODATA: u8 = 61;
pub const ENODATA_STR: &[u8; 18] = b"No data available\0";
pub const ETIME: u8 = 62;
pub const ETIME_STR: &[u8; 14] = b"Timer expired\0";
pub const ENOSR: u8 = 63;
pub const ENOSR_STR: &[u8; 25] = b"Out of streams resources\0";
pub const ENONET: u8 = 64;
pub const ENONET_STR: &[u8; 30] = b"Machine is not on the network\0";
pub const ENOPKG: u8 = 65;
pub const ENOPKG_STR: &[u8; 22] = b"Package not installed\0";
pub const EREMOTE: u8 = 66;
pub const EREMOTE_STR: &[u8; 17] = b"Object is remote\0";
pub const ENOLINK: u8 = 67;
pub const ENOLINK_STR: &[u8; 22] = b"Link has been severed\0";
pub const EADV: u8 = 68;
pub const EADV_STR: &[u8; 16] = b"Advertise error\0";
pub const ESRMNT: u8 = 69;
pub const ESRMNT_STR: &[u8; 14] = b"Srmount error\0";
pub const ECOMM: u8 = 70;
pub const ECOMM_STR: &[u8; 28] = b"Communication error on send\0";
pub const EPROTO: u8 = 71;
pub const EPROTO_STR: &[u8; 15] = b"Protocol error\0";
pub const EMULTIHOP: u8 = 72;
pub const EMULTIHOP_STR: &[u8; 19] = b"Multihop attempted\0";
pub const EDOTDOT: u8 = 73;
pub const EDOTDOT_STR: &[u8; 19] = b"RFS specific error\0";
pub const EBADMSG: u8 = 74;
pub const EBADMSG_STR: &[u8; 19] = b"Not a data message\0";
pub const EOVERFLOW: u8 = 75;
pub const EOVERFLOW_STR: &[u8; 38] = b"Value too large for defined data type\0";
pub const ENOTUNIQ: u8 = 76;
pub const ENOTUNIQ_STR: &[u8; 27] = b"Name not unique on network\0";
pub const EBADFD: u8 = 77;
pub const EBADFD_STR: &[u8; 29] = b"File descriptor in bad state\0";
pub const EREMCHG: u8 = 78;
pub const EREMCHG_STR: &[u8; 23] = b"Remote address changed\0";
pub const ELIBACC: u8 = 79;
pub const ELIBACC_STR: &[u8; 39] = b"Can not access a needed shared library\0";
pub const ELIBBAD: u8 = 80;
pub const ELIBBAD_STR: &[u8; 37] = b"Accessing a corrupted shared library\0";
pub const ELIBSCN: u8 = 81;
pub const ELIBSCN_STR: &[u8; 32] = b".lib section in a.out corrupted\0";
pub const ELIBMAX: u8 = 82;
pub const ELIBMAX_STR: &[u8; 48] = b"Attempting to link in too many shared libraries\0";
pub const ELIBEXEC: u8 = 83;
pub const ELIBEXEC_STR: &[u8; 38] = b"Cannot exec a shared library directly\0";
pub const EILSEQ: u8 = 84;
pub const EILSEQ_STR: &[u8; 22] = b"Illegal byte sequence\0";
pub const ERESTART: u8 = 85;
pub const ERESTART_STR: &[u8; 44] = b"Interrupted system call should be restarted\0";
pub const ESTRPIPE: u8 = 86;
pub const ESTRPIPE_STR: &[u8; 19] = b"Streams pipe error\0";
pub const EUSERS: u8 = 87;
pub const EUSERS_STR: &[u8; 15] = b"Too many users\0";
pub const ENOTSOCK: u8 = 88;
pub const ENOTSOCK_STR: &[u8; 31] = b"Socket operation on non-socket\0";
pub const EDESTADDRREQ: u8 = 89;
pub const EDESTADDRREQ_STR: &[u8; 29] = b"Destination address required\0";
pub const EMSGSIZE: u8 = 90;
pub const EMSGSIZE_STR: &[u8; 17] = b"Message too long\0";
pub const EPROTOTYPE: u8 = 91;
pub const EPROTOTYPE_STR: &[u8; 31] = b"Protocol wrong type for socket\0";
pub const ENOPROTOOPT: u8 = 92;
pub const ENOPROTOOPT_STR: &[u8; 23] = b"Protocol not available\0";
pub const EPROTONOSUPPORT: u8 = 93;
pub const EPROTONOSUPPORT_STR: &[u8; 23] = b"Protocol not supported\0";
pub const ESOCKTNOSUPPORT: u8 = 94;
pub const ESOCKTNOSUPPORT_STR: &[u8; 26] = b"Socket type not supported\0";
pub const EOPNOTSUPP: u8 = 95;
pub const EOPNOTSUPP_STR: &[u8; 46] = b"Operation not supported on transport endpoint\0";
pub const EPFNOSUPPORT: u8 = 96;
pub const EPFNOSUPPORT_STR: &[u8; 30] = b"Protocol family not supported\0";
pub const EAFNOSUPPORT: u8 = 97;
pub const EAFNOSUPPORT_STR: &[u8; 41] = b"Address family not supported by protocol\0";
pub const EADDRINUSE: u8 = 98;
pub const EADDRINUSE_STR: &[u8; 23] = b"Address already in use\0";
pub const EADDRNOTAVAIL: u8 = 99;
pub const EADDRNOTAVAIL_STR: &[u8; 32] = b"Cannot assign requested address\0";
pub const ENETDOWN: u8 = 100;
pub const ENETDOWN_STR: &[u8; 16] = b"Network is down\0";
pub const ENETUNREACH: u8 = 101;
pub const ENETUNREACH_STR: &[u8; 23] = b"Network is unreachable\0";
pub const ENETRESET: u8 = 102;
pub const ENETRESET_STR: &[u8; 44] = b"Network dropped connection because of reset\0";
pub const ECONNABORTED: u8 = 103;
pub const ECONNABORTED_STR: &[u8; 33] = b"Software caused connection abort\0";
pub const ECONNRESET: u8 = 104;
pub const ECONNRESET_STR: &[u8; 25] = b"Connection reset by peer\0";
pub const ENOBUFS: u8 = 105;
pub const ENOBUFS_STR: &[u8; 26] = b"No buffer space available\0";
pub const EISCONN: u8 = 106;
pub const EISCONN_STR: &[u8; 40] = b"Transport endpoint is already connected\0";
pub const ENOTCONN: u8 = 107;
pub const ENOTCONN_STR: &[u8; 36] = b"Transport endpoint is not connected\0";
pub const ESHUTDOWN: u8 = 108;
pub const ESHUTDOWN_STR: &[u8; 46] = b"Cannot send after transport endpoint shutdown\0";
pub const ETOOMANYREFS: u8 = 109;
pub const ETOOMANYREFS_STR: &[u8; 35] = b"Too many references: cannot splice\0";
pub const ETIMEDOUT: u8 = 110;
pub const ETIMEDOUT_STR: &[u8; 21] = b"Connection timed out\0";
pub const ECONNREFUSED: u8 = 111;
pub const ECONNREFUSED_STR: &[u8; 19] = b"Connection refused\0";
pub const EHOSTDOWN: u8 = 112;
pub const EHOSTDOWN_STR: &[u8; 13] = b"Host is down\0";
pub const EHOSTUNREACH: u8 = 113;
pub const EHOSTUNREACH_STR: &[u8; 17] = b"No route to host\0";
pub const EALREADY: u8 = 114;
pub const EALREADY_STR: &[u8; 30] = b"Operation already in progress\0";
pub const EINPROGRESS: u8 = 115;
pub const EINPROGRESS_STR: &[u8; 26] = b"Operation now in progress\0";
pub const ESTALE: u8 = 116;
pub const ESTALE_STR: &[u8; 18] = b"Stale file handle\0";
pub const EUCLEAN: u8 = 117;
pub const EUCLEAN_STR: &[u8; 25] = b"Structure needs cleaning\0";
pub const ENOTNAM: u8 = 118;
pub const ENOTNAM_STR: &[u8; 28] = b"Not a XENIX named type file\0";
pub const ENAVAIL: u8 = 119;
pub const ENAVAIL_STR: &[u8; 30] = b"No XENIX semaphores available\0";
pub const EISNAM: u8 = 120;
pub const EISNAM_STR: &[u8; 21] = b"Is a named type file\0";
pub const EREMOTEIO: u8 = 121;
pub const EREMOTEIO_STR: &[u8; 17] = b"Remote I/O error\0";
pub const EDQUOT: u8 = 122;
pub const EDQUOT_STR: &[u8; 15] = b"Quota exceeded\0";
pub const ENOMEDIUM: u8 = 123;
pub const ENOMEDIUM_STR: &[u8; 16] = b"No medium found\0";
pub const EMEDIUMTYPE: u8 = 124;
pub const EMEDIUMTYPE_STR: &[u8; 18] = b"Wrong medium type\0";
pub const ECANCELED: u8 = 125;
pub const ECANCELED_STR: &[u8; 20] = b"Operation cancelled\0";
pub const ENOKEY: u8 = 126;
pub const ENOKEY_STR: &[u8; 27] = b"Required key not available\0";
pub const EKEYEXPIRED: u8 = 127;
pub const EKEYEXPIRED_STR: &[u8; 16] = b"Key has expired\0";
pub const EKEYREVOKED: u8 = 128;
pub const EKEYREVOKED_STR: &[u8; 21] = b"Key has been revoked\0";
pub const EKEYREJECTED: u8 = 129;
pub const EKEYREJECTED_STR: &[u8; 28] = b"Key was rejected by service\0";
pub const EOWNERDEAD: u8 = 130;
pub const EOWNERDEAD_STR: &[u8; 20] = b"Previous owner died\0";
pub const ENOTRECOVERABLE: u8 = 131;
pub const ENOTRECOVERABLE_STR: &[u8; 22] = b"State not recoverable\0";
pub const ERFKILL: u8 = 132;
pub const ERFKILL_STR: &[u8; 38] = b"Operation not possible due to RF-kill\0";
pub const EHWPOISON: u8 = 133;
pub const EHWPOISON_STR: &[u8; 31] = b"Memory page has hardware error\0";
pub const ELBIN: u8 = 134;
pub const ELBIN_STR: &[u8; 16] = b"Inode is remote\0";
pub const EFTYPE: u8 = 135;
pub const EFTYPE_STR: &[u8; 34] = b"Inappropriate file type or format\0";
pub const ENMFILE: u8 = 136;
pub const ENMFILE_STR: &[u8; 14] = b"No more files\0";
pub const EPROCLIM: u8 = 137;
pub const EPROCLIM_STR: &[u8; 42] = b"Limit would be exceeded by attempted fork\0";
pub const ENOTSUP: u8 = 138;
pub const ENOTSUP_STR: &[u8; 14] = b"Not supported\0";
pub const ENOSHARE: u8 = 139;
pub const ENOSHARE_STR: &[u8; 29] = b"No such host or network path\0";
pub const ECASECLASH: u8 = 140;
pub const ECASECLASH_STR: &[u8; 36] = b"Filename exists with different case\0";
pub const __ELASTERROR: u16 = 2000;
pub const CLK_TCK: u8 = 100;
pub const CLOCKS_PER_SEC: u8 = 100;
pub const CLOCK_REALTIME: u8 = 0;
pub const CLOCK_MONOTONIC: u8 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u8 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u8 = 3;
pub const CLOCK_BOOTTIME: u8 = 4;
pub const TIMER_ABSTIME: u8 = 1;
pub const TIME_UTC: u8 = 1;
pub const SEM_PRIO_NONE: u8 = 0;
pub const SEM_PRIO_INHERIT: u8 = 1;
pub const SEM_PRIO_PROTECT: u8 = 2;
pub const SEM_PRIO_MASK: u8 = 3;
pub const SEM_TYPE_MUTEX: u8 = 4;
pub const __HAVE_KERNEL_GLOBALS: u8 = 1;
pub const CLOCK_MASK: u8 = 7;
pub const CLOCK_SHIFT: u8 = 3;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const MSEC_PER_SEC: u16 = 1000;
pub const DSEC_PER_SEC: u8 = 10;
pub const HSEC_PER_SEC: u8 = 2;
pub const NSEC_PER_HSEC: u32 = 500000000;
pub const USEC_PER_HSEC: u32 = 500000;
pub const MSEC_PER_HSEC: u16 = 500;
pub const DSEC_PER_HSEC: u8 = 5;
pub const NSEC_PER_DSEC: u32 = 100000000;
pub const USEC_PER_DSEC: u32 = 100000;
pub const MSEC_PER_DSEC: u8 = 100;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_MSEC: u16 = 1000;
pub const NSEC_PER_USEC: u16 = 1000;
pub const SEC_PER_MIN: u8 = 60;
pub const NSEC_PER_MIN: u64 = 60000000000;
pub const USEC_PER_MIN: u32 = 60000000;
pub const MSEC_PER_MIN: u16 = 60000;
pub const DSEC_PER_MIN: u16 = 600;
pub const HSEC_PER_MIN: u8 = 120;
pub const MIN_PER_HOUR: u8 = 60;
pub const NSEC_PER_HOUR: u64 = 3600000000000;
pub const USEC_PER_HOUR: u32 = 3600000000;
pub const MSEC_PER_HOUR: u32 = 3600000;
pub const DSEC_PER_HOUR: u16 = 36000;
pub const HSEC_PER_HOUR: u16 = 7200;
pub const SEC_PER_HOUR: u16 = 3600;
pub const HOURS_PER_DAY: u8 = 24;
pub const SEC_PER_DAY: u32 = 86400;
pub const USEC_PER_TICK: u16 = 10000;
pub const TICK_PER_HOUR: u32 = 360000;
pub const TICK_PER_MIN: u16 = 6000;
pub const TICK_PER_SEC: u8 = 100;
pub const TICK_PER_MSEC: u8 = 0;
pub const TICK_PER_DSEC: u8 = 10;
pub const TICK_PER_HSEC: u8 = 50;
pub const MSEC_PER_TICK: u8 = 10;
pub const NSEC_PER_TICK: u32 = 10000000;
pub const INITIAL_SYSTEM_TIMER_TICKS: u8 = 0;
pub const SECSPERMIN: u8 = 60;
pub const MINSPERHOUR: u8 = 60;
pub const HOURSPERDAY: u8 = 24;
pub const DAYSPERWEEK: u8 = 7;
pub const DAYSPERNYEAR: u16 = 365;
pub const DAYSPERLYEAR: u16 = 366;
pub const MONSPERYEAR: u8 = 12;
pub const TM_SUNDAY: u8 = 0;
pub const TM_MONDAY: u8 = 1;
pub const TM_TUESDAY: u8 = 2;
pub const TM_WEDNESDAY: u8 = 3;
pub const TM_THURSDAY: u8 = 4;
pub const TM_FRIDAY: u8 = 5;
pub const TM_SATURDAY: u8 = 6;
pub const TM_JANUARY: u8 = 0;
pub const TM_FEBRUARY: u8 = 1;
pub const TM_MARCH: u8 = 2;
pub const TM_APRIL: u8 = 3;
pub const TM_MAY: u8 = 4;
pub const TM_JUNE: u8 = 5;
pub const TM_JULY: u8 = 6;
pub const TM_AUGUST: u8 = 7;
pub const TM_SEPTEMBER: u8 = 8;
pub const TM_OCTOBER: u8 = 9;
pub const TM_NOVEMBER: u8 = 10;
pub const TM_DECEMBER: u8 = 11;
pub const TM_YEAR_BASE: u16 = 1900;
pub const TM_WDAY_BASE: u8 = 1;
pub const EPOCH_YEAR: u16 = 1970;
pub const EPOCH_WDAY: u8 = 4;
pub const USBHOST_DEVADDR_HASHSIZE: u8 = 8;
pub const USBHOST_DEVADDR_HASHMASK: u8 = 7;
pub type _int8_t = cty::c_schar;
pub type _uint8_t = cty::c_uchar;
pub type _int16_t = cty::c_short;
pub type _uint16_t = cty::c_ushort;
pub type _int32_t = cty::c_int;
pub type _uint32_t = cty::c_uint;
pub type _int64_t = cty::c_longlong;
pub type _uint64_t = cty::c_ulonglong;
pub type _intmax_t = _int64_t;
pub type _uintmax_t = _uint64_t;
pub type _wchar_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type _size_t = cty::c_uint;
pub type irqstate_t = cty::c_ushort;
pub type int_least8_t = _int8_t;
pub type uint_least8_t = _uint8_t;
pub type int_least16_t = _int16_t;
pub type uint_least16_t = _uint16_t;
pub type int_least24_t = _int32_t;
pub type uint_least24_t = _uint32_t;
pub type int_least32_t = _int32_t;
pub type uint_least32_t = _uint32_t;
pub type int_least64_t = _int64_t;
pub type uint_least64_t = _uint64_t;
pub type int_fast8_t = _int8_t;
pub type uint_fast8_t = _uint8_t;
pub type int_fast16_t = cty::c_int;
pub type uint_fast16_t = cty::c_uint;
pub type int_fast24_t = _int32_t;
pub type uint_fast24_t = _uint32_t;
pub type int_fast32_t = _int32_t;
pub type uint_fast32_t = _uint32_t;
pub type int_fast64_t = _int64_t;
pub type uint_fast64_t = _uint64_t;
pub type intmax_t = _intmax_t;
pub type uintmax_t = _uintmax_t;
extern "C" {
    #[doc = " Name: stm32_bringup\n\n Description:\n   Perform architecture specific initialization\n\n   CONFIG_BOARDCTL=y:\n     If CONFIG_NSH_ARCHINITIALIZE=y:\n       Called from the NSH library (or other application)\n     Otherwise, assumed to be called from some other application.\n\n   Otherwise CONFIG_BOARD_LATE_INITIALIZE=y:\n     Called from board_late_initialize().\n\n   Otherwise, bad news:  Never called\n"]
    pub fn stm32_bringup() -> cty::c_int;
}
extern "C" {
    pub fn stm32_spidev_initialize();
}
extern "C" {
    #[doc = " Name: stm32_dma_alloc_init\n\n Description:\n   Called to create a FAT DMA allocator\n\n Returned Value:\n   0 on success or -ENOMEM\n"]
    pub fn stm32_dma_alloc_init();
}
pub type mode_t = cty::c_uint;
pub type rsize_t = _size_t;
pub type uid_t = cty::c_uint;
pub type gid_t = cty::c_uint;
pub type dev_t = u32;
pub type ino_t = u16;
pub type nlink_t = u16;
pub type pid_t = cty::c_int;
pub type id_t = cty::c_int;
pub type key_t = i32;
pub type wchar_t = _wchar_t;
pub type wint_t = cty::c_int;
pub type wctype_t = cty::c_int;
pub type fsblkcnt_t = u32;
pub type fsfilcnt_t = u32;
pub type blkcnt_t = u32;
pub type off_t = i32;
pub type fpos_t = i32;
pub type blksize_t = i16;
pub type socklen_t = cty::c_uint;
pub type sa_family_t = u16;
pub type clock_t = u32;
pub type time_t = u32;
pub type clockid_t = cty::c_int;
pub type timer_t = *mut cty::c_void;
pub type useconds_t = u32;
pub type suseconds_t = i32;
pub type cpu_set_t = u8;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type unchar = cty::c_uchar;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type s_char = cty::c_schar;
pub type caddr_t = *mut cty::c_char;
pub type u_int8_t = u8;
pub type u_int16_t = u16;
pub type u_int32_t = u32;
pub type u_int64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsid_s {
    pub val: [cty::c_int; 2usize],
}
pub type main_t = ::core::option::Option<
    unsafe extern "C" fn(argc: cty::c_int, argv: *mut *mut cty::c_char) -> cty::c_int,
>;
pub const ERROR: _bindgen_ty_1 = -1;
pub const OK: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = cty::c_int;
extern "C" {
    pub fn nsh_main(argc: cty::c_int, argv: *mut *mut cty::c_char) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcptcontext {
    pub sigdeliver: *mut cty::c_void,
    pub saved_regs: *mut u32,
    pub regs: *mut u32,
}
extern "C" {
    #[doc = " Public Data"]
    pub static mut g_current_regs: [*mut u32; 1usize];
}
pub type irq_t = u8;
pub type xcpt_t = ::core::option::Option<
    unsafe extern "C" fn(
        irq: cty::c_int,
        context: *mut cty::c_void,
        arg: *mut cty::c_void,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " Name: irq_attach\n\n Description:\n   Configure the IRQ subsystem so that IRQ number 'irq' is dispatched to\n   'isr' with argument 'arg'\n"]
    pub fn irq_attach(irq: cty::c_int, isr: xcpt_t, arg: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub static g_gpiobase: [u32; 11usize];
}
extern "C" {
    #[doc = " Name: stm32_configgpio\n\n Description:\n   Configure a GPIO pin based on bit-encoded description of the pin.\n   Once it is configured as Alternative (GPIO_ALT|GPIO_CNF_AFPP|...)\n   function, it must be unconfigured with stm32_unconfiggpio() with\n   the same cfgset first before it can be set to non-alternative function.\n\n Returned Value:\n   OK on success\n   ERROR on invalid port, or when pin is locked as ALT function.\n"]
    pub fn stm32_configgpio(cfgset: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: stm32_unconfiggpio\n\n Description:\n   Unconfigure a GPIO pin based on bit-encoded description of the pin, set\n   it into default HiZ state (and possibly mark it's unused) and unlock it\n   whether it was previously selected as alternative function\n   (GPIO_ALT|GPIO_CNF_AFPP|...).\n\n   This is a safety function and prevents hardware from shocks, as\n   unexpected write to the Timer Channel Output GPIO to fixed '1' or '0'\n   while it should operate in PWM mode could produce excessive on-board\n   currents and trigger over-current/alarm function.\n\n Returned Value:\n  OK on success\n  ERROR on invalid port\n"]
    pub fn stm32_unconfiggpio(cfgset: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: stm32_gpiowrite\n\n Description:\n   Write one or zero to the selected GPIO pin\n"]
    pub fn stm32_gpiowrite(pinset: u32, value: bool);
}
extern "C" {
    #[doc = " Name: stm32_gpioread\n\n Description:\n   Read one or zero from the selected GPIO pin\n"]
    pub fn stm32_gpioread(pinset: u32) -> bool;
}
extern "C" {
    #[doc = " Name: stm32_iocompensation\n\n Description:\n   Enable I/O compensation.\n\n   By default the I/O compensation cell is not used. However when the I/O\n   output buffer speed is configured in 50 MHz or 100 MHz mode, it is\n   recommended to use the compensation cell for slew rate control on I/O\n   tf(IO)out)/tr(IO)out commutation to reduce the I/O noise on power\n   supply.\n\n   The I/O compensation cell can be used only when the supply voltage\n   ranges from 2.4 to 3.6 V.\n\n Input Parameters:\n   None\n\n Returned Value:\n   None\n"]
    pub fn stm32_iocompensation();
}
extern "C" {
    #[doc = " Name: stm32_gpiosetevent\n\n Description:\n   Sets/clears GPIO based event and interrupt triggers.\n\n Input Parameters:\n  - pinset:      GPIO pin configuration\n  - risingedge:  Enables interrupt on rising edges\n  - fallingedge: Enables interrupt on falling edges\n  - event:       Generate event when set\n  - func:        When non-NULL, generate interrupt\n  - arg:         Argument passed to the interrupt callback\n\n Returned Value:\n   Zero (OK) on success; a negated errno value on failure indicating the\n   nature of the failure.\n"]
    pub fn stm32_gpiosetevent(
        pinset: u32,
        risingedge: bool,
        fallingedge: bool,
        event: bool,
        func: xcpt_t,
        arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _assert(
        filename: *const cty::c_char,
        linenum: cty::c_int,
        msg: *const cty::c_char,
        regs: *mut cty::c_void,
    );
}
extern "C" {
    pub fn __assert(
        filename: *const cty::c_char,
        linenum: cty::c_int,
        msg: *const cty::c_char,
    ) -> !;
}
extern "C" {
    pub fn __errno() -> *mut cty::c_int;
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
    pub tm_gmtoff: cty::c_long,
    pub tm_zone: *const cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn clock_settime(clockid: clockid_t, tp: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_gettime(clockid: clockid_t, tp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getres(clockid: clockid_t, res: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(pid: pid_t, clockid: *mut clockid_t) -> cty::c_int;
}
extern "C" {
    pub fn timespec_get(t: *mut timespec, b: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn timegm(tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn mktime(tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn gmtime(timep: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(timep: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime(timep: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(timep: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        s: *mut cty::c_char,
        max: usize,
        format: *const cty::c_char,
        tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        s: *const cty::c_char,
        format: *const cty::c_char,
        tm: *mut tm,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asctime(tp: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn asctime_r(tp: *const tm, buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(timep: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime_r(timep: *const time_t, buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn time(timep: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(time1: time_t, time0: time_t) -> f64;
}
extern "C" {
    pub fn timer_create(
        clockid: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: cty::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> cty::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        clockid: clockid_t,
        flags: cty::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sq_entry_s {
    pub flink: *mut sq_entry_s,
}
#[doc = " Public Type Definitions"]
pub type sq_entry_t = sq_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dq_entry_s {
    pub flink: *mut dq_entry_s,
    pub blink: *mut dq_entry_s,
}
pub type dq_entry_t = dq_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sq_queue_s {
    pub head: *mut sq_entry_t,
    pub tail: *mut sq_entry_t,
}
pub type sq_queue_t = sq_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dq_queue_s {
    pub head: *mut dq_entry_t,
    pub tail: *mut dq_entry_t,
}
pub type dq_queue_t = dq_queue_s;
extern "C" {
    pub fn sq_addafter(prev: *mut sq_entry_t, node: *mut sq_entry_t, queue: *mut sq_queue_t);
}
extern "C" {
    pub fn dq_addafter(prev: *mut dq_entry_t, node: *mut dq_entry_t, queue: *mut dq_queue_t);
}
extern "C" {
    pub fn sq_remafter(node: *mut sq_entry_t, queue: *mut sq_queue_t) -> *mut sq_entry_t;
}
extern "C" {
    pub fn dq_remafter(node: *mut dq_entry_t, queue: *mut dq_queue_t) -> *mut dq_entry_t;
}
extern "C" {
    pub fn sq_remlast(queue: *mut sq_queue_t) -> *mut sq_entry_t;
}
extern "C" {
    pub fn dq_remlast(queue: *mut dq_queue_t) -> *mut dq_entry_t;
}
extern "C" {
    pub fn sq_remfirst(queue: *mut sq_queue_t) -> *mut sq_entry_t;
}
extern "C" {
    pub fn dq_remfirst(queue: *mut dq_queue_t) -> *mut dq_entry_t;
}
extern "C" {
    pub fn sq_count(queue: *mut sq_queue_t) -> usize;
}
extern "C" {
    pub fn dq_count(queue: *mut dq_queue_t) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_s {
    pub semcount: i16,
    pub flags: u8,
    pub waitlist: dq_queue_t,
}
pub type sem_t = sem_s;
extern "C" {
    #[doc = " Public Function Prototypes"]
    pub fn sem_init(sem: *mut sem_t, pshared: cty::c_int, value: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn sem_destroy(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_wait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_timedwait(sem: *mut sem_t, abstime: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn sem_clockwait(
        sem: *mut sem_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sem_trywait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_post(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: sem_setprotocol\n\n Description:\n    Set semaphore protocol attribute.\n\n    One particularly important use of this function is when a semaphore\n    is used for inter-task communication like:\n\n      TASK A                 TASK B\n      sem_init(sem, 0, 0);\n      sem_wait(sem);\n                             sem_post(sem);\n      Awakens as holder\n\n    In this case priority inheritance can interfere with the operation of\n    the semaphore.  The problem is that when TASK A is restarted it is a\n    holder of the semaphore.  However, it never calls sem_post(sem) so it\n    becomes *permanently* a holder of the semaphore and may have its\n    priority boosted when any other task tries to acquire the semaphore.\n\n    The fix is to call sem_setprotocol(SEM_PRIO_NONE) immediately after\n    the sem_init() call so that there will be no priority inheritance\n    operations on this semaphore.\n\n Input Parameters:\n    sem      - A pointer to the semaphore whose attributes are to be\n               modified\n    protocol - The new protocol to use\n\n Returned Value:\n   This function is exposed as a non-standard application interface.  It\n   returns zero (OK) if successful.  Otherwise, -1 (ERROR) is returned and\n   the errno value is set appropriately.\n"]
    pub fn sem_setprotocol(sem: *mut sem_t, protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: sem_getprotocol\n\n Description:\n    Return the value of the semaphore protocol attribute.\n\n Input Parameters:\n    sem      - A pointer to the semaphore whose attributes are to be\n               queried.\n    protocol - The user provided location in which to store the protocol\n               value.\n\n Returned Value:\n   This function is exposed as a non-standard application interface.  It\n   returns zero (OK) if successful.  Otherwise, -1 (ERROR) is returned and\n   the errno value is set appropriately.\n"]
    pub fn sem_getprotocol(sem: *mut sem_t, protocol: *mut cty::c_int) -> cty::c_int;
}
pub type sclock_t = i32;
extern "C" {
    pub static mut g_system_ticks: clock_t;
}
extern "C" {
    #[doc = " Name: clock_timespec_compare\n\n Description:\n    Return < 0 if time ts1 is before time ts2\n    Return > 0 if time ts2 is before time ts1\n    Return 0 if time ts1 is the same as time ts2\n"]
    pub fn clock_timespec_compare(ts1: *const timespec, ts2: *const timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_timespec_add\n\n Description:\n   Add timespec ts1 to to2 and return the result in ts3\n\n Input Parameters:\n   ts1 and ts2: The two timespecs to be added\n   t23: The location to return the result (may be ts1 or ts2)\n\n Returned Value:\n   None\n"]
    pub fn clock_timespec_add(ts1: *const timespec, ts2: *const timespec, ts3: *mut timespec);
}
extern "C" {
    #[doc = " Name:  clock_timespec_subtract\n\n Description:\n   Subtract timespec ts2 from to1 and return the result in ts3.\n   Zero is returned if the time difference is negative.\n\n Input Parameters:\n   ts1 and ts2: The two timespecs to be subtracted (ts1 - ts2)\n   t23: The location to return the result (may be ts1 or ts2)\n\n Returned Value:\n   None\n"]
    pub fn clock_timespec_subtract(ts1: *const timespec, ts2: *const timespec, ts3: *mut timespec);
}
extern "C" {
    #[doc = " Name:  clock_isleapyear\n\n Description:\n    Return true if the specified year is a leap year\n"]
    pub fn clock_isleapyear(year: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_daysbeforemonth\n\n Description:\n    Get the number of days that occurred before the beginning of the month.\n"]
    pub fn clock_daysbeforemonth(month: cty::c_int, leapyear: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_dayoftheweek\n\n Description:\n    Get the day of the week\n\n Input Parameters:\n   mday  - The day of the month 1 - 31\n   month - The month of the year 1 - 12\n   year  - the year including the 1900\n\n Returned Value:\n   Zero based day of the week 0-6, 0 = Sunday, 1 = Monday... 6 = Saturday\n"]
    pub fn clock_dayoftheweek(mday: cty::c_int, month: cty::c_int, year: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  clock_calendar2utc\n\n Description:\n    Calendar/UTC conversion based on algorithms from p. 604\n    of Seidelman, P. K. 1992.  Explanatory Supplement to\n    the Astronomical Almanac.  University Science Books,\n    Mill Valley.\n"]
    pub fn clock_calendar2utc(year: cty::c_int, month: cty::c_int, day: cty::c_int) -> time_t;
}
extern "C" {
    #[doc = " Name: clock_time2ticks\n\n Description:\n   Return the given struct timespec as systime ticks.\n\n   NOTE:  This is an internal OS interface and should not be called from\n   application code.\n\n Input Parameters:\n   reltime - Pointer to the time presented as struct timespec\n\n Output Parameters:\n   ticks - Pointer to receive the time value presented as systime ticks\n\n Returned Value:\n   Always returns OK (0)\n"]
    pub fn clock_time2ticks(reltime: *const timespec, ticks: *mut sclock_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: clock_ticks2time\n\n Description:\n   Return the given systime ticks as a struct timespec.\n\n   NOTE:  This is an internal OS interface and should not be called from\n   application code.\n\n Input Parameters:\n   ticks - Time presented as systime ticks\n\n Output Parameters:\n   reltime - Pointer to receive the time value presented as struct timespec\n\n Returned Value:\n   Always returns OK (0)\n"]
    pub fn clock_ticks2time(ticks: sclock_t, reltime: *mut timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: clock_systime_timespec\n\n Description:\n   Return the current value of the system timer counter as a struct\n   timespec.\n\n Input Parameters:\n   ts - Location to return the time\n\n Returned Value:\n   OK (0) on success; a negated errno value on failure.\n\n Assumptions:\n"]
    pub fn clock_systime_timespec(ts: *mut timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " perf_gettime"]
    pub fn perf_gettime() -> clock_t;
}
extern "C" {
    #[doc = " perf_convert"]
    pub fn perf_convert(elapsed: clock_t, ts: *mut timespec);
}
extern "C" {
    #[doc = " perf_gettfreq"]
    pub fn perf_getfreq() -> cty::c_ulong;
}
extern "C" {
    #[doc = " Name: nxsem_init\n\n Description:\n   This function initializes the UNNAMED semaphore sem. Following a\n   successful call to nxsem_init(), the semaphore may be used in subsequent\n   calls to nxsem_wait(), nxsem_post(), and nxsem_trywait().  The semaphore\n   remains usable until it is destroyed.\n\n   Only sem itself may be used for performing synchronization. The result\n   of referring to copies of sem in calls to sem_wait(), sem_trywait(),\n   sem_post(), and sem_destroy() is undefined.\n\n Input Parameters:\n   sem - Semaphore to be initialized\n   pshared - Process sharing (not used)\n   value - Semaphore initialization value\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_init(sem: *mut sem_t, pshared: cty::c_int, value: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_destroy\n\n Description:\n   This function is used to destroy the un-named semaphore indicated by\n   'sem'.  Only a semaphore that was created using nxsem_init() may be\n   destroyed using nxsem_destroy(); the effect of calling nxsem_destroy()\n   with a named semaphore is undefined.  The effect of subsequent use of\n   the semaphore sem is undefined until sem is re-initialized by another\n   call to nxsem_init().\n\n   The effect of destroying a semaphore upon which other processes are\n   currently blocked is undefined.\n\n Input Parameters:\n   sem - Semaphore to be destroyed.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_destroy(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_wait\n\n Description:\n   This function attempts to lock the semaphore referenced by 'sem'.  If\n   the semaphore value is (<=) zero, then the calling task will not return\n   until it successfully acquires the lock.\n\n   This is an internal OS interface.  It is functionally equivalent to\n   sem_wait except that:\n\n   - It is not a cancellation point, and\n   - It does not modify the errno value.\n\n Input Parameters:\n   sem - Semaphore descriptor.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     EINVAL - Invalid attempt to get the semaphore\n     EINTR  - The wait was interrupted by the receipt of a signal.\n"]
    pub fn nxsem_wait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_trywait\n\n Description:\n   This function locks the specified semaphore only if the semaphore is\n   currently not locked.  Otherwise, it locks the semaphore.  In either\n   case, the call returns without blocking.\n\n Input Parameters:\n   sem - the semaphore descriptor\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     EINVAL - Invalid attempt to get the semaphore\n     EAGAIN - The semaphore is not available.\n\n Assumptions:\n"]
    pub fn nxsem_trywait(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_timedwait\n\n Description:\n   This function will lock the semaphore referenced by sem as in the\n   sem_wait() function. However, if the semaphore cannot be locked without\n   waiting for another process or thread to unlock the semaphore by\n   performing a sem_post() function, this wait will be terminated when the\n   specified timeout expires.\n\n   The timeout will expire when the absolute time specified by abstime\n   passes, as measured by the clock on which timeouts are based (that is,\n   when the value of that clock equals or exceeds abstime), or if the\n   absolute time specified by abstime has already been passed at the\n   time of the call.\n\n   This is an internal OS interface.  It is functionally equivalent to\n   sem_wait except that:\n\n   - It is not a cancellation point, and\n   - It does not modify the errno value.\n\n Input Parameters:\n   sem     - Semaphore object\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   That may be one of:\n\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   EINTR     A signal interrupted this function.\n   ECANCELED May be returned if the thread is canceled while waiting.\n"]
    pub fn nxsem_timedwait(sem: *mut sem_t, abstime: *const timespec) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_clockwait\n\n Description:\n   This function will lock the semaphore referenced by sem as in the\n   sem_wait() function. However, if the semaphore cannot be locked without\n   waiting for another process or thread to unlock the semaphore by\n   performing a sem_post() function, this wait will be terminated when the\n   specified timeout expires.\n\n   The timeout will expire when the absolute time specified by abstime\n   passes, as measured by the clock on which timeouts are based (that is,\n   when the value of that clock equals or exceeds abstime), or if the\n   absolute time specified by abstime has already been passed at the\n   time of the call.\n\n   This is an internal OS interface.  It is functionally equivalent to\n   sem_wait except that:\n\n   - It is not a cancellation point, and\n   - It does not modify the errno value.\n\n Input Parameters:\n   sem     - Semaphore object\n   clockid - The timing source to use in the conversion\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   That may be one of:\n\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   EINTR     A signal interrupted this function.\n   ECANCELED May be returned if the thread is canceled while waiting.\n"]
    pub fn nxsem_clockwait(
        sem: *mut sem_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_tickwait\n\n Description:\n   This function is a lighter weight version of sem_timedwait().  It is\n   non-standard and intended only for use within the RTOS.\n\n Input Parameters:\n   sem     - Semaphore object\n   delay   - Ticks to wait from the start time until the semaphore is\n             posted.  If ticks is zero, then this function is equivalent\n             to sem_trywait().\n\n Returned Value:\n   This is an internal OS interface, not available to applications, and\n   hence follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure:\n\n     -ETIMEDOUT is returned on the timeout condition.\n     -ECANCELED may be returned if the thread is canceled while waiting.\n"]
    pub fn nxsem_tickwait(sem: *mut sem_t, delay: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_post\n\n Description:\n   When a kernel thread has finished with a semaphore, it will call\n   nxsem_post().  This function unlocks the semaphore referenced by sem\n   by performing the semaphore unlock operation on that semaphore.\n\n   If the semaphore value resulting from this operation is positive, then\n   no tasks were blocked waiting for the semaphore to become unlocked; the\n   semaphore is simply incremented.\n\n   If the value of the semaphore resulting from this operation is zero,\n   then one of the tasks blocked waiting for the semaphore shall be\n   allowed to return successfully from its call to sem_wait().\n\n Input Parameters:\n   sem - Semaphore descriptor\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n\n Assumptions:\n   This function may be called from an interrupt handler.\n"]
    pub fn nxsem_post(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name:  nxsem_get_value\n\n Description:\n   This function updates the location referenced by 'sval' argument to\n   have the value of the semaphore referenced by 'sem' without effecting\n   the state of the semaphore.  The updated value represents the actual\n   semaphore value that occurred at some unspecified time during the call,\n   but may not reflect the actual value of the semaphore when it is\n   returned to the calling task.\n\n   If 'sem' is locked, the value return by nxsem_get_value() will either be\n   zero or a negative number whose absolute value represents the number\n   of tasks waiting for the semaphore.\n\n Input Parameters:\n   sem - Semaphore descriptor\n   sval - Buffer by which the value is returned\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_get_value(sem: *mut sem_t, sval: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_open\n\n Description:\n   This function establishes a connection between named semaphores and a\n   task.  Following a call to sem_open() with the semaphore name, the task\n   may reference the semaphore associated with name using the address\n   returned by this call.  The semaphore may be used in subsequent calls\n   to sem_wait(), sem_trywait(), and sem_post().  The semaphore remains\n   usable until the semaphore is closed by a successful call to\n   sem_close().\n\n   If a task makes multiple calls to sem_open() with the same name, then\n   the same semaphore address is returned (provided there have been no\n   calls to sem_unlink()).\n\n Input Parameters:\n   name  - Semaphore name\n   oflags - Semaphore creation options.  This may either or both of the\n     following bit settings.\n     oflags = 0:  Connect to the semaphore only if it already exists.\n     oflags = O_CREAT:  Connect to the semaphore if it exists, otherwise\n        create the semaphore.\n     oflags = O_CREAT|O_EXCL:  Create a new semaphore\n        unless one of this name already exists.\n   Optional parameters.  When the O_CREAT flag is specified, two optional\n     parameters are expected:\n     1. mode_t mode, and\n     2. unsigned int value.  This initial value of the semaphore. Valid\n        initial values of the semaphore must be less than or equal to\n        SEM_VALUE_MAX.\n\n Returned Value:\n   A pointer to sem_t or negated errno if unsuccessful.\n\n Assumptions:\n"]
    pub fn nxsem_open(name: *const cty::c_char, oflags: cty::c_int, ...) -> *mut sem_t;
}
extern "C" {
    #[doc = " Name:  nxsem_close\n\n Description:\n   This function is called to indicate that the calling task is finished\n   with the specified named semaphore, 'sem'.  The sem_close() deallocates\n   any system resources allocated by the system for this named semaphore.\n\n   If the semaphore has not been removed with a call to sem_unlink(), then\n   sem_close() has no effect on the named semaphore.  However, when the\n   named semaphore has been fully unlinked, the semaphore will vanish when\n   the last task closes it.\n\n Input Parameters:\n  sem - semaphore descriptor\n\n Returned Value:\n  0 (OK), or negated errno if unsuccessful.\n\n Assumptions:\n   - Care must be taken to avoid risking the deletion of a semaphore that\n     another calling task has already locked.\n   - sem_close must not be called for an un-named semaphore\n"]
    pub fn nxsem_close(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_unlink\n\n Description:\n   This function removes the semaphore named by the input parameter 'name.'\n   If the semaphore named by 'name' is currently referenced by other task,\n   the sem_unlink() will have no effect on the state of the semaphore.  If\n   one or more processes have the semaphore open when sem_unlink() is\n   called, destruction of the semaphore will be postponed until all\n   references to the semaphore have been destroyed by calls of sem_close().\n\n Input Parameters:\n   name - Semaphore name\n\n Returned Value:\n  0 (OK), or negated errno if unsuccessful.\n\n Assumptions:\n"]
    pub fn nxsem_unlink(name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_reset\n\n Description:\n   Reset a semaphore count to a specific value.  This is similar to part\n   of the operation of nxsem_init().  But nxsem_reset() may need to wake up\n   tasks waiting on a count.  This kind of operation is sometimes required\n   within the OS (only) for certain error handling conditions.\n\n Input Parameters:\n   sem   - Semaphore descriptor to be reset\n   count - The requested semaphore count\n\n Returned Value:\n   This is an internal OS interface, not available to applications, and\n   hence follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_reset(sem: *mut sem_t, count: i16) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_set_protocol\n\n Description:\n    Set semaphore protocol attribute.\n\n    One particularly important use of this function is when a semaphore\n    is used for inter-task communication like:\n\n      TASK A                 TASK B\n      sem_init(sem, 0, 0);\n      sem_wait(sem);\n                             sem_post(sem);\n      Awakens as holder\n\n    In this case priority inheritance can interfere with the operation of\n    the semaphore.  The problem is that when TASK A is restarted it is a\n    holder of the semaphore.  However, it never calls sem_post(sem) so it\n    becomes *permanently* a holder of the semaphore and may have its\n    priority boosted when any other task tries to acquire the semaphore.\n\n    The fix is to call nxsem_set_protocol(SEM_PRIO_NONE) immediately after\n    the sem_init() call so that there will be no priority inheritance\n    operations on this semaphore.\n\n Input Parameters:\n    sem      - A pointer to the semaphore whose attributes are to be\n               modified\n    protocol - The new protocol to use\n\n Returned Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxsem_set_protocol(sem: *mut sem_t, protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_wait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_wait(), which is\n   uninterruptible and convenient for use.\n\n Parameters:\n   sem - Semaphore descriptor.\n\n Return Value:\n   Zero(OK)  - On success\n   EINVAL    - Invalid attempt to get the semaphore\n   ECANCELED - May be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_wait_uninterruptible(sem: *mut sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_timedwait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_timedwait(), which is\n   uninterruptible and convenient for use.\n\n Input Parameters:\n   sem     - Semaphore object\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   ECANCELED May be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_timedwait_uninterruptible(sem: *mut sem_t, abstime: *const timespec)
        -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_clockwait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_clockwait(), which is\n   uninterruptible and convenient for use.\n\n Input Parameters:\n   sem     - Semaphore object\n   clockid - The timing source to use in the conversion\n   abstime - The absolute time to wait until a timeout is declared.\n\n Returned Value:\n   EINVAL    The sem argument does not refer to a valid semaphore.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The semaphore could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   ECANCELED May be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_clockwait_uninterruptible(
        sem: *mut sem_t,
        clockid: clockid_t,
        abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxsem_tickwait_uninterruptible\n\n Description:\n   This function is wrapped version of nxsem_tickwait(), which is\n   uninterruptible and convenient for use.\n\n Input Parameters:\n   sem     - Semaphore object\n   delay   - Ticks to wait from the start time until the semaphore is\n             posted.  If ticks is zero, then this function is equivalent\n             to sem_trywait().\n\n Returned Value:\n   This is an internal OS interface, not available to applications, and\n   hence follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure:\n\n     -ETIMEDOUT is returned on the timeout condition.\n     -ECANCELED may be returned if the thread is canceled while waiting.\n\n NOTE:  It is essential that callers of this function handle the\n ECANCELED error.  Correct handling is that the function should return the\n error and the error should propagate back up the calling tree to the\n cancellation point interface function where the thread termination will\n be handled gracefully\n"]
    pub fn nxsem_tickwait_uninterruptible(sem: *mut sem_t, delay: u32) -> cty::c_int;
}
#[doc = " Public Type Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex_s {
    pub sem: sem_t,
    pub holder: pid_t,
}
#[doc = " Public Type Definitions"]
pub type mutex_t = mutex_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmutex_s {
    pub mutex: mutex_t,
    pub count: cty::c_uint,
}
pub type rmutex_t = rmutex_s;
extern "C" {
    #[doc = " Name: nxmutex_init\n\n Description:\n   This function initializes the UNNAMED mutex. Following a\n   successful call to nxmutex_init(), the mutex may be used in subsequent\n   calls to nxmutex_lock(), nxmutex_unlock(), and nxmutex_trylock().  The\n   mutex remains usable until it is destroyed.\n\n Parameters:\n   mutex - Semaphore to be initialized\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxmutex_init(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_destroy\n\n Description:\n   This function initializes the UNNAMED mutex. Following a\n   successful call to nxmutex_init(), the mutex may be used in subsequent\n   calls to nxmutex_lock(), nxmutex_unlock(), and nxmutex_trylock().  The\n   mutex remains usable until it is destroyed.\n\n Parameters:\n   mutex - Semaphore to be destroyed\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxmutex_destroy(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_is_hold\n\n Description:\n   This function check whether the caller hold the mutex\n   referenced by 'mutex'.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n"]
    pub fn nxmutex_is_hold(mutex: *mut mutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nxmutex_is_locked\n\n Description:\n   This function get the lock state the mutex referenced by 'mutex'.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n"]
    pub fn nxmutex_is_locked(mutex: *mut mutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nxmutex_lock\n\n Description:\n   This function attempts to lock the mutex referenced by 'mutex'.  The\n   mutex is implemented with a semaphore, so if the semaphore value is\n   (<=) zero, then the calling task will not return until it successfully\n   acquires the lock.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxmutex_lock(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_trylock\n\n Description:\n   This function locks the mutex only if the mutex is currently not locked.\n   If the mutex has been locked already, the call returns without blocking.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     -EINVAL - Invalid attempt to lock the mutex\n     -EAGAIN - The mutex is not available.\n"]
    pub fn nxmutex_trylock(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_timedlock\n\n Description:\n   This function attempts to lock the mutex .  If the mutex value\n   is (<=) zero,then the calling task will not return until it\n   successfully acquires the lock or timed out\n\n Input Parameters:\n   mutex   - Mutex object\n   timeout - The time when mutex lock timed out\n\n Returned Value:\n   OK        The mutex successfully acquires\n   EINVAL    The mutex argument does not refer to a valid mutex.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The mutex could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n"]
    pub fn nxmutex_timedlock(mutex: *mut mutex_t, timeout: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_unlock\n\n Description:\n   This function attempts to unlock the mutex referenced by 'mutex'.\n\n Parameters:\n   mutex - mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n Assumptions:\n   This function may be called from an interrupt handler.\n"]
    pub fn nxmutex_unlock(mutex: *mut mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn nxmutex_reset(mutex: *mut mutex_t);
}
extern "C" {
    #[doc = " Name: nxmutex_breaklock\n\n Description:\n   This function attempts to break the mutex\n\n Parameters:\n   mutex   - Mutex descriptor.\n   locked  - Is the mutex break success\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxmutex_breaklock(mutex: *mut mutex_t, locked: *mut bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxmutex_restorelock\n\n Description:\n   This function attempts to restore the mutex.\n\n Parameters:\n   mutex   - mutex descriptor.\n   locked  - true: it's mean that the mutex is broke success\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure\n"]
    pub fn nxmutex_restorelock(mutex: *mut mutex_t, locked: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_init\n\n Description:\n   This function initializes the UNNAMED recursive mutex. Following a\n   successful call to nxrmutex_init(), the recursive mutex may be used in\n   subsequent calls to nxrmutex_lock(), nxrmutex_unlock(),\n   and nxrmutex_trylock(). The recursive mutex remains usable\n   until it is destroyed.\n\n Parameters:\n   rmutex - Recursive mutex to be initialized\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxrmutex_init(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_destroy\n\n Description:\n   This function destroy the UNNAMED recursive mutex.\n\n Parameters:\n   rmutex - Recursive mutex to be destroyed\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n"]
    pub fn nxrmutex_destroy(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_is_hold\n\n Description:\n   This function check whether the caller hold the recursive mutex\n   referenced by 'rmutex'.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n"]
    pub fn nxrmutex_is_hold(rmutex: *mut rmutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nxrmutex_is_locked\n\n Description:\n   This function get the lock state the recursive mutex\n   referenced by 'rmutex'.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n"]
    pub fn nxrmutex_is_locked(rmutex: *mut rmutex_t) -> bool;
}
extern "C" {
    #[doc = " Name: nrxmutex_lock\n\n Description:\n   This function attempts to lock the recursive mutex referenced by\n   'rmutex'.The recursive mutex can be locked multiple times in the same\n   thread.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxrmutex_lock(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_trylock\n\n Description:\n   This function locks the recursive mutex if the recursive mutex is\n   currently not locked or the same thread call.\n   If the recursive mutex is locked and other thread call it,\n   the call returns without blocking.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n     -EINVAL - Invalid attempt to lock the recursive mutex\n     -EAGAIN - The recursive mutex is not available.\n"]
    pub fn nxrmutex_trylock(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_timedlock\n\n Description:\n   This function attempts to lock the mutex .  If the mutex value\n   is (<=) zero,then the calling task will not return until it\n   successfully acquires the lock or timed out\n\n Input Parameters:\n   rmutex  - Rmutex object\n   timeout - The time when mutex lock timed out\n\n Returned Value:\n   OK        The mutex successfully acquires\n   EINVAL    The mutex argument does not refer to a valid mutex.  Or the\n             thread would have blocked, and the abstime parameter specified\n             a nanoseconds field value less than zero or greater than or\n             equal to 1000 million.\n   ETIMEDOUT The mutex could not be locked before the specified timeout\n             expired.\n   EDEADLK   A deadlock condition was detected.\n   ECANCELED May be returned if the thread is canceled while waiting.\n"]
    pub fn nxrmutex_timedlock(rmutex: *mut rmutex_t, timeout: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_unlock\n\n Description:\n   This function attempts to unlock the recursive mutex\n   referenced by 'rmutex'.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n\n Assumptions:\n   This function may be called from an interrupt handler.\n"]
    pub fn nxrmutex_unlock(rmutex: *mut rmutex_t) -> cty::c_int;
}
extern "C" {
    pub fn nxrmutex_reset(rmutex: *mut rmutex_t);
}
extern "C" {
    #[doc = " Name: nrxmutex_breaklock\n\n Description:\n   This function attempts to break the recursive mutex\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxrmutex_breaklock(rmutex: *mut rmutex_t, count: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: nxrmutex_restorelock\n\n Description:\n   This function attempts to restore the recursive mutex.\n\n Parameters:\n   rmutex - Recursive mutex descriptor.\n\n Return Value:\n   This is an internal OS interface and should not be used by applications.\n   It follows the NuttX internal error return policy:  Zero (OK) is\n   returned on success.  A negated errno value is returned on failure.\n   Possible returned errors:\n"]
    pub fn nxrmutex_restorelock(rmutex: *mut rmutex_t, count: cty::c_uint) -> cty::c_int;
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_devaddr_s {
    pub next: u8,
    pub lock: mutex_t,
    pub alloctab: [u32; 4usize],
}
extern "C" {
    #[doc = " Name: usbhost_devaddr_initialize\n\n Description:\n   Initialize the caller provided struct usbhost_devaddr_s instance in\n   preparation for the management of device addresses on behalf of an root\n   hub port.\n\n Input Parameters:\n   devgen - A reference to a usbhost_devaddr_s structure.\n\n Returned Value:\n   On success, zero (OK) is returned. On a failure, a negated errno value\n   is returned indicating the nature of the failure.\n"]
    pub fn usbhost_devaddr_initialize(devgen: *mut usbhost_devaddr_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_devaddr_create\n\n Description:\n   Create a new unique device address for this hub port.\n\n Input Parameters:\n   hport - A reference to a hub port structure to which a device has been\n     newly connected and so is in need of a function address.\n\n Returned Value:\n   On success, a new device function address in the range 0x01 to 0x7f\n   is returned.  On failure, a negated errno value is returned.\n"]
    pub fn usbhost_devaddr_create(hport: *mut usbhost_hubport_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_devaddr_destroy\n\n Description:\n  Release a device address previously assigned by usbhost_devaddr_create().\n\n Input Parameters:\n  hport - A reference to a hub port structure from which a device has been\n     disconnected and so no longer needs the function address.\n  devaddr - The address to be released.\n\n Returned Value:\n   None\n"]
    pub fn usbhost_devaddr_destroy(hport: *mut usbhost_hubport_s, devaddr: u8);
}
#[doc = " Public Types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_id_s {
    pub base: u8,
    pub subclass: u8,
    pub proto: u8,
    pub vid: u16,
    pub pid: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_registry_s {
    pub flink: *mut usbhost_registry_s,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            hub: *mut usbhost_hubport_s,
            id: *const usbhost_id_s,
        ) -> *mut usbhost_class_s,
    >,
    pub nids: u8,
    pub id: *const usbhost_id_s,
}
pub type usbhost_ep_t = *mut cty::c_void;
#[doc = " Public Functions Definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_hubport_s {
    pub drvr: *mut usbhost_driver_s,
    pub devclass: *mut usbhost_class_s,
    pub ep0: usbhost_ep_t,
    pub connected: bool,
    pub port: u8,
    pub funcaddr: u8,
    pub speed: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_roothubport_s {
    pub hport: usbhost_hubport_s,
    pub pdevgen: *mut usbhost_devaddr_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_class_s {
    pub hport: *mut usbhost_hubport_s,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            devclass: *mut usbhost_class_s,
            configdesc: *const u8,
            desclen: cty::c_int,
        ) -> cty::c_int,
    >,
    pub disconnected:
        ::core::option::Option<unsafe extern "C" fn(devclass: *mut usbhost_class_s) -> cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_epdesc_s {
    pub hport: *mut usbhost_hubport_s,
    pub addr: u8,
    pub in_: bool,
    pub xfrtype: u8,
    pub interval: u8,
    pub mxpacketsize: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_connection_s {
    pub wait: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut usbhost_connection_s,
            hport: *mut *mut usbhost_hubport_s,
        ) -> cty::c_int,
    >,
    pub enumerate: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut usbhost_connection_s,
            hport: *mut usbhost_hubport_s,
        ) -> cty::c_int,
    >,
}
pub type usbhost_asynch_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void, result: isize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbhost_driver_s {
    pub ep0configure: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep0: usbhost_ep_t,
            funcaddr: u8,
            speed: u8,
            maxpacketsize: u16,
        ) -> cty::c_int,
    >,
    pub epalloc: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            epdesc: *const usbhost_epdesc_s,
            ep: *mut usbhost_ep_t,
        ) -> cty::c_int,
    >,
    pub epfree: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, ep: usbhost_ep_t) -> cty::c_int,
    >,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            buffer: *mut *mut u8,
            maxlen: *mut usize,
        ) -> cty::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, buffer: *mut u8) -> cty::c_int,
    >,
    pub ioalloc: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            buffer: *mut *mut u8,
            buflen: usize,
        ) -> cty::c_int,
    >,
    pub iofree: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, buffer: *mut u8) -> cty::c_int,
    >,
    pub ctrlin: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep0: usbhost_ep_t,
            req: *mut usb_ctrlreq_s,
            buffer: *mut u8,
        ) -> cty::c_int,
    >,
    pub ctrlout: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep0: usbhost_ep_t,
            req: *const usb_ctrlreq_s,
            buffer: *const u8,
        ) -> cty::c_int,
    >,
    pub transfer: ::core::option::Option<
        unsafe extern "C" fn(
            drvr: *mut usbhost_driver_s,
            ep: usbhost_ep_t,
            buffer: *mut u8,
            buflen: usize,
        ) -> isize,
    >,
    pub cancel: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, ep: usbhost_ep_t) -> cty::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(drvr: *mut usbhost_driver_s, hport: *mut usbhost_hubport_s),
    >,
}
extern "C" {
    #[doc = " Name: usbhost_registerclass\n\n Description:\n   Register a USB host class implementation.  The caller provides an\n   instance of struct usbhost_registry_s that contains all of the\n   information that will be needed later to (1) associate the USB host\n   class implementation with a connected USB device, and (2) to obtain and\n   bind a struct usbhost_class_s instance for the device.\n\n Input Parameters:\n   devclass - An write-able instance of struct usbhost_registry_s that will\n     be maintained in a registry.\n\n Returned Value:\n   On success, this function will return zero (OK).  Otherwise, a negated\n   errno value is returned.\n"]
    pub fn usbhost_registerclass(devclass: *mut usbhost_registry_s) -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_findclass\n\n Description:\n   Find a USB host class implementation previously registered by\n   usbhost_registerclass().  On success, an instance of struct\n   usbhost_registry_s will be returned.  That instance will contain all of\n   the information that will be needed to obtain and bind a struct\n   usbhost_class_s instance for the device.\n\n Input Parameters:\n   id - Identifies the USB device class that has connect to the USB host.\n\n Returned Value:\n   On success this function will return a non-NULL instance of struct\n   usbhost_registry_s.  NULL will be returned on failure.  This function\n   can only fail if (1) id is NULL, or (2) no USB host class is registered\n   that matches the device class ID.\n"]
    pub fn usbhost_findclass(id: *const usbhost_id_s) -> *const usbhost_registry_s;
}
extern "C" {
    #[doc = " Name: usbhost_wlaninit\n\n Description:\n   Initialize the USB WLAN class driver.  This function should be called\n   by platform-specific code in order to initialize and register support\n   for the USB host class device.\n\n Input Parameters:\n   None\n\n Returned Value:\n   On success this function will return zero (OK);  A negated errno value\n   will be returned on failure.\n"]
    pub fn usbhost_wlaninit() -> cty::c_int;
}
extern "C" {
    #[doc = " Name: usbhost_enumerate\n\n Description:\n   This is a share-able implementation of most of the logic required by the\n   driver enumerate() method.  This logic within this method should be\n   common to all USB host drivers.\n\n   Enumerate the connected device.  As part of this enumeration process,\n   the driver will (1) get the device's configuration descriptor, (2)\n   extract the class ID info from the configuration descriptor, (3) call\n   usbhost_findclass() to find the class that supports this device, (4)\n   call the create() method on the struct usbhost_registry_s interface\n   to get a class instance, and finally (5) call the configdesc() method\n   of the struct usbhost_class_s interface.  After that, the class is in\n   charge of the sequence of operations.\n\n Input Parameters:\n   hub - The hub that manages the new class.\n   devclass - If the class driver for the device is successful located\n      and bound to the hub, the allocated class instance is returned into\n      this caller-provided memory location.\n\n Returned Value:\n   On success, zero (OK) is returned. On a failure, a negated errno value\n   is returned indicating the nature of the failure\n\n Assumptions:\n   - Only a single class bound to a single device is supported.\n   - Called from a single thread so no mutual exclusion is required.\n   - Never called from an interrupt handler.\n"]
    pub fn usbhost_enumerate(
        hub: *mut usbhost_hubport_s,
        devclass: *mut *mut usbhost_class_s,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ctrlreq_s {
    _unused: [u8; 0],
}
